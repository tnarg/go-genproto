// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/spanner/v1/query_plan.proto

package spanner

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The kind of [PlanNode][google.spanner.v1.PlanNode]. Distinguishes between the two different kinds of
// nodes that can appear in a query plan.
type PlanNode_Kind int32

const (
	// Not specified.
	PlanNode_KIND_UNSPECIFIED PlanNode_Kind = 0
	// Denotes a Relational operator node in the expression tree. Relational
	// operators represent iterative processing of rows during query execution.
	// For example, a `TableScan` operation that reads rows from a table.
	PlanNode_RELATIONAL PlanNode_Kind = 1
	// Denotes a Scalar node in the expression tree. Scalar nodes represent
	// non-iterable entities in the query plan. For example, constants or
	// arithmetic operators appearing inside predicate expressions or references
	// to column names.
	PlanNode_SCALAR PlanNode_Kind = 2
)

var PlanNode_Kind_name = map[int32]string{
	0: "KIND_UNSPECIFIED",
	1: "RELATIONAL",
	2: "SCALAR",
}
var PlanNode_Kind_value = map[string]int32{
	"KIND_UNSPECIFIED": 0,
	"RELATIONAL":       1,
	"SCALAR":           2,
}

func (x PlanNode_Kind) String() string {
	return proto.EnumName(PlanNode_Kind_name, int32(x))
}
func (PlanNode_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorQueryPlan, []int{0, 0} }

// Node information for nodes appearing in a [QueryPlan.plan_nodes][google.spanner.v1.QueryPlan.plan_nodes].
type PlanNode struct {
	// The `PlanNode`'s index in [node list][google.spanner.v1.QueryPlan.plan_nodes].
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// Used to determine the type of node. May be needed for visualizing
	// different kinds of nodes differently. For example, If the node is a
	// [SCALAR][google.spanner.v1.PlanNode.Kind.SCALAR] node, it will have a condensed representation
	// which can be used to directly embed a description of the node in its
	// parent.
	Kind PlanNode_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=google.spanner.v1.PlanNode_Kind" json:"kind,omitempty"`
	// The display name for the node.
	DisplayName string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// List of child node `index`es and their relationship to this parent.
	ChildLinks []*PlanNode_ChildLink `protobuf:"bytes,4,rep,name=child_links,json=childLinks" json:"child_links,omitempty"`
	// Condensed representation for [SCALAR][google.spanner.v1.PlanNode.Kind.SCALAR] nodes.
	ShortRepresentation *PlanNode_ShortRepresentation `protobuf:"bytes,5,opt,name=short_representation,json=shortRepresentation" json:"short_representation,omitempty"`
	// Attributes relevant to the node contained in a group of key-value pairs.
	// For example, a Parameter Reference node could have the following
	// information in its metadata:
	//
	//     {
	//       "parameter_reference": "param1",
	//       "parameter_type": "array"
	//     }
	Metadata *google_protobuf1.Struct `protobuf:"bytes,6,opt,name=metadata" json:"metadata,omitempty"`
	// The execution statistics associated with the node, contained in a group of
	// key-value pairs. Only present if the plan was returned as a result of a
	// profile query. For example, number of executions, number of rows/time per
	// execution etc.
	ExecutionStats *google_protobuf1.Struct `protobuf:"bytes,7,opt,name=execution_stats,json=executionStats" json:"execution_stats,omitempty"`
}

func (m *PlanNode) Reset()                    { *m = PlanNode{} }
func (m *PlanNode) String() string            { return proto.CompactTextString(m) }
func (*PlanNode) ProtoMessage()               {}
func (*PlanNode) Descriptor() ([]byte, []int) { return fileDescriptorQueryPlan, []int{0} }

func (m *PlanNode) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PlanNode) GetKind() PlanNode_Kind {
	if m != nil {
		return m.Kind
	}
	return PlanNode_KIND_UNSPECIFIED
}

func (m *PlanNode) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *PlanNode) GetChildLinks() []*PlanNode_ChildLink {
	if m != nil {
		return m.ChildLinks
	}
	return nil
}

func (m *PlanNode) GetShortRepresentation() *PlanNode_ShortRepresentation {
	if m != nil {
		return m.ShortRepresentation
	}
	return nil
}

func (m *PlanNode) GetMetadata() *google_protobuf1.Struct {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *PlanNode) GetExecutionStats() *google_protobuf1.Struct {
	if m != nil {
		return m.ExecutionStats
	}
	return nil
}

// Metadata associated with a parent-child relationship appearing in a
// [PlanNode][google.spanner.v1.PlanNode].
type PlanNode_ChildLink struct {
	// The node to which the link points.
	ChildIndex int32 `protobuf:"varint,1,opt,name=child_index,json=childIndex,proto3" json:"child_index,omitempty"`
	// The type of the link. For example, in Hash Joins this could be used to
	// distinguish between the build child and the probe child, or in the case
	// of the child being an output variable, to represent the tag associated
	// with the output variable.
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Only present if the child node is [SCALAR][google.spanner.v1.PlanNode.Kind.SCALAR] and corresponds
	// to an output variable of the parent node. The field carries the name of
	// the output variable.
	// For example, a `TableScan` operator that reads rows from a table will
	// have child links to the `SCALAR` nodes representing the output variables
	// created for each column that is read by the operator. The corresponding
	// `variable` fields will be set to the variable names assigned to the
	// columns.
	Variable string `protobuf:"bytes,3,opt,name=variable,proto3" json:"variable,omitempty"`
}

func (m *PlanNode_ChildLink) Reset()                    { *m = PlanNode_ChildLink{} }
func (m *PlanNode_ChildLink) String() string            { return proto.CompactTextString(m) }
func (*PlanNode_ChildLink) ProtoMessage()               {}
func (*PlanNode_ChildLink) Descriptor() ([]byte, []int) { return fileDescriptorQueryPlan, []int{0, 0} }

func (m *PlanNode_ChildLink) GetChildIndex() int32 {
	if m != nil {
		return m.ChildIndex
	}
	return 0
}

func (m *PlanNode_ChildLink) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PlanNode_ChildLink) GetVariable() string {
	if m != nil {
		return m.Variable
	}
	return ""
}

// Condensed representation of a node and its subtree. Only present for
// `SCALAR` [PlanNode(s)][google.spanner.v1.PlanNode].
type PlanNode_ShortRepresentation struct {
	// A string representation of the expression subtree rooted at this node.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// A mapping of (subquery variable name) -> (subquery node id) for cases
	// where the `description` string of this node references a `SCALAR`
	// subquery contained in the expression subtree rooted at this node. The
	// referenced `SCALAR` subquery may not necessarily be a direct child of
	// this node.
	Subqueries map[string]int32 `protobuf:"bytes,2,rep,name=subqueries" json:"subqueries,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *PlanNode_ShortRepresentation) Reset()         { *m = PlanNode_ShortRepresentation{} }
func (m *PlanNode_ShortRepresentation) String() string { return proto.CompactTextString(m) }
func (*PlanNode_ShortRepresentation) ProtoMessage()    {}
func (*PlanNode_ShortRepresentation) Descriptor() ([]byte, []int) {
	return fileDescriptorQueryPlan, []int{0, 1}
}

func (m *PlanNode_ShortRepresentation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PlanNode_ShortRepresentation) GetSubqueries() map[string]int32 {
	if m != nil {
		return m.Subqueries
	}
	return nil
}

// Contains an ordered list of nodes appearing in the query plan.
type QueryPlan struct {
	// The nodes in the query plan. Plan nodes are returned in pre-order starting
	// with the plan root. Each [PlanNode][google.spanner.v1.PlanNode]'s `id` corresponds to its index in
	// `plan_nodes`.
	PlanNodes []*PlanNode `protobuf:"bytes,1,rep,name=plan_nodes,json=planNodes" json:"plan_nodes,omitempty"`
}

func (m *QueryPlan) Reset()                    { *m = QueryPlan{} }
func (m *QueryPlan) String() string            { return proto.CompactTextString(m) }
func (*QueryPlan) ProtoMessage()               {}
func (*QueryPlan) Descriptor() ([]byte, []int) { return fileDescriptorQueryPlan, []int{1} }

func (m *QueryPlan) GetPlanNodes() []*PlanNode {
	if m != nil {
		return m.PlanNodes
	}
	return nil
}

func init() {
	proto.RegisterType((*PlanNode)(nil), "google.spanner.v1.PlanNode")
	proto.RegisterType((*PlanNode_ChildLink)(nil), "google.spanner.v1.PlanNode.ChildLink")
	proto.RegisterType((*PlanNode_ShortRepresentation)(nil), "google.spanner.v1.PlanNode.ShortRepresentation")
	proto.RegisterType((*QueryPlan)(nil), "google.spanner.v1.QueryPlan")
	proto.RegisterEnum("google.spanner.v1.PlanNode_Kind", PlanNode_Kind_name, PlanNode_Kind_value)
}
func (m *PlanNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(m.Index))
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(m.Kind))
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if len(m.ChildLinks) > 0 {
		for _, msg := range m.ChildLinks {
			dAtA[i] = 0x22
			i++
			i = encodeVarintQueryPlan(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ShortRepresentation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(m.ShortRepresentation.Size()))
		n1, err := m.ShortRepresentation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Metadata != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(m.Metadata.Size()))
		n2, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ExecutionStats != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(m.ExecutionStats.Size()))
		n3, err := m.ExecutionStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *PlanNode_ChildLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanNode_ChildLink) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChildIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(m.ChildIndex))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Variable) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(len(m.Variable)))
		i += copy(dAtA[i:], m.Variable)
	}
	return i, nil
}

func (m *PlanNode_ShortRepresentation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanNode_ShortRepresentation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQueryPlan(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Subqueries) > 0 {
		for k, _ := range m.Subqueries {
			dAtA[i] = 0x12
			i++
			v := m.Subqueries[k]
			mapSize := 1 + len(k) + sovQueryPlan(uint64(len(k))) + 1 + sovQueryPlan(uint64(v))
			i = encodeVarintQueryPlan(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintQueryPlan(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintQueryPlan(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *QueryPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPlan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlanNodes) > 0 {
		for _, msg := range m.PlanNodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintQueryPlan(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64QueryPlan(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32QueryPlan(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintQueryPlan(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PlanNode) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovQueryPlan(uint64(m.Index))
	}
	if m.Kind != 0 {
		n += 1 + sovQueryPlan(uint64(m.Kind))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovQueryPlan(uint64(l))
	}
	if len(m.ChildLinks) > 0 {
		for _, e := range m.ChildLinks {
			l = e.Size()
			n += 1 + l + sovQueryPlan(uint64(l))
		}
	}
	if m.ShortRepresentation != nil {
		l = m.ShortRepresentation.Size()
		n += 1 + l + sovQueryPlan(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovQueryPlan(uint64(l))
	}
	if m.ExecutionStats != nil {
		l = m.ExecutionStats.Size()
		n += 1 + l + sovQueryPlan(uint64(l))
	}
	return n
}

func (m *PlanNode_ChildLink) Size() (n int) {
	var l int
	_ = l
	if m.ChildIndex != 0 {
		n += 1 + sovQueryPlan(uint64(m.ChildIndex))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovQueryPlan(uint64(l))
	}
	l = len(m.Variable)
	if l > 0 {
		n += 1 + l + sovQueryPlan(uint64(l))
	}
	return n
}

func (m *PlanNode_ShortRepresentation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovQueryPlan(uint64(l))
	}
	if len(m.Subqueries) > 0 {
		for k, v := range m.Subqueries {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQueryPlan(uint64(len(k))) + 1 + sovQueryPlan(uint64(v))
			n += mapEntrySize + 1 + sovQueryPlan(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *QueryPlan) Size() (n int) {
	var l int
	_ = l
	if len(m.PlanNodes) > 0 {
		for _, e := range m.PlanNodes {
			l = e.Size()
			n += 1 + l + sovQueryPlan(uint64(l))
		}
	}
	return n
}

func sovQueryPlan(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQueryPlan(x uint64) (n int) {
	return sovQueryPlan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PlanNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (PlanNode_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildLinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildLinks = append(m.ChildLinks, &PlanNode_ChildLink{})
			if err := m.ChildLinks[len(m.ChildLinks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortRepresentation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShortRepresentation == nil {
				m.ShortRepresentation = &PlanNode_ShortRepresentation{}
			}
			if err := m.ShortRepresentation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &google_protobuf1.Struct{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecutionStats == nil {
				m.ExecutionStats = &google_protobuf1.Struct{}
			}
			if err := m.ExecutionStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQueryPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanNode_ChildLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChildLink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChildLink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildIndex", wireType)
			}
			m.ChildIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChildIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQueryPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanNode_ShortRepresentation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShortRepresentation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShortRepresentation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subqueries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subqueries == nil {
				m.Subqueries = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQueryPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQueryPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQueryPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQueryPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQueryPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthQueryPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Subqueries[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQueryPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQueryPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQueryPlan
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanNodes = append(m.PlanNodes, &PlanNode{})
			if err := m.PlanNodes[len(m.PlanNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQueryPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQueryPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQueryPlan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQueryPlan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQueryPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQueryPlan
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQueryPlan
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQueryPlan(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQueryPlan = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQueryPlan   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/spanner/v1/query_plan.proto", fileDescriptorQueryPlan) }

var fileDescriptorQueryPlan = []byte{
	// 608 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xfe, 0x6d, 0x9a, 0xe4, 0xd7, 0x4c, 0x50, 0x1a, 0xb6, 0x45, 0xb5, 0x02, 0x2a, 0x26, 0x12,
	0x52, 0x4e, 0xb6, 0xda, 0x72, 0xa8, 0x8a, 0x10, 0xa4, 0x69, 0x5a, 0x45, 0x8d, 0x42, 0x58, 0x03,
	0x07, 0x84, 0x64, 0x6d, 0xe2, 0x25, 0x5d, 0xc5, 0xd9, 0x35, 0x5e, 0x3b, 0x6a, 0x1e, 0x81, 0x0b,
	0x0f, 0xc2, 0x93, 0x70, 0xe4, 0xc6, 0x15, 0xf5, 0x49, 0x90, 0xd7, 0x7f, 0x28, 0x14, 0x45, 0xe2,
	0x36, 0xb3, 0xf3, 0x7d, 0x9f, 0x77, 0xbe, 0x99, 0x35, 0xb4, 0x67, 0x52, 0xce, 0x7c, 0x66, 0xab,
	0x80, 0x0a, 0xc1, 0x42, 0x7b, 0xb9, 0x6f, 0x7f, 0x8c, 0x59, 0xb8, 0x72, 0x03, 0x9f, 0x0a, 0x2b,
	0x08, 0x65, 0x24, 0xf1, 0xdd, 0x14, 0x63, 0x65, 0x18, 0x6b, 0xb9, 0xdf, 0x7a, 0x90, 0xd1, 0x68,
	0xc0, 0x6d, 0x2a, 0x84, 0x8c, 0x68, 0xc4, 0xa5, 0x50, 0x29, 0xa1, 0xa8, 0xea, 0x6c, 0x12, 0x7f,
	0xb0, 0x55, 0x14, 0xc6, 0xd3, 0x28, 0xad, 0xb6, 0x3f, 0x57, 0x61, 0x73, 0xec, 0x53, 0x31, 0x92,
	0x1e, 0xc3, 0x3b, 0x50, 0xe1, 0xc2, 0x63, 0x57, 0x06, 0x32, 0x51, 0xa7, 0x42, 0xd2, 0x04, 0x3f,
	0x81, 0xf2, 0x9c, 0x0b, 0xcf, 0x28, 0x99, 0xa8, 0xd3, 0x38, 0x30, 0xad, 0x5b, 0x17, 0xb0, 0x72,
	0x01, 0xeb, 0x82, 0x0b, 0x8f, 0x68, 0x34, 0x7e, 0x04, 0x77, 0x3c, 0xae, 0x02, 0x9f, 0xae, 0x5c,
	0x41, 0x17, 0xcc, 0xd8, 0x30, 0x51, 0xa7, 0x46, 0xea, 0xd9, 0xd9, 0x88, 0x2e, 0x18, 0x3e, 0x83,
	0xfa, 0xf4, 0x92, 0xfb, 0x9e, 0xeb, 0x73, 0x31, 0x57, 0x46, 0xd9, 0xdc, 0xe8, 0xd4, 0x0f, 0x1e,
	0xaf, 0xd3, 0xef, 0x25, 0xf0, 0x21, 0x17, 0x73, 0x02, 0xd3, 0x3c, 0x54, 0x78, 0x02, 0x3b, 0xea,
	0x52, 0x86, 0x91, 0x1b, 0xb2, 0x20, 0x64, 0x8a, 0x89, 0xd4, 0x00, 0xa3, 0x62, 0xa2, 0x4e, 0xfd,
	0xc0, 0x5e, 0x27, 0xe8, 0x24, 0x3c, 0xf2, 0x1b, 0x8d, 0x6c, 0xab, 0xdb, 0x87, 0xf8, 0x10, 0x36,
	0x17, 0x2c, 0xa2, 0x1e, 0x8d, 0xa8, 0x51, 0xd5, 0xba, 0xbb, 0xb9, 0x6e, 0x6e, 0xac, 0xe5, 0x68,
	0x63, 0x49, 0x01, 0xc4, 0x2f, 0x60, 0x8b, 0x5d, 0xb1, 0x69, 0x9c, 0x28, 0xb8, 0x2a, 0xa2, 0x91,
	0x32, 0xfe, 0x5f, 0xcf, 0x6d, 0x14, 0x78, 0x27, 0x81, 0xb7, 0xde, 0x43, 0xad, 0xe8, 0x19, 0x3f,
	0xcc, 0xfd, 0xba, 0x39, 0xa4, 0xd4, 0x88, 0x81, 0x9e, 0x14, 0x86, 0x72, 0xb4, 0x0a, 0x98, 0x9e,
	0x54, 0x8d, 0xe8, 0x18, 0xb7, 0x60, 0x73, 0x49, 0x43, 0x4e, 0x27, 0x7e, 0x3e, 0x83, 0x22, 0x6f,
	0x7d, 0x47, 0xb0, 0xfd, 0x17, 0x07, 0xb0, 0x09, 0x75, 0x8f, 0xa9, 0x69, 0xc8, 0x03, 0xed, 0x23,
	0xca, 0x46, 0xf7, 0xeb, 0x08, 0xbb, 0x00, 0x2a, 0x9e, 0x24, 0xcb, 0xc9, 0x99, 0x32, 0x4a, 0x7a,
	0x72, 0xcf, 0xff, 0xd1, 0x68, 0xcb, 0x29, 0x14, 0xfa, 0x22, 0x0a, 0x57, 0xe4, 0x86, 0x64, 0xeb,
	0x19, 0x6c, 0xfd, 0x51, 0xc6, 0x4d, 0xd8, 0x98, 0xb3, 0x55, 0x76, 0x9b, 0x24, 0x4c, 0xf6, 0x75,
	0x49, 0xfd, 0x38, 0x6d, 0xb8, 0x42, 0xd2, 0xe4, 0xb8, 0x74, 0x84, 0xda, 0x47, 0x50, 0x4e, 0x76,
	0x11, 0xef, 0x40, 0xf3, 0x62, 0x30, 0x3a, 0x75, 0xdf, 0x8c, 0x9c, 0x71, 0xbf, 0x37, 0x38, 0x1b,
	0xf4, 0x4f, 0x9b, 0xff, 0xe1, 0x06, 0x00, 0xe9, 0x0f, 0xbb, 0xaf, 0x07, 0x2f, 0x47, 0xdd, 0x61,
	0x13, 0x61, 0x80, 0xaa, 0xd3, 0xeb, 0x0e, 0xbb, 0xa4, 0x59, 0x6a, 0x9f, 0x43, 0xed, 0x55, 0xf2,
	0xe6, 0x92, 0x9b, 0xe3, 0x63, 0x80, 0xe4, 0xe9, 0xb9, 0x42, 0x7a, 0x4c, 0x19, 0x48, 0xb7, 0x79,
	0x7f, 0x4d, 0x9b, 0xa4, 0x16, 0x64, 0x91, 0x3a, 0xf9, 0x84, 0xbe, 0x5e, 0xef, 0xa1, 0x6f, 0xd7,
	0x7b, 0xe8, 0xc7, 0xf5, 0x1e, 0x82, 0x7b, 0x53, 0xb9, 0xb8, 0xcd, 0x3c, 0x69, 0x14, 0x1f, 0x1b,
	0x27, 0xab, 0x30, 0x46, 0xef, 0x8e, 0x32, 0xd0, 0x4c, 0xfa, 0x54, 0xcc, 0x2c, 0x19, 0xce, 0xec,
	0x19, 0x13, 0x7a, 0x51, 0xec, 0xb4, 0x44, 0x03, 0xae, 0x6e, 0xfc, 0x23, 0x9e, 0x66, 0xe1, 0x97,
	0xd2, 0xee, 0x79, 0x4a, 0xed, 0xf9, 0x32, 0xf6, 0x2c, 0x27, 0xfb, 0xca, 0xdb, 0xfd, 0x49, 0x55,
	0xd3, 0x0f, 0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0x34, 0xc3, 0xc8, 0xd1, 0x61, 0x04, 0x00, 0x00,
}
