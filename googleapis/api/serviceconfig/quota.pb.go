// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/api/quota.proto

package serviceconfig

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Quota configuration helps to achieve fairness and budgeting in service
// usage.
//
// The quota configuration works this way:
// - The service configuration defines a set of metrics.
// - For API calls, the quota.metric_rules maps methods to metrics with
//   corresponding costs.
// - The quota.limits defines limits on the metrics, which will be used for
//   quota checks at runtime.
//
// An example quota configuration in yaml format:
//
//    quota:
//      limits:
//
//      - name: apiWriteQpsPerProject
//        metric: library.googleapis.com/write_calls
//        unit: "1/min/{project}"  # rate limit for consumer projects
//        values:
//          STANDARD: 10000
//
//      # The metric rules bind all methods to the read_calls metric,
//      # except for the UpdateBook and DeleteBook methods. These two methods
//      # are mapped to the write_calls metric, with the UpdateBook method
//      # consuming at twice rate as the DeleteBook method.
//      metric_rules:
//      - selector: "*"
//        metric_costs:
//          library.googleapis.com/read_calls: 1
//      - selector: google.example.library.v1.LibraryService.UpdateBook
//        metric_costs:
//          library.googleapis.com/write_calls: 2
//      - selector: google.example.library.v1.LibraryService.DeleteBook
//        metric_costs:
//          library.googleapis.com/write_calls: 1
//
//  Corresponding Metric definition:
//
//      metrics:
//      - name: library.googleapis.com/read_calls
//        display_name: Read requests
//        metric_kind: DELTA
//        value_type: INT64
//
//      - name: library.googleapis.com/write_calls
//        display_name: Write requests
//        metric_kind: DELTA
//        value_type: INT64
//
type Quota struct {
	// List of `QuotaLimit` definitions for the service.
	//
	// Used by metric-based quotas only.
	Limits []*QuotaLimit `protobuf:"bytes,3,rep,name=limits" json:"limits,omitempty"`
	// List of `MetricRule` definitions, each one mapping a selected method to one
	// or more metrics.
	//
	// Used by metric-based quotas only.
	MetricRules []*MetricRule `protobuf:"bytes,4,rep,name=metric_rules,json=metricRules" json:"metric_rules,omitempty"`
}

func (m *Quota) Reset()                    { *m = Quota{} }
func (m *Quota) String() string            { return proto.CompactTextString(m) }
func (*Quota) ProtoMessage()               {}
func (*Quota) Descriptor() ([]byte, []int) { return fileDescriptorQuota, []int{0} }

func (m *Quota) GetLimits() []*QuotaLimit {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *Quota) GetMetricRules() []*MetricRule {
	if m != nil {
		return m.MetricRules
	}
	return nil
}

// Bind API methods to metrics. Binding a method to a metric causes that
// metric's configured quota, billing, and monitoring behaviors to apply to the
// method call.
//
// Used by metric-based quotas only.
type MetricRule struct {
	// Selects the methods to which this rule applies.
	//
	// Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
	Selector string `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Metrics to update when the selected methods are called, and the associated
	// cost applied to each metric.
	//
	// The key of the map is the metric name, and the values are the amount
	// increased for the metric against which the quota limits are defined.
	// The value must not be negative.
	MetricCosts map[string]int64 `protobuf:"bytes,2,rep,name=metric_costs,json=metricCosts" json:"metric_costs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *MetricRule) Reset()                    { *m = MetricRule{} }
func (m *MetricRule) String() string            { return proto.CompactTextString(m) }
func (*MetricRule) ProtoMessage()               {}
func (*MetricRule) Descriptor() ([]byte, []int) { return fileDescriptorQuota, []int{1} }

func (m *MetricRule) GetSelector() string {
	if m != nil {
		return m.Selector
	}
	return ""
}

func (m *MetricRule) GetMetricCosts() map[string]int64 {
	if m != nil {
		return m.MetricCosts
	}
	return nil
}

// `QuotaLimit` defines a specific limit that applies over a specified duration
// for a limit type. There can be at most one limit for a duration and limit
// type combination defined within a `QuotaGroup`.
type QuotaLimit struct {
	// Name of the quota limit. The name is used to refer to the limit when
	// overriding the default limit on per-consumer basis.
	//
	// For group-based quota limits, the name must be unique within the quota
	// group. If a name is not provided, it will be generated from the limit_by
	// and duration fields.
	//
	// For metric-based quota limits, the name must be provided, and it must be
	// unique within the service. The name can only include alphanumeric
	// characters as well as '-'.
	//
	// The maximum length of the limit name is 64 characters.
	//
	// The name of a limit is used as a unique identifier for this limit.
	// Therefore, once a limit has been put into use, its name should be
	// immutable. You can use the display_name field to provide a user-friendly
	// name for the limit. The display name can be evolved over time without
	// affecting the identity of the limit.
	Name string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. User-visible, extended description for this quota limit.
	// Should be used only when more context is needed to understand this limit
	// than provided by the limit's display name (see: `display_name`).
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Default number of tokens that can be consumed during the specified
	// duration. This is the number of tokens assigned when a client
	// application developer activates the service for his/her project.
	//
	// Specifying a value of 0 will block all requests. This can be used if you
	// are provisioning quota to selected consumers and blocking others.
	// Similarly, a value of -1 will indicate an unlimited quota. No other
	// negative values are allowed.
	//
	// Used by group-based quotas only.
	DefaultLimit int64 `protobuf:"varint,3,opt,name=default_limit,json=defaultLimit,proto3" json:"default_limit,omitempty"`
	// Maximum number of tokens that can be consumed during the specified
	// duration. Client application developers can override the default limit up
	// to this maximum. If specified, this value cannot be set to a value less
	// than the default limit. If not specified, it is set to the default limit.
	//
	// To allow clients to apply overrides with no upper bound, set this to -1,
	// indicating unlimited maximum quota.
	//
	// Used by group-based quotas only.
	MaxLimit int64 `protobuf:"varint,4,opt,name=max_limit,json=maxLimit,proto3" json:"max_limit,omitempty"`
	// Free tier value displayed in the Developers Console for this limit.
	// The free tier is the number of tokens that will be subtracted from the
	// billed amount when billing is enabled.
	// This field can only be set on a limit with duration "1d", in a billable
	// group; it is invalid on any other limit. If this field is not set, it
	// defaults to 0, indicating that there is no free tier for this service.
	//
	// Used by group-based quotas only.
	FreeTier int64 `protobuf:"varint,7,opt,name=free_tier,json=freeTier,proto3" json:"free_tier,omitempty"`
	// Duration of this limit in textual notation. Example: "100s", "24h", "1d".
	// For duration longer than a day, only multiple of days is supported. We
	// support only "100s" and "1d" for now. Additional support will be added in
	// the future. "0" indicates indefinite duration.
	//
	// Used by group-based quotas only.
	Duration string `protobuf:"bytes,5,opt,name=duration,proto3" json:"duration,omitempty"`
	// The name of the metric this quota limit applies to. The quota limits with
	// the same metric will be checked together during runtime. The metric must be
	// defined within the service config.
	//
	// Used by metric-based quotas only.
	Metric string `protobuf:"bytes,8,opt,name=metric,proto3" json:"metric,omitempty"`
	// Specify the unit of the quota limit. It uses the same syntax as
	// [Metric.unit][]. The supported unit kinds are determined by the quota
	// backend system.
	//
	// The [Google Service Control](https://cloud.google.com/service-control)
	// supports the following unit components:
	// * One of the time intevals:
	//   * "/min"  for quota every minute.
	//   * "/d"  for quota every 24 hours, starting 00:00 US Pacific Time.
	//   * Otherwise the quota won't be reset by time, such as storage limit.
	// * One and only one of the granted containers:
	//   * "/{organization}" quota for an organization.
	//   * "/{project}" quota for a project.
	//   * "/{folder}" quota for a folder.
	//   * "/{resource}" quota for a universal resource.
	// * Zero or more quota segmentation dimension. Not all combos are valid.
	//   * "/{region}" quota for every region. Not to be used with time intervals.
	//   * Otherwise the resources granted on the target is not segmented.
	//   * "/{zone}" quota for every zone. Not to be used with time intervals.
	//   * Otherwise the resources granted on the target is not segmented.
	//   * "/{resource}" quota for a resource associated with a project or org.
	//
	// Here are some examples:
	// * "1/min/{project}" for quota per minute per project.
	// * "1/min/{user}" for quota per minute per user.
	// * "1/min/{organization}" for quota per minute per organization.
	//
	// Note: the order of unit components is insignificant.
	// The "1" at the beginning is required to follow the metric unit syntax.
	//
	// Used by metric-based quotas only.
	Unit string `protobuf:"bytes,9,opt,name=unit,proto3" json:"unit,omitempty"`
	// Tiered limit values. Also allows for regional or zone overrides for these
	// values if "/{region}" or "/{zone}" is specified in the unit field.
	//
	// Currently supported tiers from low to high:
	// VERY_LOW, LOW, STANDARD, HIGH, VERY_HIGH
	//
	// To apply different limit values for users according to their tiers, specify
	// the values for the tiers you want to differentiate. For example:
	// {LOW:100, STANDARD:500, HIGH:1000, VERY_HIGH:5000}
	//
	// The limit value for each tier is optional except for the tier STANDARD.
	// The limit value for an unspecified tier falls to the value of its next
	// tier towards tier STANDARD. For the above example, the limit value for tier
	// STANDARD is 500.
	//
	// To apply the same limit value for all users, just specify limit value for
	// tier STANDARD. For example: {STANDARD:500}.
	//
	// To apply a regional overide for a tier, add a map entry with key
	// "<TIER>/<region>", where <region> is a region name. Similarly, for a zone
	// override, add a map entry with key "<TIER>/{zone}".
	// Further, a wildcard can be used at the end of a zone name in order to
	// specify zone level overrides. For example:
	// LOW: 10, STANDARD: 50, HIGH: 100,
	// LOW/us-central1: 20, STANDARD/us-central1: 60, HIGH/us-central1: 200,
	// LOW/us-central1-*: 10, STANDARD/us-central1-*: 20, HIGH/us-central1-*: 80
	//
	// The regional overrides tier set for each region must be the same as
	// the tier set for default limit values. Same rule applies for zone overrides
	// tier as well.
	//
	// Used by metric-based quotas only.
	Values map[string]int64 `protobuf:"bytes,10,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// User-visible display name for this limit.
	// Optional. If not set, the UI will provide a default display name based on
	// the quota configuration. This field can be used to override the default
	// display name generated from the configuration.
	DisplayName string `protobuf:"bytes,12,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *QuotaLimit) Reset()                    { *m = QuotaLimit{} }
func (m *QuotaLimit) String() string            { return proto.CompactTextString(m) }
func (*QuotaLimit) ProtoMessage()               {}
func (*QuotaLimit) Descriptor() ([]byte, []int) { return fileDescriptorQuota, []int{2} }

func (m *QuotaLimit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QuotaLimit) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *QuotaLimit) GetDefaultLimit() int64 {
	if m != nil {
		return m.DefaultLimit
	}
	return 0
}

func (m *QuotaLimit) GetMaxLimit() int64 {
	if m != nil {
		return m.MaxLimit
	}
	return 0
}

func (m *QuotaLimit) GetFreeTier() int64 {
	if m != nil {
		return m.FreeTier
	}
	return 0
}

func (m *QuotaLimit) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

func (m *QuotaLimit) GetMetric() string {
	if m != nil {
		return m.Metric
	}
	return ""
}

func (m *QuotaLimit) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *QuotaLimit) GetValues() map[string]int64 {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *QuotaLimit) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func init() {
	proto.RegisterType((*Quota)(nil), "google.api.Quota")
	proto.RegisterType((*MetricRule)(nil), "google.api.MetricRule")
	proto.RegisterType((*QuotaLimit)(nil), "google.api.QuotaLimit")
}
func (m *Quota) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Quota) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for _, msg := range m.Limits {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintQuota(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetricRules) > 0 {
		for _, msg := range m.MetricRules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintQuota(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MetricRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Selector) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintQuota(dAtA, i, uint64(len(m.Selector)))
		i += copy(dAtA[i:], m.Selector)
	}
	if len(m.MetricCosts) > 0 {
		for k, _ := range m.MetricCosts {
			dAtA[i] = 0x12
			i++
			v := m.MetricCosts[k]
			mapSize := 1 + len(k) + sovQuota(uint64(len(k))) + 1 + sovQuota(uint64(v))
			i = encodeVarintQuota(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuota(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintQuota(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *QuotaLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuotaLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintQuota(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.DefaultLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintQuota(dAtA, i, uint64(m.DefaultLimit))
	}
	if m.MaxLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintQuota(dAtA, i, uint64(m.MaxLimit))
	}
	if len(m.Duration) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintQuota(dAtA, i, uint64(len(m.Duration)))
		i += copy(dAtA[i:], m.Duration)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintQuota(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.FreeTier != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintQuota(dAtA, i, uint64(m.FreeTier))
	}
	if len(m.Metric) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintQuota(dAtA, i, uint64(len(m.Metric)))
		i += copy(dAtA[i:], m.Metric)
	}
	if len(m.Unit) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintQuota(dAtA, i, uint64(len(m.Unit)))
		i += copy(dAtA[i:], m.Unit)
	}
	if len(m.Values) > 0 {
		for k, _ := range m.Values {
			dAtA[i] = 0x52
			i++
			v := m.Values[k]
			mapSize := 1 + len(k) + sovQuota(uint64(len(k))) + 1 + sovQuota(uint64(v))
			i = encodeVarintQuota(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintQuota(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintQuota(dAtA, i, uint64(v))
		}
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintQuota(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	return i, nil
}

func encodeFixed64Quota(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Quota(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintQuota(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Quota) Size() (n int) {
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for _, e := range m.Limits {
			l = e.Size()
			n += 1 + l + sovQuota(uint64(l))
		}
	}
	if len(m.MetricRules) > 0 {
		for _, e := range m.MetricRules {
			l = e.Size()
			n += 1 + l + sovQuota(uint64(l))
		}
	}
	return n
}

func (m *MetricRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Selector)
	if l > 0 {
		n += 1 + l + sovQuota(uint64(l))
	}
	if len(m.MetricCosts) > 0 {
		for k, v := range m.MetricCosts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQuota(uint64(len(k))) + 1 + sovQuota(uint64(v))
			n += mapEntrySize + 1 + sovQuota(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *QuotaLimit) Size() (n int) {
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovQuota(uint64(l))
	}
	if m.DefaultLimit != 0 {
		n += 1 + sovQuota(uint64(m.DefaultLimit))
	}
	if m.MaxLimit != 0 {
		n += 1 + sovQuota(uint64(m.MaxLimit))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovQuota(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuota(uint64(l))
	}
	if m.FreeTier != 0 {
		n += 1 + sovQuota(uint64(m.FreeTier))
	}
	l = len(m.Metric)
	if l > 0 {
		n += 1 + l + sovQuota(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovQuota(uint64(l))
	}
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQuota(uint64(len(k))) + 1 + sovQuota(uint64(v))
			n += mapEntrySize + 1 + sovQuota(uint64(mapEntrySize))
		}
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovQuota(uint64(l))
	}
	return n
}

func sovQuota(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozQuota(x uint64) (n int) {
	return sovQuota(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Quota) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuota
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Quota: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Quota: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Limits = append(m.Limits, &QuotaLimit{})
			if err := m.Limits[len(m.Limits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricRules = append(m.MetricRules, &MetricRule{})
			if err := m.MetricRules[len(m.MetricRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuota(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuota
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuota
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricCosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetricCosts == nil {
				m.MetricCosts = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuota
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuota
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQuota
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuota
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQuota(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthQuota
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MetricCosts[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuota(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuota
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuotaLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuota
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuotaLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuotaLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultLimit", wireType)
			}
			m.DefaultLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLimit", wireType)
			}
			m.MaxLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTier", wireType)
			}
			m.FreeTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTier |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuota
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuota
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQuota
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuota
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQuota(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthQuota
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Values[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuota
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuota(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuota
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuota(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuota
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuota
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthQuota
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQuota
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQuota(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQuota = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuota   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/api/quota.proto", fileDescriptorQuota) }

var fileDescriptorQuota = []byte{
	// 486 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0xc1, 0xaa, 0xd3, 0x40,
	0x14, 0x25, 0x4d, 0x5b, 0xdb, 0xdb, 0x2a, 0x8f, 0x41, 0xca, 0x10, 0xa5, 0xd4, 0xba, 0xb0, 0xab,
	0x14, 0x74, 0xe3, 0x7b, 0x82, 0xe0, 0x93, 0x87, 0x28, 0x2a, 0x35, 0x88, 0x0b, 0x37, 0x65, 0x4c,
	0x6f, 0xc3, 0x60, 0x92, 0x89, 0x33, 0x93, 0x47, 0xbb, 0xf6, 0x4f, 0xfc, 0x06, 0x3f, 0xc2, 0xa5,
	0x9f, 0x20, 0xfd, 0x12, 0x99, 0x3b, 0x79, 0x6d, 0xd5, 0xb7, 0x71, 0x77, 0xef, 0xb9, 0xe7, 0x9c,
	0x3b, 0x39, 0x33, 0x81, 0x51, 0xa6, 0x54, 0x96, 0xe3, 0x5c, 0x54, 0x72, 0xfe, 0xa5, 0x56, 0x56,
	0xc4, 0x95, 0x56, 0x56, 0x31, 0xf0, 0x78, 0x2c, 0x2a, 0x19, 0xdd, 0x3d, 0xe2, 0x88, 0xb2, 0x54,
	0x56, 0x58, 0xa9, 0x4a, 0xe3, 0x99, 0x53, 0x0d, 0x9d, 0x77, 0x4e, 0xc8, 0x62, 0xe8, 0xe6, 0xb2,
	0x90, 0xd6, 0xf0, 0x70, 0x12, 0xce, 0x06, 0x0f, 0x47, 0xf1, 0xc1, 0x23, 0x26, 0xca, 0x6b, 0x37,
	0x4e, 0x1a, 0x16, 0x3b, 0x85, 0x61, 0x81, 0x56, 0xcb, 0x74, 0xa9, 0xeb, 0x1c, 0x0d, 0x6f, 0xff,
	0xab, 0x7a, 0x43, 0xf3, 0xa4, 0xce, 0x31, 0x19, 0x14, 0xfb, 0xda, 0x4c, 0xbf, 0x07, 0x00, 0x87,
	0x19, 0x8b, 0xa0, 0x67, 0x30, 0xc7, 0xd4, 0x2a, 0xcd, 0x83, 0x49, 0x30, 0xeb, 0x27, 0xfb, 0x9e,
	0xbd, 0xda, 0x6f, 0x49, 0x95, 0xb1, 0x86, 0xb7, 0x68, 0xcb, 0x83, 0xeb, 0xb7, 0x34, 0xe5, 0x73,
	0xc7, 0xbc, 0x28, 0xad, 0xde, 0x5e, 0xad, 0x25, 0x24, 0x7a, 0x0a, 0x27, 0x7f, 0x13, 0xd8, 0x09,
	0x84, 0x9f, 0x71, 0xdb, 0xac, 0x75, 0x25, 0xbb, 0x0d, 0x9d, 0x4b, 0x91, 0xd7, 0xc8, 0x5b, 0x93,
	0x60, 0x16, 0x26, 0xbe, 0x39, 0x6b, 0x3d, 0x0e, 0xa6, 0x5f, 0x43, 0x80, 0x43, 0x10, 0x6c, 0x02,
	0x83, 0x15, 0x9a, 0x54, 0xcb, 0xca, 0xe5, 0x49, 0xf4, 0x7e, 0x72, 0x0c, 0xb1, 0xfb, 0x70, 0x73,
	0x85, 0x6b, 0x51, 0xe7, 0x76, 0x49, 0xa1, 0xf1, 0x90, 0x2c, 0x87, 0x0d, 0xe8, 0x6d, 0xee, 0x40,
	0xbf, 0x10, 0x9b, 0x86, 0xd0, 0x26, 0x42, 0xaf, 0x10, 0x1b, 0x3f, 0x8c, 0xa0, 0xb7, 0xaa, 0x35,
	0x5d, 0x18, 0xef, 0xf8, 0x68, 0xae, 0x7a, 0xc6, 0xa0, 0x5d, 0x8a, 0x02, 0x79, 0x97, 0x70, 0xaa,
	0x9d, 0xd9, 0x5a, 0x23, 0x2e, 0xad, 0x44, 0xcd, 0x6f, 0x78, 0x33, 0x07, 0xbc, 0x97, 0xa8, 0xd9,
	0x08, 0xba, 0x3e, 0x0e, 0xde, 0x23, 0x49, 0xd3, 0x39, 0xa3, 0xba, 0x94, 0x96, 0xf7, 0xbd, 0x91,
	0xab, 0xd9, 0x19, 0x74, 0xe9, 0xc3, 0x0d, 0x07, 0x4a, 0x7c, 0x7a, 0xfd, 0x6b, 0x88, 0x3f, 0x10,
	0xc9, 0x87, 0xdd, 0x28, 0xd8, 0x3d, 0x18, 0xae, 0xa4, 0xa9, 0x72, 0xb1, 0x5d, 0xd2, 0x01, 0x87,
	0x4d, 0x32, 0x1e, 0x7b, 0x2b, 0x0a, 0x8c, 0x4e, 0x61, 0x70, 0xa4, 0xfc, 0x9f, 0x5b, 0x38, 0xdf,
	0xfc, 0xd8, 0x8d, 0x83, 0x9f, 0xbb, 0x71, 0xf0, 0x6b, 0x37, 0x0e, 0xe0, 0x56, 0xaa, 0x8a, 0xa3,
	0xa3, 0x9d, 0xfb, 0x0b, 0x5a, 0xb8, 0xa7, 0xbd, 0x08, 0x3e, 0x5e, 0x34, 0x93, 0x4c, 0xe5, 0xa2,
	0xcc, 0x62, 0xa5, 0xb3, 0x79, 0x86, 0x25, 0x3d, 0xfc, 0xb9, 0x1f, 0x89, 0x4a, 0x1a, 0xfa, 0x33,
	0x0c, 0xea, 0x4b, 0x99, 0x62, 0xaa, 0xca, 0xb5, 0xcc, 0x9e, 0xfc, 0xd1, 0x7d, 0x6b, 0xb5, 0x5f,
	0x3c, 0x5b, 0xbc, 0xfc, 0xd4, 0x25, 0xe1, 0xa3, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x19, 0xbc,
	0xb0, 0x5b, 0x75, 0x03, 0x00, 0x00,
}
