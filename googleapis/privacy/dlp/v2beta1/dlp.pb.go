// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/privacy/dlp/v2beta1/dlp.proto

/*
	Package dlp is a generated protocol buffer package.

	It is generated from these files:
		google/privacy/dlp/v2beta1/dlp.proto
		google/privacy/dlp/v2beta1/storage.proto

	It has these top-level messages:
		InspectConfig
		OperationConfig
		ContentItem
		Table
		InspectResult
		Finding
		Location
		TableLocation
		Range
		ImageLocation
		RedactContentRequest
		Color
		RedactContentResponse
		InspectContentRequest
		InspectContentResponse
		CreateInspectOperationRequest
		OutputStorageConfig
		InfoTypeStatistics
		InspectOperationMetadata
		InspectOperationResult
		ListInspectFindingsRequest
		ListInspectFindingsResponse
		InfoTypeDescription
		ListInfoTypesRequest
		ListInfoTypesResponse
		CategoryDescription
		ListRootCategoriesRequest
		ListRootCategoriesResponse
		Value
		InfoType
		FieldId
		PartitionId
		KindExpression
		PropertyReference
		Projection
		DatastoreOptions
		CloudStorageOptions
		CloudStoragePath
		BigQueryOptions
		StorageConfig
		CloudStorageKey
		DatastoreKey
		Key
		RecordKey
		BigQueryTable
*/
package dlp

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_longrunning "google.golang.org/genproto/googleapis/longrunning"
import _ "github.com/gogo/protobuf/types"
import google_protobuf3 "github.com/gogo/protobuf/types"
import google_type "google.golang.org/genproto/googleapis/type/date"
import google_type1 "google.golang.org/genproto/googleapis/type/timeofday"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Categorization of results based on how likely they are to represent a match,
// based on the number of elements they contain which imply a match.
type Likelihood int32

const (
	// Default value; information with all likelihoods is included.
	Likelihood_LIKELIHOOD_UNSPECIFIED Likelihood = 0
	// Few matching elements.
	Likelihood_VERY_UNLIKELY Likelihood = 1
	Likelihood_UNLIKELY      Likelihood = 2
	// Some matching elements.
	Likelihood_POSSIBLE Likelihood = 3
	Likelihood_LIKELY   Likelihood = 4
	// Many matching elements.
	Likelihood_VERY_LIKELY Likelihood = 5
)

var Likelihood_name = map[int32]string{
	0: "LIKELIHOOD_UNSPECIFIED",
	1: "VERY_UNLIKELY",
	2: "UNLIKELY",
	3: "POSSIBLE",
	4: "LIKELY",
	5: "VERY_LIKELY",
}
var Likelihood_value = map[string]int32{
	"LIKELIHOOD_UNSPECIFIED": 0,
	"VERY_UNLIKELY":          1,
	"UNLIKELY":               2,
	"POSSIBLE":               3,
	"LIKELY":                 4,
	"VERY_LIKELY":            5,
}

func (x Likelihood) String() string {
	return proto.EnumName(Likelihood_name, int32(x))
}
func (Likelihood) EnumDescriptor() ([]byte, []int) { return fileDescriptorDlp, []int{0} }

// Configuration description of the scanning process.
// When used with redactContent only info_types and min_likelihood are currently
// used.
type InspectConfig struct {
	// Restricts what info_types to look for. The values must correspond to
	// InfoType values returned by ListInfoTypes or found in documentation.
	// Empty info_types runs all enabled detectors.
	InfoTypes []*InfoType `protobuf:"bytes,1,rep,name=info_types,json=infoTypes" json:"info_types,omitempty"`
	// Only returns findings equal or above this threshold.
	MinLikelihood Likelihood `protobuf:"varint,2,opt,name=min_likelihood,json=minLikelihood,proto3,enum=google.privacy.dlp.v2beta1.Likelihood" json:"min_likelihood,omitempty"`
	// Limits the number of findings per content item or long running operation.
	MaxFindings int32 `protobuf:"varint,3,opt,name=max_findings,json=maxFindings,proto3" json:"max_findings,omitempty"`
	// When true, a contextual quote from the data that triggered a finding is
	// included in the response; see Finding.quote.
	IncludeQuote bool `protobuf:"varint,4,opt,name=include_quote,json=includeQuote,proto3" json:"include_quote,omitempty"`
	// When true, excludes type information of the findings.
	ExcludeTypes bool `protobuf:"varint,6,opt,name=exclude_types,json=excludeTypes,proto3" json:"exclude_types,omitempty"`
	// Configuration of findings limit given for specified info types.
	InfoTypeLimits []*InspectConfig_InfoTypeLimit `protobuf:"bytes,7,rep,name=info_type_limits,json=infoTypeLimits" json:"info_type_limits,omitempty"`
}

func (m *InspectConfig) Reset()                    { *m = InspectConfig{} }
func (m *InspectConfig) String() string            { return proto.CompactTextString(m) }
func (*InspectConfig) ProtoMessage()               {}
func (*InspectConfig) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{0} }

func (m *InspectConfig) GetInfoTypes() []*InfoType {
	if m != nil {
		return m.InfoTypes
	}
	return nil
}

func (m *InspectConfig) GetMinLikelihood() Likelihood {
	if m != nil {
		return m.MinLikelihood
	}
	return Likelihood_LIKELIHOOD_UNSPECIFIED
}

func (m *InspectConfig) GetMaxFindings() int32 {
	if m != nil {
		return m.MaxFindings
	}
	return 0
}

func (m *InspectConfig) GetIncludeQuote() bool {
	if m != nil {
		return m.IncludeQuote
	}
	return false
}

func (m *InspectConfig) GetExcludeTypes() bool {
	if m != nil {
		return m.ExcludeTypes
	}
	return false
}

func (m *InspectConfig) GetInfoTypeLimits() []*InspectConfig_InfoTypeLimit {
	if m != nil {
		return m.InfoTypeLimits
	}
	return nil
}

// Max findings configuration per info type, per content item or long running
// operation.
type InspectConfig_InfoTypeLimit struct {
	// Type of information the findings limit applies to. Only one limit per
	// info_type should be provided. If InfoTypeLimit does not have an
	// info_type, the DLP API applies the limit against all info_types that are
	// found but not specified in another InfoTypeLimit.
	InfoType *InfoType `protobuf:"bytes,1,opt,name=info_type,json=infoType" json:"info_type,omitempty"`
	// Max findings limit for the given infoType.
	MaxFindings int32 `protobuf:"varint,2,opt,name=max_findings,json=maxFindings,proto3" json:"max_findings,omitempty"`
}

func (m *InspectConfig_InfoTypeLimit) Reset()         { *m = InspectConfig_InfoTypeLimit{} }
func (m *InspectConfig_InfoTypeLimit) String() string { return proto.CompactTextString(m) }
func (*InspectConfig_InfoTypeLimit) ProtoMessage()    {}
func (*InspectConfig_InfoTypeLimit) Descriptor() ([]byte, []int) {
	return fileDescriptorDlp, []int{0, 0}
}

func (m *InspectConfig_InfoTypeLimit) GetInfoType() *InfoType {
	if m != nil {
		return m.InfoType
	}
	return nil
}

func (m *InspectConfig_InfoTypeLimit) GetMaxFindings() int32 {
	if m != nil {
		return m.MaxFindings
	}
	return 0
}

// Additional configuration for inspect long running operations.
type OperationConfig struct {
	// Max number of findings per file, Datastore entity, or database row.
	MaxItemFindings int64 `protobuf:"varint,1,opt,name=max_item_findings,json=maxItemFindings,proto3" json:"max_item_findings,omitempty"`
}

func (m *OperationConfig) Reset()                    { *m = OperationConfig{} }
func (m *OperationConfig) String() string            { return proto.CompactTextString(m) }
func (*OperationConfig) ProtoMessage()               {}
func (*OperationConfig) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{1} }

func (m *OperationConfig) GetMaxItemFindings() int64 {
	if m != nil {
		return m.MaxItemFindings
	}
	return 0
}

// Container structure for the content to inspect.
type ContentItem struct {
	// Type of the content, as defined in Content-Type HTTP header.
	// Supported types are: all "text" types, octet streams, PNG images,
	// JPEG images.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Data of the item either in the byte array or UTF-8 string form.
	//
	// Types that are valid to be assigned to DataItem:
	//	*ContentItem_Data
	//	*ContentItem_Value
	//	*ContentItem_Table
	DataItem isContentItem_DataItem `protobuf_oneof:"data_item"`
}

func (m *ContentItem) Reset()                    { *m = ContentItem{} }
func (m *ContentItem) String() string            { return proto.CompactTextString(m) }
func (*ContentItem) ProtoMessage()               {}
func (*ContentItem) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{2} }

type isContentItem_DataItem interface {
	isContentItem_DataItem()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ContentItem_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}
type ContentItem_Value struct {
	Value string `protobuf:"bytes,3,opt,name=value,proto3,oneof"`
}
type ContentItem_Table struct {
	Table *Table `protobuf:"bytes,4,opt,name=table,oneof"`
}

func (*ContentItem_Data) isContentItem_DataItem()  {}
func (*ContentItem_Value) isContentItem_DataItem() {}
func (*ContentItem_Table) isContentItem_DataItem() {}

func (m *ContentItem) GetDataItem() isContentItem_DataItem {
	if m != nil {
		return m.DataItem
	}
	return nil
}

func (m *ContentItem) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ContentItem) GetData() []byte {
	if x, ok := m.GetDataItem().(*ContentItem_Data); ok {
		return x.Data
	}
	return nil
}

func (m *ContentItem) GetValue() string {
	if x, ok := m.GetDataItem().(*ContentItem_Value); ok {
		return x.Value
	}
	return ""
}

func (m *ContentItem) GetTable() *Table {
	if x, ok := m.GetDataItem().(*ContentItem_Table); ok {
		return x.Table
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ContentItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ContentItem_OneofMarshaler, _ContentItem_OneofUnmarshaler, _ContentItem_OneofSizer, []interface{}{
		(*ContentItem_Data)(nil),
		(*ContentItem_Value)(nil),
		(*ContentItem_Table)(nil),
	}
}

func _ContentItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ContentItem)
	// data_item
	switch x := m.DataItem.(type) {
	case *ContentItem_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Data)
	case *ContentItem_Value:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Value)
	case *ContentItem_Table:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Table); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ContentItem.DataItem has unexpected type %T", x)
	}
	return nil
}

func _ContentItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ContentItem)
	switch tag {
	case 2: // data_item.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.DataItem = &ContentItem_Data{x}
		return true, err
	case 3: // data_item.value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.DataItem = &ContentItem_Value{x}
		return true, err
	case 4: // data_item.table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Table)
		err := b.DecodeMessage(msg)
		m.DataItem = &ContentItem_Table{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ContentItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ContentItem)
	// data_item
	switch x := m.DataItem.(type) {
	case *ContentItem_Data:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Data)))
		n += len(x.Data)
	case *ContentItem_Value:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Value)))
		n += len(x.Value)
	case *ContentItem_Table:
		s := proto.Size(x.Table)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Structured content to inspect. Up to 50,000 `Value`s per request allowed.
type Table struct {
	Headers []*FieldId   `protobuf:"bytes,1,rep,name=headers" json:"headers,omitempty"`
	Rows    []*Table_Row `protobuf:"bytes,2,rep,name=rows" json:"rows,omitempty"`
}

func (m *Table) Reset()                    { *m = Table{} }
func (m *Table) String() string            { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()               {}
func (*Table) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{3} }

func (m *Table) GetHeaders() []*FieldId {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Table) GetRows() []*Table_Row {
	if m != nil {
		return m.Rows
	}
	return nil
}

type Table_Row struct {
	Values []*Value `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *Table_Row) Reset()                    { *m = Table_Row{} }
func (m *Table_Row) String() string            { return proto.CompactTextString(m) }
func (*Table_Row) ProtoMessage()               {}
func (*Table_Row) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{3, 0} }

func (m *Table_Row) GetValues() []*Value {
	if m != nil {
		return m.Values
	}
	return nil
}

// All the findings for a single scanned item.
type InspectResult struct {
	// List of findings for an item.
	Findings []*Finding `protobuf:"bytes,1,rep,name=findings" json:"findings,omitempty"`
	// If true, then this item might have more findings than were returned,
	// and the findings returned are an arbitrary subset of all findings.
	// The findings list might be truncated because the input items were too
	// large, or because the server reached the maximum amount of resources
	// allowed for a single API call. For best results, divide the input into
	// smaller batches.
	FindingsTruncated bool `protobuf:"varint,2,opt,name=findings_truncated,json=findingsTruncated,proto3" json:"findings_truncated,omitempty"`
}

func (m *InspectResult) Reset()                    { *m = InspectResult{} }
func (m *InspectResult) String() string            { return proto.CompactTextString(m) }
func (*InspectResult) ProtoMessage()               {}
func (*InspectResult) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{4} }

func (m *InspectResult) GetFindings() []*Finding {
	if m != nil {
		return m.Findings
	}
	return nil
}

func (m *InspectResult) GetFindingsTruncated() bool {
	if m != nil {
		return m.FindingsTruncated
	}
	return false
}

// Container structure describing a single finding within a string or image.
type Finding struct {
	// The specific string that may be potentially sensitive info.
	Quote string `protobuf:"bytes,1,opt,name=quote,proto3" json:"quote,omitempty"`
	// The specific type of info the string might be.
	InfoType *InfoType `protobuf:"bytes,2,opt,name=info_type,json=infoType" json:"info_type,omitempty"`
	// Estimate of how likely it is that the info_type is correct.
	Likelihood Likelihood `protobuf:"varint,3,opt,name=likelihood,proto3,enum=google.privacy.dlp.v2beta1.Likelihood" json:"likelihood,omitempty"`
	// Location of the info found.
	Location *Location `protobuf:"bytes,4,opt,name=location" json:"location,omitempty"`
	// Timestamp when finding was detected.
	CreateTime *google_protobuf3.Timestamp `protobuf:"bytes,6,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
}

func (m *Finding) Reset()                    { *m = Finding{} }
func (m *Finding) String() string            { return proto.CompactTextString(m) }
func (*Finding) ProtoMessage()               {}
func (*Finding) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{5} }

func (m *Finding) GetQuote() string {
	if m != nil {
		return m.Quote
	}
	return ""
}

func (m *Finding) GetInfoType() *InfoType {
	if m != nil {
		return m.InfoType
	}
	return nil
}

func (m *Finding) GetLikelihood() Likelihood {
	if m != nil {
		return m.Likelihood
	}
	return Likelihood_LIKELIHOOD_UNSPECIFIED
}

func (m *Finding) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Finding) GetCreateTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

// Specifies the location of a finding within its source item.
type Location struct {
	// Zero-based byte offsets within a content item.
	ByteRange *Range `protobuf:"bytes,1,opt,name=byte_range,json=byteRange" json:"byte_range,omitempty"`
	// Character offsets within a content item, included when content type
	// is a text. Default charset assumed to be UTF-8.
	CodepointRange *Range `protobuf:"bytes,2,opt,name=codepoint_range,json=codepointRange" json:"codepoint_range,omitempty"`
	// Location within an image's pixels.
	ImageBoxes []*ImageLocation `protobuf:"bytes,3,rep,name=image_boxes,json=imageBoxes" json:"image_boxes,omitempty"`
	// Key of the finding.
	RecordKey *RecordKey `protobuf:"bytes,4,opt,name=record_key,json=recordKey" json:"record_key,omitempty"`
	// Field id of the field containing the finding.
	FieldId *FieldId `protobuf:"bytes,5,opt,name=field_id,json=fieldId" json:"field_id,omitempty"`
	// Location within a `ContentItem.Table`.
	TableLocation *TableLocation `protobuf:"bytes,6,opt,name=table_location,json=tableLocation" json:"table_location,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{6} }

func (m *Location) GetByteRange() *Range {
	if m != nil {
		return m.ByteRange
	}
	return nil
}

func (m *Location) GetCodepointRange() *Range {
	if m != nil {
		return m.CodepointRange
	}
	return nil
}

func (m *Location) GetImageBoxes() []*ImageLocation {
	if m != nil {
		return m.ImageBoxes
	}
	return nil
}

func (m *Location) GetRecordKey() *RecordKey {
	if m != nil {
		return m.RecordKey
	}
	return nil
}

func (m *Location) GetFieldId() *FieldId {
	if m != nil {
		return m.FieldId
	}
	return nil
}

func (m *Location) GetTableLocation() *TableLocation {
	if m != nil {
		return m.TableLocation
	}
	return nil
}

// Location of a finding within a `ContentItem.Table`.
type TableLocation struct {
	// The zero-based index of the row where the finding is located.
	RowIndex int64 `protobuf:"varint,1,opt,name=row_index,json=rowIndex,proto3" json:"row_index,omitempty"`
}

func (m *TableLocation) Reset()                    { *m = TableLocation{} }
func (m *TableLocation) String() string            { return proto.CompactTextString(m) }
func (*TableLocation) ProtoMessage()               {}
func (*TableLocation) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{7} }

func (m *TableLocation) GetRowIndex() int64 {
	if m != nil {
		return m.RowIndex
	}
	return 0
}

// Generic half-open interval [start, end)
type Range struct {
	// Index of the first character of the range (inclusive).
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// Index of the last character of the range (exclusive).
	End int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Range) Reset()                    { *m = Range{} }
func (m *Range) String() string            { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()               {}
func (*Range) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{8} }

func (m *Range) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Range) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

// Bounding box encompassing detected text within an image.
type ImageLocation struct {
	// Top coordinate of the bounding box. (0,0) is upper left.
	Top int32 `protobuf:"varint,1,opt,name=top,proto3" json:"top,omitempty"`
	// Left coordinate of the bounding box. (0,0) is upper left.
	Left int32 `protobuf:"varint,2,opt,name=left,proto3" json:"left,omitempty"`
	// Width of the bounding box in pixels.
	Width int32 `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	// Height of the bounding box in pixels.
	Height int32 `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *ImageLocation) Reset()                    { *m = ImageLocation{} }
func (m *ImageLocation) String() string            { return proto.CompactTextString(m) }
func (*ImageLocation) ProtoMessage()               {}
func (*ImageLocation) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{9} }

func (m *ImageLocation) GetTop() int32 {
	if m != nil {
		return m.Top
	}
	return 0
}

func (m *ImageLocation) GetLeft() int32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *ImageLocation) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *ImageLocation) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

// Request to search for potentially sensitive info in a list of items
// and replace it with a default or provided content.
type RedactContentRequest struct {
	// Configuration for the inspector.
	InspectConfig *InspectConfig `protobuf:"bytes,1,opt,name=inspect_config,json=inspectConfig" json:"inspect_config,omitempty"`
	// The list of items to inspect. Up to 100 are allowed per request.
	Items []*ContentItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	// The strings to replace findings text findings with. Must specify at least
	// one of these or one ImageRedactionConfig if redacting images.
	ReplaceConfigs []*RedactContentRequest_ReplaceConfig `protobuf:"bytes,3,rep,name=replace_configs,json=replaceConfigs" json:"replace_configs,omitempty"`
	// The configuration for specifying what content to redact from images.
	ImageRedactionConfigs []*RedactContentRequest_ImageRedactionConfig `protobuf:"bytes,4,rep,name=image_redaction_configs,json=imageRedactionConfigs" json:"image_redaction_configs,omitempty"`
}

func (m *RedactContentRequest) Reset()                    { *m = RedactContentRequest{} }
func (m *RedactContentRequest) String() string            { return proto.CompactTextString(m) }
func (*RedactContentRequest) ProtoMessage()               {}
func (*RedactContentRequest) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{10} }

func (m *RedactContentRequest) GetInspectConfig() *InspectConfig {
	if m != nil {
		return m.InspectConfig
	}
	return nil
}

func (m *RedactContentRequest) GetItems() []*ContentItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *RedactContentRequest) GetReplaceConfigs() []*RedactContentRequest_ReplaceConfig {
	if m != nil {
		return m.ReplaceConfigs
	}
	return nil
}

func (m *RedactContentRequest) GetImageRedactionConfigs() []*RedactContentRequest_ImageRedactionConfig {
	if m != nil {
		return m.ImageRedactionConfigs
	}
	return nil
}

type RedactContentRequest_ReplaceConfig struct {
	// Type of information to replace. Only one ReplaceConfig per info_type
	// should be provided. If ReplaceConfig does not have an info_type, the DLP
	// API matches it against all info_types that are found but not specified in
	// another ReplaceConfig.
	InfoType *InfoType `protobuf:"bytes,1,opt,name=info_type,json=infoType" json:"info_type,omitempty"`
	// Content replacing sensitive information of given type. Max 256 chars.
	ReplaceWith string `protobuf:"bytes,2,opt,name=replace_with,json=replaceWith,proto3" json:"replace_with,omitempty"`
}

func (m *RedactContentRequest_ReplaceConfig) Reset()         { *m = RedactContentRequest_ReplaceConfig{} }
func (m *RedactContentRequest_ReplaceConfig) String() string { return proto.CompactTextString(m) }
func (*RedactContentRequest_ReplaceConfig) ProtoMessage()    {}
func (*RedactContentRequest_ReplaceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorDlp, []int{10, 0}
}

func (m *RedactContentRequest_ReplaceConfig) GetInfoType() *InfoType {
	if m != nil {
		return m.InfoType
	}
	return nil
}

func (m *RedactContentRequest_ReplaceConfig) GetReplaceWith() string {
	if m != nil {
		return m.ReplaceWith
	}
	return ""
}

// Configuration for determing how redaction of images should occur.
type RedactContentRequest_ImageRedactionConfig struct {
	// Type of information to redact from images.
	//
	// Types that are valid to be assigned to Target:
	//	*RedactContentRequest_ImageRedactionConfig_InfoType
	//	*RedactContentRequest_ImageRedactionConfig_RedactAllText
	Target isRedactContentRequest_ImageRedactionConfig_Target `protobuf_oneof:"target"`
	// The color to use when redacting content from an image. If not specified,
	// the default is black.
	RedactionColor *Color `protobuf:"bytes,3,opt,name=redaction_color,json=redactionColor" json:"redaction_color,omitempty"`
}

func (m *RedactContentRequest_ImageRedactionConfig) Reset() {
	*m = RedactContentRequest_ImageRedactionConfig{}
}
func (m *RedactContentRequest_ImageRedactionConfig) String() string { return proto.CompactTextString(m) }
func (*RedactContentRequest_ImageRedactionConfig) ProtoMessage()    {}
func (*RedactContentRequest_ImageRedactionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorDlp, []int{10, 1}
}

type isRedactContentRequest_ImageRedactionConfig_Target interface {
	isRedactContentRequest_ImageRedactionConfig_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RedactContentRequest_ImageRedactionConfig_InfoType struct {
	InfoType *InfoType `protobuf:"bytes,1,opt,name=info_type,json=infoType,oneof"`
}
type RedactContentRequest_ImageRedactionConfig_RedactAllText struct {
	RedactAllText bool `protobuf:"varint,2,opt,name=redact_all_text,json=redactAllText,proto3,oneof"`
}

func (*RedactContentRequest_ImageRedactionConfig_InfoType) isRedactContentRequest_ImageRedactionConfig_Target() {
}
func (*RedactContentRequest_ImageRedactionConfig_RedactAllText) isRedactContentRequest_ImageRedactionConfig_Target() {
}

func (m *RedactContentRequest_ImageRedactionConfig) GetTarget() isRedactContentRequest_ImageRedactionConfig_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *RedactContentRequest_ImageRedactionConfig) GetInfoType() *InfoType {
	if x, ok := m.GetTarget().(*RedactContentRequest_ImageRedactionConfig_InfoType); ok {
		return x.InfoType
	}
	return nil
}

func (m *RedactContentRequest_ImageRedactionConfig) GetRedactAllText() bool {
	if x, ok := m.GetTarget().(*RedactContentRequest_ImageRedactionConfig_RedactAllText); ok {
		return x.RedactAllText
	}
	return false
}

func (m *RedactContentRequest_ImageRedactionConfig) GetRedactionColor() *Color {
	if m != nil {
		return m.RedactionColor
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RedactContentRequest_ImageRedactionConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RedactContentRequest_ImageRedactionConfig_OneofMarshaler, _RedactContentRequest_ImageRedactionConfig_OneofUnmarshaler, _RedactContentRequest_ImageRedactionConfig_OneofSizer, []interface{}{
		(*RedactContentRequest_ImageRedactionConfig_InfoType)(nil),
		(*RedactContentRequest_ImageRedactionConfig_RedactAllText)(nil),
	}
}

func _RedactContentRequest_ImageRedactionConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RedactContentRequest_ImageRedactionConfig)
	// target
	switch x := m.Target.(type) {
	case *RedactContentRequest_ImageRedactionConfig_InfoType:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InfoType); err != nil {
			return err
		}
	case *RedactContentRequest_ImageRedactionConfig_RedactAllText:
		t := uint64(0)
		if x.RedactAllText {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("RedactContentRequest_ImageRedactionConfig.Target has unexpected type %T", x)
	}
	return nil
}

func _RedactContentRequest_ImageRedactionConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RedactContentRequest_ImageRedactionConfig)
	switch tag {
	case 1: // target.info_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InfoType)
		err := b.DecodeMessage(msg)
		m.Target = &RedactContentRequest_ImageRedactionConfig_InfoType{msg}
		return true, err
	case 2: // target.redact_all_text
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Target = &RedactContentRequest_ImageRedactionConfig_RedactAllText{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _RedactContentRequest_ImageRedactionConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RedactContentRequest_ImageRedactionConfig)
	// target
	switch x := m.Target.(type) {
	case *RedactContentRequest_ImageRedactionConfig_InfoType:
		s := proto.Size(x.InfoType)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RedactContentRequest_ImageRedactionConfig_RedactAllText:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Represents a color in the RGB color space.
type Color struct {
	// The amount of red in the color as a value in the interval [0, 1].
	Red float32 `protobuf:"fixed32,1,opt,name=red,proto3" json:"red,omitempty"`
	// The amount of green in the color as a value in the interval [0, 1].
	Green float32 `protobuf:"fixed32,2,opt,name=green,proto3" json:"green,omitempty"`
	// The amount of blue in the color as a value in the interval [0, 1].
	Blue float32 `protobuf:"fixed32,3,opt,name=blue,proto3" json:"blue,omitempty"`
}

func (m *Color) Reset()                    { *m = Color{} }
func (m *Color) String() string            { return proto.CompactTextString(m) }
func (*Color) ProtoMessage()               {}
func (*Color) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{11} }

func (m *Color) GetRed() float32 {
	if m != nil {
		return m.Red
	}
	return 0
}

func (m *Color) GetGreen() float32 {
	if m != nil {
		return m.Green
	}
	return 0
}

func (m *Color) GetBlue() float32 {
	if m != nil {
		return m.Blue
	}
	return 0
}

// Results of redacting a list of items.
type RedactContentResponse struct {
	// The redacted content.
	Items []*ContentItem `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *RedactContentResponse) Reset()                    { *m = RedactContentResponse{} }
func (m *RedactContentResponse) String() string            { return proto.CompactTextString(m) }
func (*RedactContentResponse) ProtoMessage()               {}
func (*RedactContentResponse) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{12} }

func (m *RedactContentResponse) GetItems() []*ContentItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request to search for potentially sensitive info in a list of items.
type InspectContentRequest struct {
	// Configuration for the inspector.
	InspectConfig *InspectConfig `protobuf:"bytes,1,opt,name=inspect_config,json=inspectConfig" json:"inspect_config,omitempty"`
	// The list of items to inspect. Items in a single request are
	// considered "related" unless inspect_config.independent_inputs is true.
	// Up to 100 are allowed per request.
	Items []*ContentItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
}

func (m *InspectContentRequest) Reset()                    { *m = InspectContentRequest{} }
func (m *InspectContentRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectContentRequest) ProtoMessage()               {}
func (*InspectContentRequest) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{13} }

func (m *InspectContentRequest) GetInspectConfig() *InspectConfig {
	if m != nil {
		return m.InspectConfig
	}
	return nil
}

func (m *InspectContentRequest) GetItems() []*ContentItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// Results of inspecting a list of items.
type InspectContentResponse struct {
	// Each content_item from the request has a result in this list, in the
	// same order as the request.
	Results []*InspectResult `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *InspectContentResponse) Reset()                    { *m = InspectContentResponse{} }
func (m *InspectContentResponse) String() string            { return proto.CompactTextString(m) }
func (*InspectContentResponse) ProtoMessage()               {}
func (*InspectContentResponse) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{14} }

func (m *InspectContentResponse) GetResults() []*InspectResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// Request for scheduling a scan of a data subset from a Google Platform data
// repository.
type CreateInspectOperationRequest struct {
	// Configuration for the inspector.
	InspectConfig *InspectConfig `protobuf:"bytes,1,opt,name=inspect_config,json=inspectConfig" json:"inspect_config,omitempty"`
	// Specification of the data set to process.
	StorageConfig *StorageConfig `protobuf:"bytes,2,opt,name=storage_config,json=storageConfig" json:"storage_config,omitempty"`
	// Optional location to store findings. The bucket must already exist and
	// the Google APIs service account for DLP must have write permission to
	// write to the given bucket.
	// <p>Results are split over multiple csv files with each file name matching
	// the pattern "[operation_id]_[count].csv", for example
	// `3094877188788974909_1.csv`. The `operation_id` matches the
	// identifier for the Operation, and the `count` is a counter used for
	// tracking the number of files written. <p>The CSV file(s) contain the
	// following columns regardless of storage type scanned: <li>id <li>info_type
	// <li>likelihood <li>byte size of finding <li>quote <li>timestamp<br/>
	// <p>For Cloud Storage the next columns are: <li>file_path
	// <li>start_offset<br/>
	// <p>For Cloud Datastore the next columns are: <li>project_id
	// <li>namespace_id <li>path <li>column_name <li>offset<br/>
	// <p>For BigQuery the next columns are: <li>row_number <li>project_id
	// <li>dataset_id <li>table_id
	OutputConfig *OutputStorageConfig `protobuf:"bytes,3,opt,name=output_config,json=outputConfig" json:"output_config,omitempty"`
	// Additional configuration settings for long running operations.
	OperationConfig *OperationConfig `protobuf:"bytes,5,opt,name=operation_config,json=operationConfig" json:"operation_config,omitempty"`
}

func (m *CreateInspectOperationRequest) Reset()         { *m = CreateInspectOperationRequest{} }
func (m *CreateInspectOperationRequest) String() string { return proto.CompactTextString(m) }
func (*CreateInspectOperationRequest) ProtoMessage()    {}
func (*CreateInspectOperationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorDlp, []int{15}
}

func (m *CreateInspectOperationRequest) GetInspectConfig() *InspectConfig {
	if m != nil {
		return m.InspectConfig
	}
	return nil
}

func (m *CreateInspectOperationRequest) GetStorageConfig() *StorageConfig {
	if m != nil {
		return m.StorageConfig
	}
	return nil
}

func (m *CreateInspectOperationRequest) GetOutputConfig() *OutputStorageConfig {
	if m != nil {
		return m.OutputConfig
	}
	return nil
}

func (m *CreateInspectOperationRequest) GetOperationConfig() *OperationConfig {
	if m != nil {
		return m.OperationConfig
	}
	return nil
}

// Cloud repository for storing output.
type OutputStorageConfig struct {
	// Types that are valid to be assigned to Type:
	//	*OutputStorageConfig_Table
	//	*OutputStorageConfig_StoragePath
	Type isOutputStorageConfig_Type `protobuf_oneof:"type"`
}

func (m *OutputStorageConfig) Reset()                    { *m = OutputStorageConfig{} }
func (m *OutputStorageConfig) String() string            { return proto.CompactTextString(m) }
func (*OutputStorageConfig) ProtoMessage()               {}
func (*OutputStorageConfig) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{16} }

type isOutputStorageConfig_Type interface {
	isOutputStorageConfig_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OutputStorageConfig_Table struct {
	Table *BigQueryTable `protobuf:"bytes,1,opt,name=table,oneof"`
}
type OutputStorageConfig_StoragePath struct {
	StoragePath *CloudStoragePath `protobuf:"bytes,2,opt,name=storage_path,json=storagePath,oneof"`
}

func (*OutputStorageConfig_Table) isOutputStorageConfig_Type()       {}
func (*OutputStorageConfig_StoragePath) isOutputStorageConfig_Type() {}

func (m *OutputStorageConfig) GetType() isOutputStorageConfig_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *OutputStorageConfig) GetTable() *BigQueryTable {
	if x, ok := m.GetType().(*OutputStorageConfig_Table); ok {
		return x.Table
	}
	return nil
}

func (m *OutputStorageConfig) GetStoragePath() *CloudStoragePath {
	if x, ok := m.GetType().(*OutputStorageConfig_StoragePath); ok {
		return x.StoragePath
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OutputStorageConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OutputStorageConfig_OneofMarshaler, _OutputStorageConfig_OneofUnmarshaler, _OutputStorageConfig_OneofSizer, []interface{}{
		(*OutputStorageConfig_Table)(nil),
		(*OutputStorageConfig_StoragePath)(nil),
	}
}

func _OutputStorageConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OutputStorageConfig)
	// type
	switch x := m.Type.(type) {
	case *OutputStorageConfig_Table:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Table); err != nil {
			return err
		}
	case *OutputStorageConfig_StoragePath:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StoragePath); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OutputStorageConfig.Type has unexpected type %T", x)
	}
	return nil
}

func _OutputStorageConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OutputStorageConfig)
	switch tag {
	case 1: // type.table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BigQueryTable)
		err := b.DecodeMessage(msg)
		m.Type = &OutputStorageConfig_Table{msg}
		return true, err
	case 2: // type.storage_path
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudStoragePath)
		err := b.DecodeMessage(msg)
		m.Type = &OutputStorageConfig_StoragePath{msg}
		return true, err
	default:
		return false, nil
	}
}

func _OutputStorageConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OutputStorageConfig)
	// type
	switch x := m.Type.(type) {
	case *OutputStorageConfig_Table:
		s := proto.Size(x.Table)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OutputStorageConfig_StoragePath:
		s := proto.Size(x.StoragePath)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Statistics regarding a specific InfoType.
type InfoTypeStatistics struct {
	// The type of finding this stat is for.
	InfoType *InfoType `protobuf:"bytes,1,opt,name=info_type,json=infoType" json:"info_type,omitempty"`
	// Number of findings for this info type.
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *InfoTypeStatistics) Reset()                    { *m = InfoTypeStatistics{} }
func (m *InfoTypeStatistics) String() string            { return proto.CompactTextString(m) }
func (*InfoTypeStatistics) ProtoMessage()               {}
func (*InfoTypeStatistics) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{17} }

func (m *InfoTypeStatistics) GetInfoType() *InfoType {
	if m != nil {
		return m.InfoType
	}
	return nil
}

func (m *InfoTypeStatistics) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Metadata returned within GetOperation for an inspect request.
type InspectOperationMetadata struct {
	// Total size in bytes that were processed.
	ProcessedBytes int64 `protobuf:"varint,1,opt,name=processed_bytes,json=processedBytes,proto3" json:"processed_bytes,omitempty"`
	// Estimate of the number of bytes to process.
	TotalEstimatedBytes int64                 `protobuf:"varint,4,opt,name=total_estimated_bytes,json=totalEstimatedBytes,proto3" json:"total_estimated_bytes,omitempty"`
	InfoTypeStats       []*InfoTypeStatistics `protobuf:"bytes,2,rep,name=info_type_stats,json=infoTypeStats" json:"info_type_stats,omitempty"`
	// The time which this request was started.
	CreateTime *google_protobuf3.Timestamp `protobuf:"bytes,3,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// The inspect config used to create the Operation.
	RequestInspectConfig *InspectConfig `protobuf:"bytes,5,opt,name=request_inspect_config,json=requestInspectConfig" json:"request_inspect_config,omitempty"`
	// The storage config used to create the Operation.
	RequestStorageConfig *StorageConfig `protobuf:"bytes,6,opt,name=request_storage_config,json=requestStorageConfig" json:"request_storage_config,omitempty"`
	// Optional location to store findings.
	RequestOutputConfig *OutputStorageConfig `protobuf:"bytes,7,opt,name=request_output_config,json=requestOutputConfig" json:"request_output_config,omitempty"`
}

func (m *InspectOperationMetadata) Reset()                    { *m = InspectOperationMetadata{} }
func (m *InspectOperationMetadata) String() string            { return proto.CompactTextString(m) }
func (*InspectOperationMetadata) ProtoMessage()               {}
func (*InspectOperationMetadata) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{18} }

func (m *InspectOperationMetadata) GetProcessedBytes() int64 {
	if m != nil {
		return m.ProcessedBytes
	}
	return 0
}

func (m *InspectOperationMetadata) GetTotalEstimatedBytes() int64 {
	if m != nil {
		return m.TotalEstimatedBytes
	}
	return 0
}

func (m *InspectOperationMetadata) GetInfoTypeStats() []*InfoTypeStatistics {
	if m != nil {
		return m.InfoTypeStats
	}
	return nil
}

func (m *InspectOperationMetadata) GetCreateTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *InspectOperationMetadata) GetRequestInspectConfig() *InspectConfig {
	if m != nil {
		return m.RequestInspectConfig
	}
	return nil
}

func (m *InspectOperationMetadata) GetRequestStorageConfig() *StorageConfig {
	if m != nil {
		return m.RequestStorageConfig
	}
	return nil
}

func (m *InspectOperationMetadata) GetRequestOutputConfig() *OutputStorageConfig {
	if m != nil {
		return m.RequestOutputConfig
	}
	return nil
}

// The operational data.
type InspectOperationResult struct {
	// The server-assigned name, which is only unique within the same service that
	// originally returns it. If you use the default HTTP mapping, the
	// `name` should have the format of `inspect/results/{id}`.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *InspectOperationResult) Reset()                    { *m = InspectOperationResult{} }
func (m *InspectOperationResult) String() string            { return proto.CompactTextString(m) }
func (*InspectOperationResult) ProtoMessage()               {}
func (*InspectOperationResult) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{19} }

func (m *InspectOperationResult) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request for the list of results in a given inspect operation.
type ListInspectFindingsRequest struct {
	// Identifier of the results set returned as metadata of
	// the longrunning operation created by a call to CreateInspectOperation.
	// Should be in the format of `inspect/results/{id}`.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Maximum number of results to return.
	// If 0, the implementation selects a reasonable value.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// The value returned by the last `ListInspectFindingsResponse`; indicates
	// that this is a continuation of a prior `ListInspectFindings` call, and that
	// the system should return the next page of data.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Restricts findings to items that match. Supports info_type and likelihood.
	// <p>Examples:<br/>
	// <li>info_type=EMAIL_ADDRESS
	// <li>info_type=PHONE_NUMBER,EMAIL_ADDRESS
	// <li>likelihood=VERY_LIKELY
	// <li>likelihood=VERY_LIKELY,LIKELY
	// <li>info_type=EMAIL_ADDRESS,likelihood=VERY_LIKELY,LIKELY
	Filter string `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
}

func (m *ListInspectFindingsRequest) Reset()                    { *m = ListInspectFindingsRequest{} }
func (m *ListInspectFindingsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListInspectFindingsRequest) ProtoMessage()               {}
func (*ListInspectFindingsRequest) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{20} }

func (m *ListInspectFindingsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListInspectFindingsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListInspectFindingsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListInspectFindingsRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

// Response to the ListInspectFindings request.
type ListInspectFindingsResponse struct {
	// The results.
	Result *InspectResult `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	// If not empty, indicates that there may be more results that match the
	// request; this value should be passed in a new `ListInspectFindingsRequest`.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *ListInspectFindingsResponse) Reset()                    { *m = ListInspectFindingsResponse{} }
func (m *ListInspectFindingsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListInspectFindingsResponse) ProtoMessage()               {}
func (*ListInspectFindingsResponse) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{21} }

func (m *ListInspectFindingsResponse) GetResult() *InspectResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ListInspectFindingsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Info type description.
type InfoTypeDescription struct {
	// Internal name of the info type.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Human readable form of the info type name.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// List of categories this info type belongs to.
	Categories []*CategoryDescription `protobuf:"bytes,3,rep,name=categories" json:"categories,omitempty"`
}

func (m *InfoTypeDescription) Reset()                    { *m = InfoTypeDescription{} }
func (m *InfoTypeDescription) String() string            { return proto.CompactTextString(m) }
func (*InfoTypeDescription) ProtoMessage()               {}
func (*InfoTypeDescription) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{22} }

func (m *InfoTypeDescription) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InfoTypeDescription) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *InfoTypeDescription) GetCategories() []*CategoryDescription {
	if m != nil {
		return m.Categories
	}
	return nil
}

// Request for the list of info types belonging to a given category,
// or all supported info types if no category is specified.
type ListInfoTypesRequest struct {
	// Category name as returned by ListRootCategories.
	Category string `protobuf:"bytes,1,opt,name=category,proto3" json:"category,omitempty"`
	// Optional BCP-47 language code for localized info type friendly
	// names. If omitted, or if localized strings are not available,
	// en-US strings will be returned.
	LanguageCode string `protobuf:"bytes,2,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
}

func (m *ListInfoTypesRequest) Reset()                    { *m = ListInfoTypesRequest{} }
func (m *ListInfoTypesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListInfoTypesRequest) ProtoMessage()               {}
func (*ListInfoTypesRequest) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{23} }

func (m *ListInfoTypesRequest) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *ListInfoTypesRequest) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

// Response to the ListInfoTypes request.
type ListInfoTypesResponse struct {
	// Set of sensitive info types belonging to a category.
	InfoTypes []*InfoTypeDescription `protobuf:"bytes,1,rep,name=info_types,json=infoTypes" json:"info_types,omitempty"`
}

func (m *ListInfoTypesResponse) Reset()                    { *m = ListInfoTypesResponse{} }
func (m *ListInfoTypesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListInfoTypesResponse) ProtoMessage()               {}
func (*ListInfoTypesResponse) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{24} }

func (m *ListInfoTypesResponse) GetInfoTypes() []*InfoTypeDescription {
	if m != nil {
		return m.InfoTypes
	}
	return nil
}

// Info Type Category description.
type CategoryDescription struct {
	// Internal name of the category.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Human readable form of the category name.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *CategoryDescription) Reset()                    { *m = CategoryDescription{} }
func (m *CategoryDescription) String() string            { return proto.CompactTextString(m) }
func (*CategoryDescription) ProtoMessage()               {}
func (*CategoryDescription) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{25} }

func (m *CategoryDescription) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CategoryDescription) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// Request for root categories of Info Types supported by the API.
// Example values might include "FINANCE", "HEALTH", "FAST", "DEFAULT".
type ListRootCategoriesRequest struct {
	// Optional language code for localized friendly category names.
	// If omitted or if localized strings are not available,
	// en-US strings will be returned.
	LanguageCode string `protobuf:"bytes,1,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
}

func (m *ListRootCategoriesRequest) Reset()                    { *m = ListRootCategoriesRequest{} }
func (m *ListRootCategoriesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRootCategoriesRequest) ProtoMessage()               {}
func (*ListRootCategoriesRequest) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{26} }

func (m *ListRootCategoriesRequest) GetLanguageCode() string {
	if m != nil {
		return m.LanguageCode
	}
	return ""
}

// Response for ListRootCategories request.
type ListRootCategoriesResponse struct {
	// List of all into type categories supported by the API.
	Categories []*CategoryDescription `protobuf:"bytes,1,rep,name=categories" json:"categories,omitempty"`
}

func (m *ListRootCategoriesResponse) Reset()                    { *m = ListRootCategoriesResponse{} }
func (m *ListRootCategoriesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListRootCategoriesResponse) ProtoMessage()               {}
func (*ListRootCategoriesResponse) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{27} }

func (m *ListRootCategoriesResponse) GetCategories() []*CategoryDescription {
	if m != nil {
		return m.Categories
	}
	return nil
}

// Set of primitive values supported by the system.
type Value struct {
	// Types that are valid to be assigned to Type:
	//	*Value_IntegerValue
	//	*Value_FloatValue
	//	*Value_StringValue
	//	*Value_BooleanValue
	//	*Value_TimestampValue
	//	*Value_TimeValue
	//	*Value_DateValue
	Type isValue_Type `protobuf_oneof:"type"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptorDlp, []int{28} }

type isValue_Type interface {
	isValue_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_IntegerValue struct {
	IntegerValue int64 `protobuf:"varint,1,opt,name=integer_value,json=integerValue,proto3,oneof"`
}
type Value_FloatValue struct {
	FloatValue float64 `protobuf:"fixed64,2,opt,name=float_value,json=floatValue,proto3,oneof"`
}
type Value_StringValue struct {
	StringValue string `protobuf:"bytes,3,opt,name=string_value,json=stringValue,proto3,oneof"`
}
type Value_BooleanValue struct {
	BooleanValue bool `protobuf:"varint,4,opt,name=boolean_value,json=booleanValue,proto3,oneof"`
}
type Value_TimestampValue struct {
	TimestampValue *google_protobuf3.Timestamp `protobuf:"bytes,5,opt,name=timestamp_value,json=timestampValue,oneof"`
}
type Value_TimeValue struct {
	TimeValue *google_type1.TimeOfDay `protobuf:"bytes,6,opt,name=time_value,json=timeValue,oneof"`
}
type Value_DateValue struct {
	DateValue *google_type.Date `protobuf:"bytes,7,opt,name=date_value,json=dateValue,oneof"`
}

func (*Value_IntegerValue) isValue_Type()   {}
func (*Value_FloatValue) isValue_Type()     {}
func (*Value_StringValue) isValue_Type()    {}
func (*Value_BooleanValue) isValue_Type()   {}
func (*Value_TimestampValue) isValue_Type() {}
func (*Value_TimeValue) isValue_Type()      {}
func (*Value_DateValue) isValue_Type()      {}

func (m *Value) GetType() isValue_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Value) GetIntegerValue() int64 {
	if x, ok := m.GetType().(*Value_IntegerValue); ok {
		return x.IntegerValue
	}
	return 0
}

func (m *Value) GetFloatValue() float64 {
	if x, ok := m.GetType().(*Value_FloatValue); ok {
		return x.FloatValue
	}
	return 0
}

func (m *Value) GetStringValue() string {
	if x, ok := m.GetType().(*Value_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *Value) GetBooleanValue() bool {
	if x, ok := m.GetType().(*Value_BooleanValue); ok {
		return x.BooleanValue
	}
	return false
}

func (m *Value) GetTimestampValue() *google_protobuf3.Timestamp {
	if x, ok := m.GetType().(*Value_TimestampValue); ok {
		return x.TimestampValue
	}
	return nil
}

func (m *Value) GetTimeValue() *google_type1.TimeOfDay {
	if x, ok := m.GetType().(*Value_TimeValue); ok {
		return x.TimeValue
	}
	return nil
}

func (m *Value) GetDateValue() *google_type.Date {
	if x, ok := m.GetType().(*Value_DateValue); ok {
		return x.DateValue
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Value) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Value_OneofMarshaler, _Value_OneofUnmarshaler, _Value_OneofSizer, []interface{}{
		(*Value_IntegerValue)(nil),
		(*Value_FloatValue)(nil),
		(*Value_StringValue)(nil),
		(*Value_BooleanValue)(nil),
		(*Value_TimestampValue)(nil),
		(*Value_TimeValue)(nil),
		(*Value_DateValue)(nil),
	}
}

func _Value_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Value)
	// type
	switch x := m.Type.(type) {
	case *Value_IntegerValue:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.IntegerValue))
	case *Value_FloatValue:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.FloatValue))
	case *Value_StringValue:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.StringValue)
	case *Value_BooleanValue:
		t := uint64(0)
		if x.BooleanValue {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *Value_TimestampValue:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TimestampValue); err != nil {
			return err
		}
	case *Value_TimeValue:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TimeValue); err != nil {
			return err
		}
	case *Value_DateValue:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DateValue); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Value.Type has unexpected type %T", x)
	}
	return nil
}

func _Value_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Value)
	switch tag {
	case 1: // type.integer_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &Value_IntegerValue{int64(x)}
		return true, err
	case 2: // type.float_value
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Type = &Value_FloatValue{math.Float64frombits(x)}
		return true, err
	case 3: // type.string_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &Value_StringValue{x}
		return true, err
	case 4: // type.boolean_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &Value_BooleanValue{x != 0}
		return true, err
	case 5: // type.timestamp_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf3.Timestamp)
		err := b.DecodeMessage(msg)
		m.Type = &Value_TimestampValue{msg}
		return true, err
	case 6: // type.time_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_type1.TimeOfDay)
		err := b.DecodeMessage(msg)
		m.Type = &Value_TimeValue{msg}
		return true, err
	case 7: // type.date_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_type.Date)
		err := b.DecodeMessage(msg)
		m.Type = &Value_DateValue{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Value_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Value)
	// type
	switch x := m.Type.(type) {
	case *Value_IntegerValue:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IntegerValue))
	case *Value_FloatValue:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case *Value_StringValue:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StringValue)))
		n += len(x.StringValue)
	case *Value_BooleanValue:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *Value_TimestampValue:
		s := proto.Size(x.TimestampValue)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Value_TimeValue:
		s := proto.Size(x.TimeValue)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Value_DateValue:
		s := proto.Size(x.DateValue)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*InspectConfig)(nil), "google.privacy.dlp.v2beta1.InspectConfig")
	proto.RegisterType((*InspectConfig_InfoTypeLimit)(nil), "google.privacy.dlp.v2beta1.InspectConfig.InfoTypeLimit")
	proto.RegisterType((*OperationConfig)(nil), "google.privacy.dlp.v2beta1.OperationConfig")
	proto.RegisterType((*ContentItem)(nil), "google.privacy.dlp.v2beta1.ContentItem")
	proto.RegisterType((*Table)(nil), "google.privacy.dlp.v2beta1.Table")
	proto.RegisterType((*Table_Row)(nil), "google.privacy.dlp.v2beta1.Table.Row")
	proto.RegisterType((*InspectResult)(nil), "google.privacy.dlp.v2beta1.InspectResult")
	proto.RegisterType((*Finding)(nil), "google.privacy.dlp.v2beta1.Finding")
	proto.RegisterType((*Location)(nil), "google.privacy.dlp.v2beta1.Location")
	proto.RegisterType((*TableLocation)(nil), "google.privacy.dlp.v2beta1.TableLocation")
	proto.RegisterType((*Range)(nil), "google.privacy.dlp.v2beta1.Range")
	proto.RegisterType((*ImageLocation)(nil), "google.privacy.dlp.v2beta1.ImageLocation")
	proto.RegisterType((*RedactContentRequest)(nil), "google.privacy.dlp.v2beta1.RedactContentRequest")
	proto.RegisterType((*RedactContentRequest_ReplaceConfig)(nil), "google.privacy.dlp.v2beta1.RedactContentRequest.ReplaceConfig")
	proto.RegisterType((*RedactContentRequest_ImageRedactionConfig)(nil), "google.privacy.dlp.v2beta1.RedactContentRequest.ImageRedactionConfig")
	proto.RegisterType((*Color)(nil), "google.privacy.dlp.v2beta1.Color")
	proto.RegisterType((*RedactContentResponse)(nil), "google.privacy.dlp.v2beta1.RedactContentResponse")
	proto.RegisterType((*InspectContentRequest)(nil), "google.privacy.dlp.v2beta1.InspectContentRequest")
	proto.RegisterType((*InspectContentResponse)(nil), "google.privacy.dlp.v2beta1.InspectContentResponse")
	proto.RegisterType((*CreateInspectOperationRequest)(nil), "google.privacy.dlp.v2beta1.CreateInspectOperationRequest")
	proto.RegisterType((*OutputStorageConfig)(nil), "google.privacy.dlp.v2beta1.OutputStorageConfig")
	proto.RegisterType((*InfoTypeStatistics)(nil), "google.privacy.dlp.v2beta1.InfoTypeStatistics")
	proto.RegisterType((*InspectOperationMetadata)(nil), "google.privacy.dlp.v2beta1.InspectOperationMetadata")
	proto.RegisterType((*InspectOperationResult)(nil), "google.privacy.dlp.v2beta1.InspectOperationResult")
	proto.RegisterType((*ListInspectFindingsRequest)(nil), "google.privacy.dlp.v2beta1.ListInspectFindingsRequest")
	proto.RegisterType((*ListInspectFindingsResponse)(nil), "google.privacy.dlp.v2beta1.ListInspectFindingsResponse")
	proto.RegisterType((*InfoTypeDescription)(nil), "google.privacy.dlp.v2beta1.InfoTypeDescription")
	proto.RegisterType((*ListInfoTypesRequest)(nil), "google.privacy.dlp.v2beta1.ListInfoTypesRequest")
	proto.RegisterType((*ListInfoTypesResponse)(nil), "google.privacy.dlp.v2beta1.ListInfoTypesResponse")
	proto.RegisterType((*CategoryDescription)(nil), "google.privacy.dlp.v2beta1.CategoryDescription")
	proto.RegisterType((*ListRootCategoriesRequest)(nil), "google.privacy.dlp.v2beta1.ListRootCategoriesRequest")
	proto.RegisterType((*ListRootCategoriesResponse)(nil), "google.privacy.dlp.v2beta1.ListRootCategoriesResponse")
	proto.RegisterType((*Value)(nil), "google.privacy.dlp.v2beta1.Value")
	proto.RegisterEnum("google.privacy.dlp.v2beta1.Likelihood", Likelihood_name, Likelihood_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DlpService service

type DlpServiceClient interface {
	// Finds potentially sensitive info in a list of strings.
	// This method has limits on input size, processing time, and output size.
	InspectContent(ctx context.Context, in *InspectContentRequest, opts ...grpc.CallOption) (*InspectContentResponse, error)
	// Redacts potentially sensitive info from a list of strings.
	// This method has limits on input size, processing time, and output size.
	RedactContent(ctx context.Context, in *RedactContentRequest, opts ...grpc.CallOption) (*RedactContentResponse, error)
	// Schedules a job scanning content in a Google Cloud Platform data
	// repository.
	CreateInspectOperation(ctx context.Context, in *CreateInspectOperationRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error)
	// Returns list of results for given inspect operation result set id.
	ListInspectFindings(ctx context.Context, in *ListInspectFindingsRequest, opts ...grpc.CallOption) (*ListInspectFindingsResponse, error)
	// Returns sensitive information types for given category.
	ListInfoTypes(ctx context.Context, in *ListInfoTypesRequest, opts ...grpc.CallOption) (*ListInfoTypesResponse, error)
	// Returns the list of root categories of sensitive information.
	ListRootCategories(ctx context.Context, in *ListRootCategoriesRequest, opts ...grpc.CallOption) (*ListRootCategoriesResponse, error)
}

type dlpServiceClient struct {
	cc *grpc.ClientConn
}

func NewDlpServiceClient(cc *grpc.ClientConn) DlpServiceClient {
	return &dlpServiceClient{cc}
}

func (c *dlpServiceClient) InspectContent(ctx context.Context, in *InspectContentRequest, opts ...grpc.CallOption) (*InspectContentResponse, error) {
	out := new(InspectContentResponse)
	err := grpc.Invoke(ctx, "/google.privacy.dlp.v2beta1.DlpService/InspectContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dlpServiceClient) RedactContent(ctx context.Context, in *RedactContentRequest, opts ...grpc.CallOption) (*RedactContentResponse, error) {
	out := new(RedactContentResponse)
	err := grpc.Invoke(ctx, "/google.privacy.dlp.v2beta1.DlpService/RedactContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dlpServiceClient) CreateInspectOperation(ctx context.Context, in *CreateInspectOperationRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	err := grpc.Invoke(ctx, "/google.privacy.dlp.v2beta1.DlpService/CreateInspectOperation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dlpServiceClient) ListInspectFindings(ctx context.Context, in *ListInspectFindingsRequest, opts ...grpc.CallOption) (*ListInspectFindingsResponse, error) {
	out := new(ListInspectFindingsResponse)
	err := grpc.Invoke(ctx, "/google.privacy.dlp.v2beta1.DlpService/ListInspectFindings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dlpServiceClient) ListInfoTypes(ctx context.Context, in *ListInfoTypesRequest, opts ...grpc.CallOption) (*ListInfoTypesResponse, error) {
	out := new(ListInfoTypesResponse)
	err := grpc.Invoke(ctx, "/google.privacy.dlp.v2beta1.DlpService/ListInfoTypes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dlpServiceClient) ListRootCategories(ctx context.Context, in *ListRootCategoriesRequest, opts ...grpc.CallOption) (*ListRootCategoriesResponse, error) {
	out := new(ListRootCategoriesResponse)
	err := grpc.Invoke(ctx, "/google.privacy.dlp.v2beta1.DlpService/ListRootCategories", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DlpService service

type DlpServiceServer interface {
	// Finds potentially sensitive info in a list of strings.
	// This method has limits on input size, processing time, and output size.
	InspectContent(context.Context, *InspectContentRequest) (*InspectContentResponse, error)
	// Redacts potentially sensitive info from a list of strings.
	// This method has limits on input size, processing time, and output size.
	RedactContent(context.Context, *RedactContentRequest) (*RedactContentResponse, error)
	// Schedules a job scanning content in a Google Cloud Platform data
	// repository.
	CreateInspectOperation(context.Context, *CreateInspectOperationRequest) (*google_longrunning.Operation, error)
	// Returns list of results for given inspect operation result set id.
	ListInspectFindings(context.Context, *ListInspectFindingsRequest) (*ListInspectFindingsResponse, error)
	// Returns sensitive information types for given category.
	ListInfoTypes(context.Context, *ListInfoTypesRequest) (*ListInfoTypesResponse, error)
	// Returns the list of root categories of sensitive information.
	ListRootCategories(context.Context, *ListRootCategoriesRequest) (*ListRootCategoriesResponse, error)
}

func RegisterDlpServiceServer(s *grpc.Server, srv DlpServiceServer) {
	s.RegisterService(&_DlpService_serviceDesc, srv)
}

func _DlpService_InspectContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DlpServiceServer).InspectContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.privacy.dlp.v2beta1.DlpService/InspectContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DlpServiceServer).InspectContent(ctx, req.(*InspectContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DlpService_RedactContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedactContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DlpServiceServer).RedactContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.privacy.dlp.v2beta1.DlpService/RedactContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DlpServiceServer).RedactContent(ctx, req.(*RedactContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DlpService_CreateInspectOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInspectOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DlpServiceServer).CreateInspectOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.privacy.dlp.v2beta1.DlpService/CreateInspectOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DlpServiceServer).CreateInspectOperation(ctx, req.(*CreateInspectOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DlpService_ListInspectFindings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInspectFindingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DlpServiceServer).ListInspectFindings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.privacy.dlp.v2beta1.DlpService/ListInspectFindings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DlpServiceServer).ListInspectFindings(ctx, req.(*ListInspectFindingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DlpService_ListInfoTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInfoTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DlpServiceServer).ListInfoTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.privacy.dlp.v2beta1.DlpService/ListInfoTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DlpServiceServer).ListInfoTypes(ctx, req.(*ListInfoTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DlpService_ListRootCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRootCategoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DlpServiceServer).ListRootCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.privacy.dlp.v2beta1.DlpService/ListRootCategories",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DlpServiceServer).ListRootCategories(ctx, req.(*ListRootCategoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DlpService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.privacy.dlp.v2beta1.DlpService",
	HandlerType: (*DlpServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InspectContent",
			Handler:    _DlpService_InspectContent_Handler,
		},
		{
			MethodName: "RedactContent",
			Handler:    _DlpService_RedactContent_Handler,
		},
		{
			MethodName: "CreateInspectOperation",
			Handler:    _DlpService_CreateInspectOperation_Handler,
		},
		{
			MethodName: "ListInspectFindings",
			Handler:    _DlpService_ListInspectFindings_Handler,
		},
		{
			MethodName: "ListInfoTypes",
			Handler:    _DlpService_ListInfoTypes_Handler,
		},
		{
			MethodName: "ListRootCategories",
			Handler:    _DlpService_ListRootCategories_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/privacy/dlp/v2beta1/dlp.proto",
}

func (m *InspectConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InfoTypes) > 0 {
		for _, msg := range m.InfoTypes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MinLikelihood != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.MinLikelihood))
	}
	if m.MaxFindings != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.MaxFindings))
	}
	if m.IncludeQuote {
		dAtA[i] = 0x20
		i++
		if m.IncludeQuote {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExcludeTypes {
		dAtA[i] = 0x30
		i++
		if m.ExcludeTypes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.InfoTypeLimits) > 0 {
		for _, msg := range m.InfoTypeLimits {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InspectConfig_InfoTypeLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectConfig_InfoTypeLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InfoType != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.InfoType.Size()))
		n1, err := m.InfoType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.MaxFindings != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.MaxFindings))
	}
	return i, nil
}

func (m *OperationConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxItemFindings != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.MaxItemFindings))
	}
	return i, nil
}

func (m *ContentItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.DataItem != nil {
		nn2, err := m.DataItem.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *ContentItem_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}
func (m *ContentItem_Value) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDlp(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}
func (m *ContentItem_Table) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Table != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Table.Size()))
		n3, err := m.Table.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Rows) > 0 {
		for _, msg := range m.Rows {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Table_Row) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table_Row) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InspectResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Findings) > 0 {
		for _, msg := range m.Findings {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FindingsTruncated {
		dAtA[i] = 0x10
		i++
		if m.FindingsTruncated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Finding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Finding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Quote) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.Quote)))
		i += copy(dAtA[i:], m.Quote)
	}
	if m.InfoType != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.InfoType.Size()))
		n4, err := m.InfoType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Likelihood != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Likelihood))
	}
	if m.Location != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Location.Size()))
		n5, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.CreateTime.Size()))
		n6, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ByteRange != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.ByteRange.Size()))
		n7, err := m.ByteRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.CodepointRange != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.CodepointRange.Size()))
		n8, err := m.CodepointRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.ImageBoxes) > 0 {
		for _, msg := range m.ImageBoxes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RecordKey != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.RecordKey.Size()))
		n9, err := m.RecordKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.FieldId != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.FieldId.Size()))
		n10, err := m.FieldId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.TableLocation != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.TableLocation.Size()))
		n11, err := m.TableLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *TableLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RowIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.RowIndex))
	}
	return i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *ImageLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Top != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Top))
	}
	if m.Left != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Left))
	}
	if m.Width != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Height))
	}
	return i, nil
}

func (m *RedactContentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedactContentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InspectConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.InspectConfig.Size()))
		n12, err := m.InspectConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ReplaceConfigs) > 0 {
		for _, msg := range m.ReplaceConfigs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImageRedactionConfigs) > 0 {
		for _, msg := range m.ImageRedactionConfigs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RedactContentRequest_ReplaceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedactContentRequest_ReplaceConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InfoType != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.InfoType.Size()))
		n13, err := m.InfoType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.ReplaceWith) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.ReplaceWith)))
		i += copy(dAtA[i:], m.ReplaceWith)
	}
	return i, nil
}

func (m *RedactContentRequest_ImageRedactionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedactContentRequest_ImageRedactionConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		nn14, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	if m.RedactionColor != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.RedactionColor.Size()))
		n15, err := m.RedactionColor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *RedactContentRequest_ImageRedactionConfig_InfoType) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InfoType != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.InfoType.Size()))
		n16, err := m.InfoType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *RedactContentRequest_ImageRedactionConfig_RedactAllText) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.RedactAllText {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Color) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Color) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Red != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Dlp(dAtA, i, uint32(math.Float32bits(float32(m.Red))))
	}
	if m.Green != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Dlp(dAtA, i, uint32(math.Float32bits(float32(m.Green))))
	}
	if m.Blue != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Dlp(dAtA, i, uint32(math.Float32bits(float32(m.Blue))))
	}
	return i, nil
}

func (m *RedactContentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedactContentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InspectContentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectContentRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InspectConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.InspectConfig.Size()))
		n17, err := m.InspectConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InspectContentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectContentResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateInspectOperationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateInspectOperationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InspectConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.InspectConfig.Size()))
		n18, err := m.InspectConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.StorageConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.StorageConfig.Size()))
		n19, err := m.StorageConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.OutputConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.OutputConfig.Size()))
		n20, err := m.OutputConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.OperationConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.OperationConfig.Size()))
		n21, err := m.OperationConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *OutputStorageConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OutputStorageConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn22, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *OutputStorageConfig_Table) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Table != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Table.Size()))
		n23, err := m.Table.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *OutputStorageConfig_StoragePath) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StoragePath != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.StoragePath.Size()))
		n24, err := m.StoragePath.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *InfoTypeStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoTypeStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InfoType != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.InfoType.Size()))
		n25, err := m.InfoType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *InspectOperationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectOperationMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProcessedBytes != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.ProcessedBytes))
	}
	if len(m.InfoTypeStats) > 0 {
		for _, msg := range m.InfoTypeStats {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.CreateTime.Size()))
		n26, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.TotalEstimatedBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.TotalEstimatedBytes))
	}
	if m.RequestInspectConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.RequestInspectConfig.Size()))
		n27, err := m.RequestInspectConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.RequestStorageConfig != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.RequestStorageConfig.Size()))
		n28, err := m.RequestStorageConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.RequestOutputConfig != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.RequestOutputConfig.Size()))
		n29, err := m.RequestOutputConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *InspectOperationResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectOperationResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *ListInspectFindingsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListInspectFindingsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if len(m.Filter) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	return i, nil
}

func (m *ListInspectFindingsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListInspectFindingsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.Result.Size()))
		n30, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *InfoTypeDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InfoTypeDescription) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if len(m.Categories) > 0 {
		for _, msg := range m.Categories {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListInfoTypesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListInfoTypesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Category) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.Category)))
		i += copy(dAtA[i:], m.Category)
	}
	if len(m.LanguageCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.LanguageCode)))
		i += copy(dAtA[i:], m.LanguageCode)
	}
	return i, nil
}

func (m *ListInfoTypesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListInfoTypesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InfoTypes) > 0 {
		for _, msg := range m.InfoTypes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CategoryDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryDescription) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	return i, nil
}

func (m *ListRootCategoriesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRootCategoriesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LanguageCode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDlp(dAtA, i, uint64(len(m.LanguageCode)))
		i += copy(dAtA[i:], m.LanguageCode)
	}
	return i, nil
}

func (m *ListRootCategoriesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRootCategoriesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for _, msg := range m.Categories {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDlp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		nn31, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn31
	}
	return i, nil
}

func (m *Value_IntegerValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintDlp(dAtA, i, uint64(m.IntegerValue))
	return i, nil
}
func (m *Value_FloatValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x11
	i++
	i = encodeFixed64Dlp(dAtA, i, uint64(math.Float64bits(float64(m.FloatValue))))
	return i, nil
}
func (m *Value_StringValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDlp(dAtA, i, uint64(len(m.StringValue)))
	i += copy(dAtA[i:], m.StringValue)
	return i, nil
}
func (m *Value_BooleanValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	if m.BooleanValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Value_TimestampValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TimestampValue != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.TimestampValue.Size()))
		n32, err := m.TimestampValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}
func (m *Value_TimeValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TimeValue != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.TimeValue.Size()))
		n33, err := m.TimeValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *Value_DateValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DateValue != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDlp(dAtA, i, uint64(m.DateValue.Size()))
		n34, err := m.DateValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func encodeFixed64Dlp(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Dlp(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDlp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *InspectConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.InfoTypes) > 0 {
		for _, e := range m.InfoTypes {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	if m.MinLikelihood != 0 {
		n += 1 + sovDlp(uint64(m.MinLikelihood))
	}
	if m.MaxFindings != 0 {
		n += 1 + sovDlp(uint64(m.MaxFindings))
	}
	if m.IncludeQuote {
		n += 2
	}
	if m.ExcludeTypes {
		n += 2
	}
	if len(m.InfoTypeLimits) > 0 {
		for _, e := range m.InfoTypeLimits {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *InspectConfig_InfoTypeLimit) Size() (n int) {
	var l int
	_ = l
	if m.InfoType != nil {
		l = m.InfoType.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.MaxFindings != 0 {
		n += 1 + sovDlp(uint64(m.MaxFindings))
	}
	return n
}

func (m *OperationConfig) Size() (n int) {
	var l int
	_ = l
	if m.MaxItemFindings != 0 {
		n += 1 + sovDlp(uint64(m.MaxItemFindings))
	}
	return n
}

func (m *ContentItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.DataItem != nil {
		n += m.DataItem.Size()
	}
	return n
}

func (m *ContentItem_Data) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}
func (m *ContentItem_Value) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovDlp(uint64(l))
	return n
}
func (m *ContentItem_Table) Size() (n int) {
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}
func (m *Table) Size() (n int) {
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *Table_Row) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *InspectResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Findings) > 0 {
		for _, e := range m.Findings {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	if m.FindingsTruncated {
		n += 2
	}
	return n
}

func (m *Finding) Size() (n int) {
	var l int
	_ = l
	l = len(m.Quote)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.InfoType != nil {
		l = m.InfoType.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.Likelihood != 0 {
		n += 1 + sovDlp(uint64(m.Likelihood))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	var l int
	_ = l
	if m.ByteRange != nil {
		l = m.ByteRange.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.CodepointRange != nil {
		l = m.CodepointRange.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if len(m.ImageBoxes) > 0 {
		for _, e := range m.ImageBoxes {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	if m.RecordKey != nil {
		l = m.RecordKey.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.FieldId != nil {
		l = m.FieldId.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.TableLocation != nil {
		l = m.TableLocation.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *TableLocation) Size() (n int) {
	var l int
	_ = l
	if m.RowIndex != 0 {
		n += 1 + sovDlp(uint64(m.RowIndex))
	}
	return n
}

func (m *Range) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovDlp(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovDlp(uint64(m.End))
	}
	return n
}

func (m *ImageLocation) Size() (n int) {
	var l int
	_ = l
	if m.Top != 0 {
		n += 1 + sovDlp(uint64(m.Top))
	}
	if m.Left != 0 {
		n += 1 + sovDlp(uint64(m.Left))
	}
	if m.Width != 0 {
		n += 1 + sovDlp(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovDlp(uint64(m.Height))
	}
	return n
}

func (m *RedactContentRequest) Size() (n int) {
	var l int
	_ = l
	if m.InspectConfig != nil {
		l = m.InspectConfig.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	if len(m.ReplaceConfigs) > 0 {
		for _, e := range m.ReplaceConfigs {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	if len(m.ImageRedactionConfigs) > 0 {
		for _, e := range m.ImageRedactionConfigs {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *RedactContentRequest_ReplaceConfig) Size() (n int) {
	var l int
	_ = l
	if m.InfoType != nil {
		l = m.InfoType.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	l = len(m.ReplaceWith)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *RedactContentRequest_ImageRedactionConfig) Size() (n int) {
	var l int
	_ = l
	if m.Target != nil {
		n += m.Target.Size()
	}
	if m.RedactionColor != nil {
		l = m.RedactionColor.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *RedactContentRequest_ImageRedactionConfig_InfoType) Size() (n int) {
	var l int
	_ = l
	if m.InfoType != nil {
		l = m.InfoType.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}
func (m *RedactContentRequest_ImageRedactionConfig_RedactAllText) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *Color) Size() (n int) {
	var l int
	_ = l
	if m.Red != 0 {
		n += 5
	}
	if m.Green != 0 {
		n += 5
	}
	if m.Blue != 0 {
		n += 5
	}
	return n
}

func (m *RedactContentResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *InspectContentRequest) Size() (n int) {
	var l int
	_ = l
	if m.InspectConfig != nil {
		l = m.InspectConfig.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *InspectContentResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *CreateInspectOperationRequest) Size() (n int) {
	var l int
	_ = l
	if m.InspectConfig != nil {
		l = m.InspectConfig.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.StorageConfig != nil {
		l = m.StorageConfig.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.OutputConfig != nil {
		l = m.OutputConfig.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.OperationConfig != nil {
		l = m.OperationConfig.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *OutputStorageConfig) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *OutputStorageConfig_Table) Size() (n int) {
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}
func (m *OutputStorageConfig_StoragePath) Size() (n int) {
	var l int
	_ = l
	if m.StoragePath != nil {
		l = m.StoragePath.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}
func (m *InfoTypeStatistics) Size() (n int) {
	var l int
	_ = l
	if m.InfoType != nil {
		l = m.InfoType.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovDlp(uint64(m.Count))
	}
	return n
}

func (m *InspectOperationMetadata) Size() (n int) {
	var l int
	_ = l
	if m.ProcessedBytes != 0 {
		n += 1 + sovDlp(uint64(m.ProcessedBytes))
	}
	if len(m.InfoTypeStats) > 0 {
		for _, e := range m.InfoTypeStats {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.TotalEstimatedBytes != 0 {
		n += 1 + sovDlp(uint64(m.TotalEstimatedBytes))
	}
	if m.RequestInspectConfig != nil {
		l = m.RequestInspectConfig.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.RequestStorageConfig != nil {
		l = m.RequestStorageConfig.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.RequestOutputConfig != nil {
		l = m.RequestOutputConfig.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *InspectOperationResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *ListInspectFindingsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovDlp(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *ListInspectFindingsResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *InfoTypeDescription) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	if len(m.Categories) > 0 {
		for _, e := range m.Categories {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *ListInfoTypesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	l = len(m.LanguageCode)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *ListInfoTypesResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.InfoTypes) > 0 {
		for _, e := range m.InfoTypes {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *CategoryDescription) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *ListRootCategoriesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.LanguageCode)
	if l > 0 {
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func (m *ListRootCategoriesResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for _, e := range m.Categories {
			l = e.Size()
			n += 1 + l + sovDlp(uint64(l))
		}
	}
	return n
}

func (m *Value) Size() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *Value_IntegerValue) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDlp(uint64(m.IntegerValue))
	return n
}
func (m *Value_FloatValue) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_StringValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sovDlp(uint64(l))
	return n
}
func (m *Value_BooleanValue) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_TimestampValue) Size() (n int) {
	var l int
	_ = l
	if m.TimestampValue != nil {
		l = m.TimestampValue.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}
func (m *Value_TimeValue) Size() (n int) {
	var l int
	_ = l
	if m.TimeValue != nil {
		l = m.TimeValue.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}
func (m *Value_DateValue) Size() (n int) {
	var l int
	_ = l
	if m.DateValue != nil {
		l = m.DateValue.Size()
		n += 1 + l + sovDlp(uint64(l))
	}
	return n
}

func sovDlp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDlp(x uint64) (n int) {
	return sovDlp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InspectConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoTypes = append(m.InfoTypes, &InfoType{})
			if err := m.InfoTypes[len(m.InfoTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLikelihood", wireType)
			}
			m.MinLikelihood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLikelihood |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFindings", wireType)
			}
			m.MaxFindings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFindings |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeQuote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeQuote = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeTypes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeTypes = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoTypeLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoTypeLimits = append(m.InfoTypeLimits, &InspectConfig_InfoTypeLimit{})
			if err := m.InfoTypeLimits[len(m.InfoTypeLimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectConfig_InfoTypeLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoTypeLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoTypeLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoType == nil {
				m.InfoType = &InfoType{}
			}
			if err := m.InfoType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFindings", wireType)
			}
			m.MaxFindings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFindings |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItemFindings", wireType)
			}
			m.MaxItemFindings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxItemFindings |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.DataItem = &ContentItem_Data{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataItem = &ContentItem_Value{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Table{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DataItem = &ContentItem_Table{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &FieldId{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &Table_Row{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table_Row) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Row: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Row: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &Value{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Findings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Findings = append(m.Findings, &Finding{})
			if err := m.Findings[len(m.Findings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindingsTruncated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FindingsTruncated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Finding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Finding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Finding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoType == nil {
				m.InfoType = &InfoType{}
			}
			if err := m.InfoType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Likelihood", wireType)
			}
			m.Likelihood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Likelihood |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf3.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ByteRange == nil {
				m.ByteRange = &Range{}
			}
			if err := m.ByteRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodepointRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodepointRange == nil {
				m.CodepointRange = &Range{}
			}
			if err := m.CodepointRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageBoxes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageBoxes = append(m.ImageBoxes, &ImageLocation{})
			if err := m.ImageBoxes[len(m.ImageBoxes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecordKey == nil {
				m.RecordKey = &RecordKey{}
			}
			if err := m.RecordKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldId == nil {
				m.FieldId = &FieldId{}
			}
			if err := m.FieldId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableLocation == nil {
				m.TableLocation = &TableLocation{}
			}
			if err := m.TableLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowIndex", wireType)
			}
			m.RowIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowIndex |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top", wireType)
			}
			m.Top = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Top |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			m.Left = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Left |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedactContentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedactContentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedactContentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InspectConfig == nil {
				m.InspectConfig = &InspectConfig{}
			}
			if err := m.InspectConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ContentItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplaceConfigs = append(m.ReplaceConfigs, &RedactContentRequest_ReplaceConfig{})
			if err := m.ReplaceConfigs[len(m.ReplaceConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageRedactionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageRedactionConfigs = append(m.ImageRedactionConfigs, &RedactContentRequest_ImageRedactionConfig{})
			if err := m.ImageRedactionConfigs[len(m.ImageRedactionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedactContentRequest_ReplaceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoType == nil {
				m.InfoType = &InfoType{}
			}
			if err := m.InfoType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceWith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplaceWith = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedactContentRequest_ImageRedactionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageRedactionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageRedactionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &RedactContentRequest_ImageRedactionConfig_InfoType{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedactAllText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Target = &RedactContentRequest_ImageRedactionConfig_RedactAllText{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedactionColor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedactionColor == nil {
				m.RedactionColor = &Color{}
			}
			if err := m.RedactionColor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Color) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Color: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Color: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Red", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Red = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Green", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Green = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Blue = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedactContentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedactContentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedactContentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ContentItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectContentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectContentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectContentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InspectConfig == nil {
				m.InspectConfig = &InspectConfig{}
			}
			if err := m.InspectConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ContentItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectContentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectContentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectContentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &InspectResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateInspectOperationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateInspectOperationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateInspectOperationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InspectConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InspectConfig == nil {
				m.InspectConfig = &InspectConfig{}
			}
			if err := m.InspectConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageConfig == nil {
				m.StorageConfig = &StorageConfig{}
			}
			if err := m.StorageConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputConfig == nil {
				m.OutputConfig = &OutputStorageConfig{}
			}
			if err := m.OutputConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OperationConfig == nil {
				m.OperationConfig = &OperationConfig{}
			}
			if err := m.OperationConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputStorageConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputStorageConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputStorageConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BigQueryTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &OutputStorageConfig_Table{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoragePath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudStoragePath{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &OutputStorageConfig_StoragePath{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoTypeStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoTypeStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoTypeStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoType == nil {
				m.InfoType = &InfoType{}
			}
			if err := m.InfoType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectOperationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectOperationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectOperationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessedBytes", wireType)
			}
			m.ProcessedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessedBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoTypeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoTypeStats = append(m.InfoTypeStats, &InfoTypeStatistics{})
			if err := m.InfoTypeStats[len(m.InfoTypeStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf3.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalEstimatedBytes", wireType)
			}
			m.TotalEstimatedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalEstimatedBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestInspectConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestInspectConfig == nil {
				m.RequestInspectConfig = &InspectConfig{}
			}
			if err := m.RequestInspectConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestStorageConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestStorageConfig == nil {
				m.RequestStorageConfig = &StorageConfig{}
			}
			if err := m.RequestStorageConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestOutputConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestOutputConfig == nil {
				m.RequestOutputConfig = &OutputStorageConfig{}
			}
			if err := m.RequestOutputConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectOperationResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectOperationResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectOperationResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListInspectFindingsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListInspectFindingsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListInspectFindingsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListInspectFindingsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListInspectFindingsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListInspectFindingsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &InspectResult{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InfoTypeDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InfoTypeDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InfoTypeDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Categories = append(m.Categories, &CategoryDescription{})
			if err := m.Categories[len(m.Categories)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListInfoTypesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListInfoTypesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListInfoTypesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LanguageCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LanguageCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListInfoTypesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListInfoTypesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListInfoTypesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoTypes = append(m.InfoTypes, &InfoTypeDescription{})
			if err := m.InfoTypes[len(m.InfoTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRootCategoriesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRootCategoriesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRootCategoriesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LanguageCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LanguageCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRootCategoriesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRootCategoriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRootCategoriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Categories = append(m.Categories, &CategoryDescription{})
			if err := m.Categories[len(m.Categories)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegerValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &Value_IntegerValue{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Type = &Value_FloatValue{float64(math.Float64frombits(v))}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = &Value_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BooleanValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Type = &Value_BooleanValue{b}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &google_protobuf3.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Value_TimestampValue{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &google_type1.TimeOfDay{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Value_TimeValue{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDlp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &google_type.Date{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Value_DateValue{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDlp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDlp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDlp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDlp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDlp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDlp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDlp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDlp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDlp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDlp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/privacy/dlp/v2beta1/dlp.proto", fileDescriptorDlp) }

var fileDescriptorDlp = []byte{
	// 2332 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x4d, 0x6c, 0x1b, 0xc7,
	0xf5, 0xd7, 0x52, 0xa2, 0x44, 0x3e, 0x8a, 0x92, 0x3c, 0xfa, 0x88, 0x42, 0xc7, 0x8e, 0xbc, 0x4a,
	0x1c, 0x59, 0x7f, 0xff, 0xc9, 0x98, 0x45, 0x6d, 0x38, 0x81, 0x52, 0x5b, 0x94, 0x5c, 0xa9, 0x51,
	0x2c, 0x79, 0xa4, 0x28, 0x48, 0x81, 0x62, 0xb1, 0xe2, 0x8e, 0xa8, 0x81, 0x97, 0x3b, 0x9b, 0xdd,
	0xa1, 0x25, 0x26, 0x30, 0x0a, 0x14, 0x3d, 0xf4, 0xdc, 0x1e, 0x5a, 0x14, 0xed, 0xad, 0x87, 0xb6,
	0xe8, 0x2d, 0xb7, 0xa2, 0xb7, 0x5e, 0x7a, 0x2c, 0xd0, 0x53, 0xd1, 0x4b, 0x61, 0xe4, 0xd4, 0x5b,
	0x2f, 0x3d, 0x17, 0xf3, 0xb5, 0x5c, 0x4a, 0xf4, 0x4a, 0x72, 0x53, 0xa0, 0xb7, 0x99, 0x37, 0xef,
	0xbd, 0xf9, 0xcd, 0x9b, 0xf7, 0x35, 0xbb, 0xf0, 0x56, 0x8b, 0xb1, 0x96, 0x4f, 0x6a, 0x61, 0x44,
	0x9f, 0xb9, 0xcd, 0x6e, 0xcd, 0xf3, 0xc3, 0xda, 0xb3, 0xfa, 0x01, 0xe1, 0xee, 0x1d, 0x31, 0xae,
	0x86, 0x11, 0xe3, 0x0c, 0x55, 0x14, 0x57, 0x55, 0x73, 0x55, 0xc5, 0x8a, 0xe6, 0xaa, 0xbc, 0xa1,
	0x35, 0xb8, 0x21, 0xad, 0xb9, 0x41, 0xc0, 0xb8, 0xcb, 0x29, 0x0b, 0x62, 0x25, 0x59, 0x59, 0xd4,
	0xab, 0x3e, 0x0b, 0x5a, 0x51, 0x27, 0x08, 0x68, 0xd0, 0xaa, 0xb1, 0x90, 0x44, 0x7d, 0x4c, 0x4b,
	0x19, 0x20, 0x62, 0xce, 0x22, 0xb7, 0x45, 0x34, 0xe7, 0xd5, 0x84, 0x93, 0x71, 0x76, 0xd0, 0x39,
	0xac, 0x91, 0x76, 0xc8, 0xbb, 0x7a, 0xf1, 0xcd, 0xd3, 0x8b, 0x9c, 0xb6, 0x49, 0xcc, 0xdd, 0xb6,
	0x3e, 0x46, 0x65, 0x4e, 0x33, 0xf0, 0x6e, 0x48, 0x6a, 0x9e, 0xcb, 0x4f, 0x6b, 0x95, 0x74, 0x21,
	0xc4, 0x0e, 0x3d, 0x57, 0x6b, 0xb5, 0xff, 0x31, 0x0c, 0xe5, 0xcd, 0x20, 0x0e, 0x49, 0x93, 0x37,
	0x58, 0x70, 0x48, 0x5b, 0xa8, 0x01, 0x40, 0x83, 0x43, 0xe6, 0x08, 0xf6, 0x78, 0xde, 0x5a, 0x18,
	0x5e, 0x2a, 0xd5, 0xdf, 0xaa, 0xbe, 0xdc, 0x44, 0xd5, 0xcd, 0xe0, 0x90, 0xed, 0x75, 0x43, 0x82,
	0x8b, 0x54, 0x8f, 0x62, 0xf4, 0x11, 0x4c, 0xb4, 0x69, 0xe0, 0xf8, 0xf4, 0x29, 0xf1, 0xe9, 0x11,
	0x63, 0xde, 0x7c, 0x6e, 0xc1, 0x5a, 0x9a, 0xa8, 0xdf, 0xcc, 0x52, 0xb4, 0x95, 0x70, 0xe3, 0x72,
	0x9b, 0x06, 0xbd, 0x29, 0xba, 0x01, 0xe3, 0x6d, 0xf7, 0xc4, 0x39, 0xa4, 0x81, 0x47, 0x83, 0x56,
	0x3c, 0x3f, 0xbc, 0x60, 0x2d, 0xe5, 0x71, 0xa9, 0xed, 0x9e, 0x3c, 0xd2, 0x24, 0xb4, 0x08, 0x65,
	0x1a, 0x34, 0xfd, 0x8e, 0x47, 0x9c, 0xcf, 0x3a, 0x8c, 0x93, 0xf9, 0x91, 0x05, 0x6b, 0xa9, 0x80,
	0xc7, 0x35, 0xf1, 0x89, 0xa0, 0x09, 0x26, 0x72, 0xa2, 0x98, 0xd4, 0xf1, 0x46, 0x15, 0x93, 0x26,
	0x2a, 0xec, 0x2e, 0x4c, 0x25, 0x06, 0x70, 0x7c, 0xda, 0xa6, 0x3c, 0x9e, 0x1f, 0x93, 0x66, 0xb8,
	0x97, 0x6d, 0x86, 0x94, 0x15, 0x13, 0xa3, 0x6c, 0x09, 0x79, 0x3c, 0x41, 0xd3, 0xd3, 0xb8, 0xd2,
	0x11, 0x46, 0x4f, 0x51, 0xd0, 0x43, 0x28, 0x26, 0x7b, 0xce, 0x5b, 0x0b, 0xd6, 0x85, 0x6d, 0x5e,
	0x30, 0x9a, 0xcf, 0xd8, 0x28, 0x77, 0xc6, 0x46, 0xf6, 0x0a, 0x4c, 0x6e, 0x1b, 0xef, 0xd4, 0xb7,
	0xbd, 0x0c, 0x57, 0x84, 0x14, 0xe5, 0xa4, 0xdd, 0x13, 0x15, 0x00, 0x86, 0xf1, 0x64, 0xdb, 0x3d,
	0xd9, 0xe4, 0xa4, 0x9d, 0x88, 0xff, 0xd4, 0x82, 0x52, 0x83, 0x05, 0x9c, 0x04, 0x5c, 0xd0, 0x11,
	0x82, 0x91, 0x04, 0x6f, 0x11, 0xcb, 0x31, 0x9a, 0x81, 0x11, 0xcf, 0xe5, 0xae, 0xdc, 0x7d, 0x7c,
	0x63, 0x08, 0xcb, 0x19, 0x9a, 0x83, 0xfc, 0x33, 0xd7, 0xef, 0x10, 0x79, 0x71, 0xc5, 0x8d, 0x21,
	0xac, 0xa6, 0xe8, 0x3e, 0xe4, 0xb9, 0x7b, 0xe0, 0xab, 0xcb, 0x2a, 0xd5, 0x6f, 0x64, 0x1d, 0x79,
	0x4f, 0x30, 0x0a, 0x51, 0x29, 0xb1, 0x5a, 0x82, 0xa2, 0x50, 0x2d, 0x91, 0xdb, 0x7f, 0xb4, 0x20,
	0x2f, 0xd7, 0xd1, 0x0a, 0x8c, 0x1d, 0x11, 0xd7, 0x23, 0x91, 0x71, 0xdd, 0xc5, 0x2c, 0x9d, 0x8f,
	0x28, 0xf1, 0xbd, 0x4d, 0x0f, 0x1b, 0x19, 0x74, 0x1f, 0x46, 0x22, 0x76, 0x2c, 0x8c, 0x27, 0x64,
	0xdf, 0x3e, 0x17, 0x4f, 0x15, 0xb3, 0x63, 0x2c, 0x45, 0x2a, 0x0f, 0x60, 0x18, 0xb3, 0x63, 0x74,
	0x1f, 0x46, 0xe5, 0xd9, 0xcc, 0xfe, 0x99, 0x67, 0xda, 0x17, 0x9c, 0x58, 0x0b, 0xd8, 0xdf, 0x4f,
	0x42, 0x11, 0x93, 0xb8, 0xe3, 0x73, 0xf4, 0x2d, 0x28, 0xa4, 0xee, 0xe4, 0x02, 0xa7, 0x91, 0xbc,
	0x38, 0x11, 0x42, 0xff, 0x0f, 0xc8, 0x8c, 0x1d, 0x1e, 0x75, 0x82, 0xa6, 0xcb, 0x89, 0x0a, 0xc5,
	0x02, 0xbe, 0x62, 0x56, 0xf6, 0xcc, 0x82, 0xfd, 0x9b, 0x1c, 0x8c, 0x69, 0x25, 0x68, 0x06, 0xf2,
	0x2a, 0x8e, 0xd4, 0xed, 0xaa, 0x49, 0xbf, 0x9f, 0xe6, 0x5e, 0xc9, 0x4f, 0x1f, 0x01, 0xa4, 0xd2,
	0xc2, 0xf0, 0xa5, 0xd2, 0x42, 0x4a, 0x12, 0x3d, 0x80, 0x82, 0xcf, 0x9a, 0xd2, 0x97, 0xb5, 0xfb,
	0x64, 0x22, 0xd9, 0xd2, 0xbc, 0x38, 0x91, 0x42, 0xef, 0x43, 0xa9, 0x19, 0x11, 0x97, 0x13, 0x47,
	0x64, 0x45, 0x99, 0x0b, 0x4a, 0xf5, 0x4a, 0x4f, 0x89, 0xca, 0xb3, 0xd5, 0x3d, 0x93, 0x67, 0x31,
	0x28, 0x76, 0x41, 0xb0, 0xff, 0x30, 0x0c, 0x05, 0xa3, 0x13, 0x3d, 0x00, 0x38, 0xe8, 0x72, 0xe2,
	0x44, 0x6e, 0xd0, 0x32, 0xf1, 0x9b, 0x79, 0xf1, 0x58, 0x30, 0xe2, 0xa2, 0x10, 0x92, 0x43, 0xf4,
	0x1d, 0x98, 0x6c, 0x32, 0x8f, 0x84, 0x8c, 0x06, 0x5c, 0xab, 0xc9, 0x5d, 0x54, 0xcd, 0x44, 0x22,
	0x69, 0x74, 0x95, 0x68, 0xdb, 0x6d, 0x11, 0xe7, 0x80, 0x9d, 0x10, 0x91, 0x2c, 0x85, 0xe7, 0xdc,
	0xca, 0xbc, 0x26, 0xc1, 0x9e, 0x58, 0x08, 0xa4, 0xf4, 0xaa, 0x10, 0x46, 0x6b, 0x00, 0x11, 0x69,
	0xb2, 0xc8, 0x73, 0x9e, 0x92, 0xae, 0xb6, 0x73, 0x66, 0x58, 0x60, 0xc9, 0xfd, 0x21, 0xe9, 0xe2,
	0x62, 0x64, 0x86, 0xe8, 0x03, 0xe1, 0xc8, 0xc4, 0xf7, 0x1c, 0xea, 0xcd, 0xe7, 0xa5, 0x8e, 0x8b,
	0x85, 0xe5, 0xa1, 0x1a, 0xa0, 0x1d, 0x98, 0x90, 0x51, 0xef, 0x24, 0x37, 0xae, 0x2e, 0xeb, 0xd6,
	0xb9, 0x01, 0x9a, 0x1c, 0xaa, 0xcc, 0xd3, 0x53, 0xfb, 0x36, 0x94, 0xfb, 0xd6, 0xd1, 0x55, 0x28,
	0x46, 0xec, 0xd8, 0xa1, 0x81, 0x47, 0x4e, 0x74, 0x02, 0x2c, 0x44, 0xec, 0x78, 0x53, 0xcc, 0xed,
	0x1a, 0xe4, 0x95, 0x69, 0x67, 0x20, 0x1f, 0x73, 0x37, 0xe2, 0x9a, 0x43, 0x4d, 0xd0, 0x14, 0x0c,
	0x93, 0x40, 0xc5, 0xd5, 0x30, 0x16, 0x43, 0xbb, 0x09, 0xe5, 0x3e, 0x9b, 0x0a, 0x16, 0xce, 0x42,
	0x29, 0x96, 0xc7, 0x62, 0x28, 0xb2, 0xa7, 0x4f, 0x0e, 0xb9, 0xce, 0xd3, 0x72, 0x2c, 0xd4, 0x1f,
	0x53, 0x8f, 0x1f, 0xe9, 0x02, 0xa7, 0x26, 0x68, 0x0e, 0x46, 0x8f, 0x08, 0x6d, 0x1d, 0x71, 0x69,
	0xff, 0x3c, 0xd6, 0x33, 0xfb, 0xab, 0x3c, 0xcc, 0x60, 0xe2, 0xb9, 0xb2, 0xe8, 0x88, 0xac, 0x8c,
	0xc9, 0x67, 0x1d, 0x12, 0x73, 0x61, 0x2e, 0xaa, 0x12, 0x89, 0xd3, 0x94, 0x69, 0x5e, 0xbb, 0xe4,
	0xad, 0x0b, 0xd7, 0x2f, 0x5c, 0xa6, 0x7d, 0x4d, 0xc1, 0x0a, 0xe4, 0x45, 0xa2, 0x35, 0x89, 0xf1,
	0x9d, 0x2c, 0x45, 0xa9, 0x12, 0x81, 0x95, 0x14, 0x6a, 0xc1, 0x64, 0x44, 0x42, 0xdf, 0x6d, 0x12,
	0x0d, 0xc8, 0x78, 0xe5, 0x07, 0xd9, 0xae, 0x74, 0xf6, 0x6c, 0x55, 0xac, 0xf4, 0x68, 0x98, 0x13,
	0x51, 0x7a, 0x1a, 0xa3, 0xe7, 0xf0, 0x9a, 0x72, 0xfd, 0x48, 0xca, 0x52, 0x16, 0x24, 0x1b, 0x8e,
	0xc8, 0x0d, 0xd7, 0x2f, 0xbd, 0xa1, 0xbc, 0x47, 0x6c, 0xd4, 0xe9, 0x7d, 0x67, 0xe9, 0x00, 0xaa,
	0xac, 0xeb, 0x7d, 0xf8, 0xbe, 0xa6, 0xba, 0x6e, 0x6c, 0x77, 0x4c, 0xf9, 0x91, 0xf4, 0x97, 0x22,
	0x2e, 0x69, 0xda, 0x27, 0x94, 0x1f, 0x55, 0xfe, 0x66, 0xc1, 0xcc, 0x20, 0x98, 0xa8, 0xf1, 0x8a,
	0xdb, 0x6f, 0x0c, 0xa5, 0x00, 0x2c, 0x89, 0xcb, 0x13, 0x7a, 0x1d, 0xd7, 0xf7, 0x1d, 0x4e, 0x4e,
	0x94, 0xcf, 0x16, 0x36, 0x86, 0x70, 0x59, 0x2d, 0x3c, 0xf4, 0xfd, 0x3d, 0x72, 0xc2, 0x45, 0x12,
	0x4b, 0xdb, 0xdd, 0x67, 0x91, 0x74, 0xe4, 0x73, 0x92, 0x58, 0x43, 0x30, 0x8a, 0x9b, 0x4c, 0xb0,
	0xfb, 0x2c, 0x5a, 0x2d, 0xc0, 0x28, 0x77, 0xa3, 0x16, 0xe1, 0x76, 0x03, 0xf2, 0x92, 0x24, 0x62,
	0x28, 0x22, 0x9e, 0x3c, 0x47, 0x0e, 0x8b, 0xa1, 0x88, 0x97, 0x56, 0x44, 0x48, 0x20, 0x01, 0xe5,
	0xb0, 0x9a, 0x88, 0xc8, 0x3a, 0x30, 0xcd, 0x46, 0x0e, 0xcb, 0xb1, 0xbd, 0x0f, 0xb3, 0xa7, 0x6e,
	0x37, 0x0e, 0x59, 0x10, 0x93, 0x9e, 0x67, 0x5b, 0xaf, 0xe2, 0xd9, 0xf6, 0xaf, 0x2d, 0x98, 0xed,
	0x45, 0xce, 0xff, 0x72, 0x10, 0xda, 0xdf, 0x83, 0xb9, 0xd3, 0x48, 0xb5, 0x0d, 0x1a, 0x30, 0x16,
	0xc9, 0x8e, 0xc3, 0x58, 0xe1, 0x22, 0x18, 0x55, 0x8f, 0x82, 0x8d, 0xa4, 0xfd, 0xcf, 0x1c, 0x5c,
	0x6b, 0xc8, 0xfa, 0xa8, 0x19, 0x92, 0x56, 0xf3, 0xbf, 0x67, 0x91, 0x1d, 0x98, 0xd0, 0x2f, 0x28,
	0xa3, 0x31, 0x77, 0xbe, 0xc6, 0x5d, 0x25, 0x61, 0x34, 0xc6, 0xe9, 0x29, 0xda, 0x83, 0x32, 0xeb,
	0xf0, 0xb0, 0x93, 0x40, 0x54, 0x0e, 0x5c, 0xcb, 0x52, 0xb8, 0x2d, 0x05, 0xfa, 0xd5, 0x8e, 0x2b,
	0x2d, 0x5a, 0xeb, 0x3e, 0x4c, 0x25, 0xcf, 0x42, 0xa3, 0x58, 0xd5, 0xc1, 0xff, 0xcb, 0x54, 0xdc,
	0xdf, 0xac, 0xe3, 0x49, 0xd6, 0x4f, 0xb0, 0xbf, 0xb4, 0x60, 0x7a, 0xc0, 0xee, 0xe8, 0xa1, 0xe9,
	0xab, 0x2f, 0x60, 0xe0, 0x55, 0xda, 0x7a, 0xd2, 0x21, 0x51, 0xb7, 0xbf, 0xbf, 0x46, 0x4f, 0x60,
	0xdc, 0x98, 0x36, 0x74, 0x75, 0xda, 0x29, 0xd5, 0x6f, 0x67, 0xfa, 0x9c, 0xcf, 0x3a, 0x9e, 0x06,
	0xb2, 0xe3, 0xf2, 0xa3, 0x8d, 0x21, 0x5c, 0x8a, 0x7b, 0xd3, 0xd5, 0x51, 0xf5, 0x5e, 0xb0, 0xdb,
	0x80, 0x4c, 0xa2, 0xd9, 0x15, 0xef, 0xe9, 0x98, 0xd3, 0x66, 0xfc, 0x75, 0xa4, 0xca, 0x19, 0xc8,
	0x37, 0x59, 0x27, 0xe0, 0xba, 0x12, 0xab, 0x89, 0xfd, 0xe5, 0x08, 0xcc, 0x9f, 0x76, 0xc9, 0x8f,
	0x08, 0x77, 0xe5, 0xcb, 0xe4, 0x1d, 0x98, 0x0c, 0x23, 0xd6, 0x24, 0x71, 0x4c, 0x3c, 0x47, 0xb4,
	0x63, 0xe6, 0xf5, 0x33, 0x91, 0x90, 0x57, 0x05, 0x15, 0xed, 0xc3, 0x64, 0xef, 0x55, 0x18, 0x73,
	0x97, 0x9b, 0x30, 0xac, 0x5e, 0x04, 0x64, 0xef, 0x9c, 0xc2, 0x85, 0x7b, 0xb4, 0xf8, 0x74, 0x13,
	0x3a, 0x7c, 0x99, 0x26, 0x14, 0xd5, 0x61, 0x96, 0x33, 0xee, 0xfa, 0x0e, 0x89, 0x39, 0x6d, 0x8b,
	0x1e, 0x5e, 0x9f, 0x61, 0x44, 0x9e, 0x61, 0x5a, 0x2e, 0xae, 0x9b, 0x35, 0x75, 0x10, 0x07, 0xe6,
	0x22, 0x15, 0x90, 0xce, 0xa9, 0x68, 0xcc, 0x5f, 0x36, 0x1a, 0x67, 0xb4, 0xa2, 0xfe, 0x0f, 0x08,
	0xa9, 0x0d, 0x4e, 0x05, 0xe7, 0xe8, 0x65, 0x83, 0xd3, 0x6c, 0xd0, 0xef, 0xdd, 0x4d, 0x98, 0x35,
	0x1b, 0xf4, 0xc7, 0xea, 0xd8, 0xab, 0xc5, 0xea, 0xb4, 0xd6, 0xb6, 0x9d, 0x0a, 0x59, 0xfb, 0x76,
	0x92, 0x2d, 0x53, 0x79, 0x4c, 0xbe, 0xca, 0x10, 0x8c, 0x04, 0x6e, 0x3b, 0x79, 0xf6, 0x8a, 0xb1,
	0xfd, 0x43, 0x0b, 0x2a, 0x5b, 0x34, 0xb1, 0x84, 0x79, 0x32, 0x9b, 0xcc, 0x37, 0x40, 0x44, 0x34,
	0x9c, 0xa1, 0xb0, 0x4d, 0x4c, 0x3f, 0x27, 0xba, 0x09, 0x2c, 0x08, 0xc2, 0x2e, 0xfd, 0x9c, 0xa0,
	0x6b, 0x00, 0x72, 0x91, 0xb3, 0xa7, 0x24, 0x50, 0xaf, 0x66, 0x2c, 0xd9, 0xf7, 0x04, 0x41, 0x74,
	0x84, 0x87, 0xd4, 0xe7, 0x24, 0x92, 0x17, 0x5d, 0xc4, 0x7a, 0x66, 0xff, 0xc8, 0x82, 0xab, 0x03,
	0x61, 0xe8, 0x44, 0xff, 0x10, 0x46, 0x55, 0xba, 0xbe, 0x44, 0xe6, 0xd5, 0x79, 0x5e, 0x0b, 0xa2,
	0x9b, 0x30, 0x19, 0x90, 0x13, 0xee, 0xa4, 0xe0, 0xa9, 0x8e, 0xa4, 0x2c, 0xc8, 0x3b, 0x06, 0xa2,
	0xfd, 0x4b, 0x0b, 0xa6, 0x8d, 0xf7, 0xaf, 0x91, 0xb8, 0x19, 0xd1, 0x50, 0x36, 0xc2, 0x83, 0x4c,
	0x71, 0x03, 0xc6, 0x3d, 0x1a, 0x87, 0xbe, 0xdb, 0x75, 0xe4, 0x9a, 0x6e, 0x71, 0x34, 0xed, 0xb1,
	0x60, 0xd9, 0x06, 0x10, 0x6f, 0xd4, 0x16, 0x8b, 0x68, 0xf2, 0xa4, 0xc9, 0xbc, 0xe8, 0x86, 0xe2,
	0xee, 0xa6, 0xf6, 0xc6, 0x29, 0x15, 0xf6, 0x27, 0x30, 0xa3, 0x2c, 0xa5, 0x3f, 0x59, 0x99, 0xab,
	0xaa, 0x40, 0x41, 0x73, 0x75, 0x35, 0xc6, 0x64, 0x8e, 0x16, 0xa1, 0xec, 0xbb, 0x41, 0xab, 0xa3,
	0x5c, 0xda, 0x33, 0x40, 0xc7, 0x0d, 0xb1, 0xc1, 0x3c, 0x62, 0xb7, 0x60, 0xf6, 0x94, 0x62, 0x6d,
	0xfc, 0xc7, 0x03, 0x3e, 0xac, 0xd5, 0x2e, 0x92, 0x3c, 0xd2, 0x47, 0xe8, 0x7d, 0x63, 0xb3, 0xb7,
	0x60, 0x7a, 0xc0, 0x21, 0x5f, 0xd1, 0xc0, 0xf6, 0x03, 0x78, 0x5d, 0xc0, 0xc6, 0x8c, 0xf1, 0x46,
	0x62, 0x25, 0x63, 0x94, 0x33, 0x07, 0xb7, 0x06, 0x1c, 0xbc, 0xad, 0x42, 0xe0, 0xb4, 0x06, 0x7d,
	0xfa, 0xfe, 0x0b, 0xb4, 0xfe, 0xf3, 0x0b, 0xfc, 0x6b, 0x0e, 0xf2, 0xf2, 0xfb, 0x09, 0x7a, 0x1b,
	0xca, 0x34, 0xe0, 0xa4, 0x45, 0x22, 0x47, 0x7d, 0x65, 0x92, 0x19, 0x7c, 0x63, 0x08, 0x8f, 0x6b,
	0xb2, 0x62, 0xbb, 0x01, 0xa5, 0x43, 0x9f, 0xb9, 0x5c, 0x33, 0x09, 0x1b, 0x58, 0x1b, 0x43, 0x18,
	0x24, 0x51, 0xb1, 0x2c, 0x8a, 0xa2, 0x17, 0xd1, 0xa0, 0xe5, 0xf4, 0x7f, 0xae, 0x2a, 0x29, 0x6a,
	0xb2, 0xdd, 0x01, 0x63, 0x3e, 0x71, 0x03, 0xcd, 0x35, 0xa2, 0xbb, 0xe1, 0x71, 0x4d, 0x56, 0x6c,
	0xeb, 0x30, 0x99, 0x7c, 0xa1, 0xd5, 0x8c, 0xf9, 0xf3, 0x92, 0xfb, 0xc6, 0x10, 0x9e, 0x48, 0x84,
	0x94, 0x9a, 0x7b, 0x00, 0x82, 0xa2, 0x35, 0xa8, 0x0c, 0x3a, 0x67, 0x34, 0x08, 0x57, 0x92, 0xd2,
	0xdb, 0x87, 0x6b, 0x6e, 0x77, 0x63, 0x08, 0x17, 0x05, 0xaf, 0x12, 0xac, 0x03, 0x78, 0xa2, 0xac,
	0x28, 0x41, 0x95, 0x1a, 0xaf, 0xf4, 0x09, 0xae, 0xb9, 0x5c, 0x14, 0xfc, 0xa2, 0x60, 0x93, 0x32,
	0xa6, 0x42, 0x2f, 0x73, 0x80, 0xd4, 0xd7, 0xd7, 0x0a, 0xcc, 0x6d, 0x6d, 0x7e, 0xb8, 0xbe, 0xb5,
	0xb9, 0xb1, 0xbd, 0xbd, 0xe6, 0x7c, 0xfc, 0x78, 0x77, 0x67, 0xbd, 0xb1, 0xf9, 0x68, 0x73, 0x7d,
	0x6d, 0x6a, 0x08, 0x5d, 0x81, 0xf2, 0xfe, 0x3a, 0xfe, 0xd4, 0xf9, 0xf8, 0xb1, 0x64, 0xf9, 0x74,
	0xca, 0x42, 0xe3, 0x50, 0x48, 0x66, 0x39, 0x31, 0xdb, 0xd9, 0xde, 0xdd, 0xdd, 0x5c, 0xdd, 0x5a,
	0x9f, 0x1a, 0x46, 0x00, 0xa3, 0x7a, 0x65, 0x04, 0x4d, 0x42, 0x49, 0x8a, 0x6a, 0x42, 0xbe, 0xfe,
	0xaf, 0x31, 0x80, 0x35, 0x3f, 0xdc, 0x25, 0xd1, 0x33, 0xda, 0x24, 0xe8, 0x17, 0x16, 0x4c, 0xf4,
	0x37, 0xac, 0xe8, 0xce, 0xc5, 0x6a, 0x53, 0xaa, 0x0d, 0xaf, 0xd4, 0x2f, 0x23, 0xa2, 0x7c, 0xd5,
	0x5e, 0xfc, 0xc1, 0x5f, 0xbe, 0xfa, 0x49, 0xee, 0x9a, 0x3d, 0x9f, 0x7c, 0xa7, 0x6f, 0x2a, 0x8e,
	0xf7, 0x74, 0xc5, 0x7c, 0xcf, 0x5a, 0x46, 0x3f, 0xb3, 0xc4, 0x63, 0x2f, 0xf5, 0xa4, 0x40, 0xef,
	0x5e, 0xf6, 0x6d, 0x59, 0xb9, 0x73, 0x09, 0x09, 0x8d, 0xcd, 0x96, 0xd8, 0xde, 0xb0, 0x5f, 0x3b,
	0x83, 0x4d, 0x3d, 0xa0, 0x04, 0xb4, 0x9f, 0x5b, 0x30, 0x37, 0xb8, 0x15, 0x47, 0xf7, 0x33, 0x43,
	0x2e, 0xab, 0x7d, 0xaf, 0x5c, 0x33, 0xa2, 0xa9, 0xbf, 0x1d, 0xbd, 0x16, 0xd5, 0xbe, 0x29, 0x81,
	0x2d, 0xd8, 0x57, 0x13, 0x60, 0xda, 0x58, 0xa9, 0x3f, 0x22, 0x02, 0xdc, 0xef, 0x2d, 0x98, 0x1e,
	0x50, 0xa3, 0xd0, 0xdd, 0xec, 0x6f, 0x80, 0x2f, 0xab, 0xad, 0x95, 0x7b, 0x97, 0x96, 0xd3, 0x96,
	0xac, 0x4b, 0xc0, 0xb7, 0xd1, 0x72, 0x02, 0xf8, 0x0b, 0x91, 0x1c, 0x57, 0x0c, 0x6c, 0xfd, 0xb0,
	0xa9, 0x2d, 0x3f, 0xaf, 0x25, 0x1f, 0x54, 0x7f, 0x67, 0x41, 0xb9, 0x2f, 0xbb, 0x67, 0x5f, 0xfa,
	0xa0, 0x0a, 0x93, 0x7d, 0xe9, 0x03, 0x4b, 0x87, 0x7d, 0x57, 0x42, 0x7d, 0x17, 0x55, 0x13, 0xa8,
	0x51, 0x5f, 0x96, 0xad, 0x7d, 0x61, 0x6a, 0xd4, 0xca, 0xf2, 0xf3, 0x5a, 0xef, 0x37, 0xcc, 0xaf,
	0x2c, 0x40, 0x67, 0x73, 0x32, 0xfa, 0xe6, 0x79, 0x08, 0x06, 0x56, 0x81, 0xca, 0xdd, 0xcb, 0x8a,
	0x69, 0xf4, 0x6f, 0x4a, 0xf4, 0xaf, 0xa3, 0xd7, 0x5e, 0x82, 0x7e, 0xf5, 0xc7, 0xd6, 0x9f, 0x5e,
	0x5c, 0xb7, 0xfe, 0xfc, 0xe2, 0xba, 0xf5, 0xf7, 0x17, 0xd7, 0x2d, 0xb8, 0xde, 0x64, 0xed, 0x8c,
	0xad, 0x56, 0x0b, 0x6b, 0x7e, 0xb8, 0x23, 0x72, 0xe7, 0x8e, 0xf5, 0xdd, 0x15, 0xcd, 0xd7, 0x62,
	0xa2, 0x16, 0x55, 0x59, 0xd4, 0xaa, 0xb5, 0x48, 0x20, 0x33, 0x6b, 0x4d, 0x2d, 0xb9, 0x21, 0x8d,
	0x07, 0xfd, 0x7b, 0x7b, 0xdf, 0xf3, 0xc3, 0xdf, 0xe6, 0xe6, 0xbf, 0xad, 0xe4, 0xe5, 0xdb, 0xa5,
	0xba, 0xe6, 0x87, 0xd5, 0xfd, 0xfa, 0xaa, 0x58, 0x3e, 0x18, 0x95, 0x4a, 0xbe, 0xf1, 0xef, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x12, 0xd0, 0x28, 0x2e, 0x44, 0x1c, 0x00, 0x00,
}
