// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/streetview/publish/v1/resources.proto

/*
	Package publish is a generated protocol buffer package.

	It is generated from these files:
		google/streetview/publish/v1/resources.proto
		google/streetview/publish/v1/rpcmessages.proto
		google/streetview/publish/v1/streetview_publish.proto

	It has these top-level messages:
		UploadRef
		PhotoId
		Level
		Pose
		Place
		Connection
		Photo
		CreatePhotoRequest
		GetPhotoRequest
		BatchGetPhotosRequest
		BatchGetPhotosResponse
		PhotoResponse
		ListPhotosRequest
		ListPhotosResponse
		UpdatePhotoRequest
		BatchUpdatePhotosRequest
		BatchUpdatePhotosResponse
		DeletePhotoRequest
		BatchDeletePhotosRequest
		BatchDeletePhotosResponse
*/
package publish

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_type "google.golang.org/genproto/googleapis/type/latlng"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Upload reference for media files.
type UploadRef struct {
	// Required. An upload reference should be unique for each user. It follows
	// the form:
	// "https://streetviewpublish.googleapis.com/media/user/<account_id>/photo/<upload_reference>"
	UploadUrl string `protobuf:"bytes,1,opt,name=upload_url,json=uploadUrl,proto3" json:"upload_url,omitempty"`
}

func (m *UploadRef) Reset()                    { *m = UploadRef{} }
func (m *UploadRef) String() string            { return proto.CompactTextString(m) }
func (*UploadRef) ProtoMessage()               {}
func (*UploadRef) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{0} }

func (m *UploadRef) GetUploadUrl() string {
	if m != nil {
		return m.UploadUrl
	}
	return ""
}

// Identifier for a photo.
type PhotoId struct {
	// Required. A base64 encoded identifier.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *PhotoId) Reset()                    { *m = PhotoId{} }
func (m *PhotoId) String() string            { return proto.CompactTextString(m) }
func (*PhotoId) ProtoMessage()               {}
func (*PhotoId) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{1} }

func (m *PhotoId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Level information containing level number and its corresponding name.
type Level struct {
	// Floor number, used for ordering. 0 indicates the ground level, 1 indicates
	// the first level above ground level, -1 indicates the first level under
	// ground level. Non-integer values are OK.
	Number float64 `protobuf:"fixed64,1,opt,name=number,proto3" json:"number,omitempty"`
	// Required. A name assigned to this Level, restricted to 3 characters.
	// Consider how the elevator buttons would be labeled for this level if there
	// was an elevator.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Level) Reset()                    { *m = Level{} }
func (m *Level) String() string            { return proto.CompactTextString(m) }
func (*Level) ProtoMessage()               {}
func (*Level) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{2} }

func (m *Level) GetNumber() float64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Level) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Raw pose measurement for an entity.
type Pose struct {
	// Latitude and longitude pair of the pose, as explained here:
	// https://cloud.google.com/datastore/docs/reference/rest/Shared.Types/LatLng
	// When creating a photo, if the latitude and longitude pair are not provided
	// here, the geolocation from the exif header will be used.
	// If the latitude and longitude pair is not provided and cannot be found in
	// the exif header, the create photo process will fail.
	LatLngPair *google_type.LatLng `protobuf:"bytes,1,opt,name=lat_lng_pair,json=latLngPair" json:"lat_lng_pair,omitempty"`
	// Altitude of the pose in meters above ground level (as defined by WGS84).
	// NaN indicates an unmeasured quantity.
	Altitude float64 `protobuf:"fixed64,2,opt,name=altitude,proto3" json:"altitude,omitempty"`
	// Compass heading, measured at the center of the photo in degrees clockwise
	// from North. Value must be >=0 and <360.
	// NaN indicates an unmeasured quantity.
	Heading float64 `protobuf:"fixed64,3,opt,name=heading,proto3" json:"heading,omitempty"`
	// Pitch, measured at the center of the photo in degrees. Value must be >=-90
	// and <= 90. A value of -90 means looking directly down, and a value of 90
	// means looking directly up.
	// NaN indicates an unmeasured quantity.
	Pitch float64 `protobuf:"fixed64,4,opt,name=pitch,proto3" json:"pitch,omitempty"`
	// Roll, measured in degrees. Value must be >= 0 and <360. A value of 0
	// means level with the horizon.
	// NaN indicates an unmeasured quantity.
	Roll float64 `protobuf:"fixed64,5,opt,name=roll,proto3" json:"roll,omitempty"`
	// Level (the floor in a building) used to configure vertical navigation.
	Level *Level `protobuf:"bytes,7,opt,name=level" json:"level,omitempty"`
}

func (m *Pose) Reset()                    { *m = Pose{} }
func (m *Pose) String() string            { return proto.CompactTextString(m) }
func (*Pose) ProtoMessage()               {}
func (*Pose) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{3} }

func (m *Pose) GetLatLngPair() *google_type.LatLng {
	if m != nil {
		return m.LatLngPair
	}
	return nil
}

func (m *Pose) GetAltitude() float64 {
	if m != nil {
		return m.Altitude
	}
	return 0
}

func (m *Pose) GetHeading() float64 {
	if m != nil {
		return m.Heading
	}
	return 0
}

func (m *Pose) GetPitch() float64 {
	if m != nil {
		return m.Pitch
	}
	return 0
}

func (m *Pose) GetRoll() float64 {
	if m != nil {
		return m.Roll
	}
	return 0
}

func (m *Pose) GetLevel() *Level {
	if m != nil {
		return m.Level
	}
	return nil
}

// Place metadata for an entity.
type Place struct {
	// Required. Place identifier, as described in
	// https://developers.google.com/places/place-id.
	PlaceId string `protobuf:"bytes,1,opt,name=place_id,json=placeId,proto3" json:"place_id,omitempty"`
}

func (m *Place) Reset()                    { *m = Place{} }
func (m *Place) String() string            { return proto.CompactTextString(m) }
func (*Place) ProtoMessage()               {}
func (*Place) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{4} }

func (m *Place) GetPlaceId() string {
	if m != nil {
		return m.PlaceId
	}
	return ""
}

// A connection is the link from a source photo to a destination photo.
type Connection struct {
	// Required. The destination of the connection from the containing photo to
	// another photo.
	Target *PhotoId `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
}

func (m *Connection) Reset()                    { *m = Connection{} }
func (m *Connection) String() string            { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()               {}
func (*Connection) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{5} }

func (m *Connection) GetTarget() *PhotoId {
	if m != nil {
		return m.Target
	}
	return nil
}

// Photo is used to store 360 photos along with photo metadata.
type Photo struct {
	// Output only. Identifier for the photo, which is unique among all photos in
	// Google.
	PhotoId *PhotoId `protobuf:"bytes,1,opt,name=photo_id,json=photoId" json:"photo_id,omitempty"`
	// Required (when creating photo). Input only. The resource URL where the
	// photo bytes are uploaded to.
	UploadReference *UploadRef `protobuf:"bytes,2,opt,name=upload_reference,json=uploadReference" json:"upload_reference,omitempty"`
	// Output only. The download URL for the photo bytes. This field is set only
	// when the `view` parameter in a `GetPhotoRequest` is set to
	// `INCLUDE_DOWNLOAD_URL`.
	DownloadUrl string `protobuf:"bytes,3,opt,name=download_url,json=downloadUrl,proto3" json:"download_url,omitempty"`
	// Output only. The thumbnail URL for showing a preview of the given photo.
	ThumbnailUrl string `protobuf:"bytes,9,opt,name=thumbnail_url,json=thumbnailUrl,proto3" json:"thumbnail_url,omitempty"`
	// Output only. The share link for the photo.
	ShareLink string `protobuf:"bytes,11,opt,name=share_link,json=shareLink,proto3" json:"share_link,omitempty"`
	// Pose of the photo.
	Pose *Pose `protobuf:"bytes,4,opt,name=pose" json:"pose,omitempty"`
	// Connections to other photos. A connection represents the link from this
	// photo to another photo.
	Connections []*Connection `protobuf:"bytes,5,rep,name=connections" json:"connections,omitempty"`
	// Absolute time when the photo was captured.
	// When the photo has no exif timestamp, this is used to set a timestamp in
	// the photo metadata.
	CaptureTime *google_protobuf1.Timestamp `protobuf:"bytes,6,opt,name=capture_time,json=captureTime" json:"capture_time,omitempty"`
	// Places where this photo belongs.
	Places []*Place `protobuf:"bytes,7,rep,name=places" json:"places,omitempty"`
	// Output only. View count of the photo.
	ViewCount int64 `protobuf:"varint,10,opt,name=view_count,json=viewCount,proto3" json:"view_count,omitempty"`
}

func (m *Photo) Reset()                    { *m = Photo{} }
func (m *Photo) String() string            { return proto.CompactTextString(m) }
func (*Photo) ProtoMessage()               {}
func (*Photo) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{6} }

func (m *Photo) GetPhotoId() *PhotoId {
	if m != nil {
		return m.PhotoId
	}
	return nil
}

func (m *Photo) GetUploadReference() *UploadRef {
	if m != nil {
		return m.UploadReference
	}
	return nil
}

func (m *Photo) GetDownloadUrl() string {
	if m != nil {
		return m.DownloadUrl
	}
	return ""
}

func (m *Photo) GetThumbnailUrl() string {
	if m != nil {
		return m.ThumbnailUrl
	}
	return ""
}

func (m *Photo) GetShareLink() string {
	if m != nil {
		return m.ShareLink
	}
	return ""
}

func (m *Photo) GetPose() *Pose {
	if m != nil {
		return m.Pose
	}
	return nil
}

func (m *Photo) GetConnections() []*Connection {
	if m != nil {
		return m.Connections
	}
	return nil
}

func (m *Photo) GetCaptureTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CaptureTime
	}
	return nil
}

func (m *Photo) GetPlaces() []*Place {
	if m != nil {
		return m.Places
	}
	return nil
}

func (m *Photo) GetViewCount() int64 {
	if m != nil {
		return m.ViewCount
	}
	return 0
}

func init() {
	proto.RegisterType((*UploadRef)(nil), "google.streetview.publish.v1.UploadRef")
	proto.RegisterType((*PhotoId)(nil), "google.streetview.publish.v1.PhotoId")
	proto.RegisterType((*Level)(nil), "google.streetview.publish.v1.Level")
	proto.RegisterType((*Pose)(nil), "google.streetview.publish.v1.Pose")
	proto.RegisterType((*Place)(nil), "google.streetview.publish.v1.Place")
	proto.RegisterType((*Connection)(nil), "google.streetview.publish.v1.Connection")
	proto.RegisterType((*Photo)(nil), "google.streetview.publish.v1.Photo")
}
func (m *UploadRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UploadUrl) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.UploadUrl)))
		i += copy(dAtA[i:], m.UploadUrl)
	}
	return i, nil
}

func (m *PhotoId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *Level) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Level) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Resources(dAtA, i, uint64(math.Float64bits(float64(m.Number))))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Pose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pose) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LatLngPair != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.LatLngPair.Size()))
		n1, err := m.LatLngPair.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Altitude != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Resources(dAtA, i, uint64(math.Float64bits(float64(m.Altitude))))
	}
	if m.Heading != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Resources(dAtA, i, uint64(math.Float64bits(float64(m.Heading))))
	}
	if m.Pitch != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Resources(dAtA, i, uint64(math.Float64bits(float64(m.Pitch))))
	}
	if m.Roll != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Resources(dAtA, i, uint64(math.Float64bits(float64(m.Roll))))
	}
	if m.Level != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.Level.Size()))
		n2, err := m.Level.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Place) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Place) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlaceId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.PlaceId)))
		i += copy(dAtA[i:], m.PlaceId)
	}
	return i, nil
}

func (m *Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.Target.Size()))
		n3, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Photo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Photo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PhotoId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.PhotoId.Size()))
		n4, err := m.PhotoId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.UploadReference != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.UploadReference.Size()))
		n5, err := m.UploadReference.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.DownloadUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.DownloadUrl)))
		i += copy(dAtA[i:], m.DownloadUrl)
	}
	if m.Pose != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.Pose.Size()))
		n6, err := m.Pose.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Connections) > 0 {
		for _, msg := range m.Connections {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintResources(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CaptureTime != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.CaptureTime.Size()))
		n7, err := m.CaptureTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Places) > 0 {
		for _, msg := range m.Places {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintResources(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ThumbnailUrl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.ThumbnailUrl)))
		i += copy(dAtA[i:], m.ThumbnailUrl)
	}
	if m.ViewCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.ViewCount))
	}
	if len(m.ShareLink) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.ShareLink)))
		i += copy(dAtA[i:], m.ShareLink)
	}
	return i, nil
}

func encodeFixed64Resources(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Resources(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintResources(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UploadRef) Size() (n int) {
	var l int
	_ = l
	l = len(m.UploadUrl)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}

func (m *PhotoId) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}

func (m *Level) Size() (n int) {
	var l int
	_ = l
	if m.Number != 0 {
		n += 9
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}

func (m *Pose) Size() (n int) {
	var l int
	_ = l
	if m.LatLngPair != nil {
		l = m.LatLngPair.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	if m.Altitude != 0 {
		n += 9
	}
	if m.Heading != 0 {
		n += 9
	}
	if m.Pitch != 0 {
		n += 9
	}
	if m.Roll != 0 {
		n += 9
	}
	if m.Level != nil {
		l = m.Level.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}

func (m *Place) Size() (n int) {
	var l int
	_ = l
	l = len(m.PlaceId)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}

func (m *Connection) Size() (n int) {
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}

func (m *Photo) Size() (n int) {
	var l int
	_ = l
	if m.PhotoId != nil {
		l = m.PhotoId.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	if m.UploadReference != nil {
		l = m.UploadReference.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	l = len(m.DownloadUrl)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	if m.Pose != nil {
		l = m.Pose.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	if len(m.Connections) > 0 {
		for _, e := range m.Connections {
			l = e.Size()
			n += 1 + l + sovResources(uint64(l))
		}
	}
	if m.CaptureTime != nil {
		l = m.CaptureTime.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	if len(m.Places) > 0 {
		for _, e := range m.Places {
			l = e.Size()
			n += 1 + l + sovResources(uint64(l))
		}
	}
	l = len(m.ThumbnailUrl)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	if m.ViewCount != 0 {
		n += 1 + sovResources(uint64(m.ViewCount))
	}
	l = len(m.ShareLink)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}

func sovResources(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozResources(x uint64) (n int) {
	return sovResources(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UploadRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhotoId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Level) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Level: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Level: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Number = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatLngPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatLngPair == nil {
				m.LatLngPair = &google_type.LatLng{}
			}
			if err := m.LatLngPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Altitude = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heading", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Heading = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pitch", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Pitch = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roll", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Roll = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Level == nil {
				m.Level = &Level{}
			}
			if err := m.Level.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Place) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Place: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Place: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &PhotoId{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Photo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Photo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Photo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PhotoId == nil {
				m.PhotoId = &PhotoId{}
			}
			if err := m.PhotoId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadReference == nil {
				m.UploadReference = &UploadRef{}
			}
			if err := m.UploadReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownloadUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pose == nil {
				m.Pose = &Pose{}
			}
			if err := m.Pose.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connections = append(m.Connections, &Connection{})
			if err := m.Connections[len(m.Connections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptureTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaptureTime == nil {
				m.CaptureTime = &google_protobuf1.Timestamp{}
			}
			if err := m.CaptureTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Places", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Places = append(m.Places, &Place{})
			if err := m.Places[len(m.Places)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbnailUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbnailUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewCount", wireType)
			}
			m.ViewCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShareLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipResources(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowResources
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowResources
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowResources
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthResources
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowResources
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipResources(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthResources = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowResources   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("google/streetview/publish/v1/resources.proto", fileDescriptorResources)
}

var fileDescriptorResources = []byte{
	// 669 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0x96, 0x9b, 0x7f, 0xcd, 0x38, 0xbf, 0x3f, 0x5a, 0x10, 0x72, 0x23, 0x5a, 0x8a, 0x2b, 0x44,
	0x84, 0x90, 0xad, 0xa6, 0x02, 0x09, 0x55, 0x95, 0x50, 0x7b, 0x2a, 0xe4, 0x10, 0x2d, 0x94, 0x03,
	0x97, 0x68, 0x63, 0x4f, 0x9d, 0x55, 0x37, 0xbb, 0xd6, 0x7a, 0x9d, 0x8a, 0x27, 0xe1, 0x01, 0x78,
	0x19, 0x8e, 0x1c, 0x39, 0xa2, 0x3e, 0x09, 0xf2, 0x7a, 0x9d, 0x72, 0xa8, 0x52, 0x4e, 0x9e, 0xf9,
	0x66, 0xbe, 0xf1, 0xec, 0x37, 0xb3, 0x0b, 0x2f, 0x33, 0xa5, 0x32, 0x81, 0x71, 0x61, 0x34, 0xa2,
	0x59, 0x71, 0xbc, 0x8e, 0xf3, 0x72, 0x2e, 0x78, 0xb1, 0x88, 0x57, 0x87, 0xb1, 0xc6, 0x42, 0x95,
	0x3a, 0xc1, 0x22, 0xca, 0xb5, 0x32, 0x8a, 0x3c, 0xae, 0xb3, 0xa3, 0xdb, 0xec, 0xc8, 0x65, 0x47,
	0xab, 0xc3, 0xa1, 0x8b, 0xc6, 0x2c, 0xe7, 0x31, 0x93, 0x52, 0x19, 0x66, 0xb8, 0x92, 0x8e, 0x3b,
	0x7c, 0xe2, 0xa2, 0xd6, 0x9b, 0x97, 0x97, 0xb1, 0xe1, 0x4b, 0x2c, 0x0c, 0x5b, 0xe6, 0x2e, 0x21,
	0x70, 0x09, 0xe6, 0x4b, 0x8e, 0xb1, 0x60, 0x46, 0xc8, 0xac, 0x8e, 0x84, 0x2f, 0xa0, 0x7f, 0x91,
	0x0b, 0xc5, 0x52, 0x8a, 0x97, 0x64, 0x17, 0xa0, 0xb4, 0xce, 0xac, 0xd4, 0x22, 0xf0, 0xf6, 0xbd,
	0x51, 0x9f, 0xf6, 0x6b, 0xe4, 0x42, 0x8b, 0x70, 0x07, 0x7a, 0xd3, 0x85, 0x32, 0xea, 0x3c, 0x25,
	0xff, 0xc2, 0x16, 0x4f, 0x5d, 0xc6, 0x16, 0x4f, 0xc3, 0x23, 0xe8, 0x4c, 0x70, 0x85, 0x82, 0x3c,
	0x82, 0xae, 0x2c, 0x97, 0x73, 0xd4, 0x36, 0xe8, 0x51, 0xe7, 0x11, 0x02, 0x6d, 0xc9, 0x96, 0x18,
	0x6c, 0x59, 0x8a, 0xb5, 0xc3, 0x9f, 0x1e, 0xb4, 0xa7, 0xaa, 0x40, 0xf2, 0x0a, 0x06, 0x82, 0x99,
	0x99, 0x90, 0xd9, 0x2c, 0x67, 0xbc, 0xa6, 0xfa, 0xe3, 0x07, 0x91, 0x93, 0xa4, 0xea, 0x3a, 0x9a,
	0x30, 0x33, 0x91, 0x19, 0x05, 0x61, 0xbf, 0x53, 0xc6, 0x35, 0x19, 0xc2, 0x36, 0x13, 0x86, 0x9b,
	0x32, 0xad, 0xeb, 0x7a, 0x74, 0xed, 0x93, 0x00, 0x7a, 0x0b, 0x64, 0x29, 0x97, 0x59, 0xd0, 0xb2,
	0xa1, 0xc6, 0x25, 0x0f, 0xa1, 0x93, 0x73, 0x93, 0x2c, 0x82, 0xb6, 0xc5, 0x6b, 0xa7, 0xea, 0x4f,
	0x2b, 0x21, 0x82, 0x8e, 0x05, 0xad, 0x4d, 0xde, 0x40, 0x47, 0x54, 0x87, 0x0a, 0x7a, 0xb6, 0x9f,
	0x83, 0x68, 0xd3, 0x88, 0x22, 0x7b, 0x7e, 0x5a, 0x33, 0xc2, 0x10, 0x3a, 0x53, 0xc1, 0x12, 0x24,
	0x3b, 0xb0, 0x9d, 0x57, 0xc6, 0x6c, 0x2d, 0x57, 0xcf, 0xfa, 0xe7, 0x69, 0xf8, 0x1e, 0xe0, 0x4c,
	0x49, 0x89, 0x49, 0x35, 0x4a, 0x72, 0x02, 0x5d, 0xc3, 0x74, 0x86, 0xc6, 0x9d, 0xfe, 0xd9, 0xe6,
	0xbf, 0xb9, 0x41, 0x50, 0x47, 0x0a, 0xbf, 0xb5, 0xa1, 0x63, 0x31, 0xf2, 0x16, 0xb6, 0xf3, 0xca,
	0x68, 0xfe, 0xf8, 0xd7, 0xa5, 0x7a, 0xb9, 0x1b, 0x2e, 0x85, 0xff, 0xdd, 0x1a, 0x68, 0xbc, 0x44,
	0x8d, 0x32, 0xa9, 0xf5, 0xf5, 0xc7, 0xcf, 0x37, 0x57, 0x5a, 0x6f, 0x12, 0xfd, 0xaf, 0x6c, 0xcc,
	0x9a, 0x4f, 0x9e, 0xc2, 0x20, 0x55, 0xd7, 0x72, 0xbd, 0x5c, 0x2d, 0xab, 0x85, 0xdf, 0x60, 0x17,
	0x5a, 0x90, 0xd7, 0xd0, 0xce, 0x55, 0x81, 0x76, 0x2e, 0xfe, 0x38, 0xbc, 0xa7, 0x69, 0x55, 0x20,
	0xb5, 0xf9, 0xe4, 0x1d, 0xf8, 0xc9, 0x5a, 0xc7, 0x22, 0xe8, 0xec, 0xb7, 0x46, 0xfe, 0x78, 0xb4,
	0x99, 0x7e, 0x2b, 0x3c, 0xfd, 0x93, 0x4c, 0x4e, 0x60, 0x90, 0xb0, 0xdc, 0x94, 0x1a, 0x67, 0xd5,
	0x1d, 0x0a, 0xba, 0xb6, 0x97, 0x61, 0x53, 0xac, 0xb9, 0x60, 0xd1, 0xc7, 0xe6, 0x82, 0x51, 0xdf,
	0xe5, 0x57, 0x08, 0x39, 0x86, 0xae, 0x9d, 0x6e, 0x11, 0xf4, 0x6c, 0x17, 0xf7, 0xac, 0x8c, 0x5d,
	0x11, 0xea, 0x28, 0xe4, 0x00, 0xfe, 0x31, 0x8b, 0x72, 0x39, 0x97, 0x8c, 0x0b, 0xab, 0x51, 0xdf,
	0x6a, 0x34, 0x58, 0x83, 0x95, 0x48, 0xbb, 0x00, 0x55, 0x95, 0x59, 0xa2, 0x4a, 0x69, 0x02, 0xd8,
	0xf7, 0x46, 0x2d, 0xda, 0xaf, 0x90, 0xb3, 0x0a, 0xa8, 0xc2, 0xc5, 0x82, 0x69, 0x9c, 0x09, 0x2e,
	0xaf, 0x02, 0xbf, 0xbe, 0xc1, 0x16, 0x99, 0x70, 0x79, 0x75, 0xfa, 0xd5, 0xfb, 0x7e, 0xb3, 0xe7,
	0xfd, 0xb8, 0xd9, 0xf3, 0x7e, 0xdd, 0xec, 0x79, 0x30, 0x4a, 0xd4, 0xb2, 0xe9, 0x30, 0x43, 0x15,
	0x95, 0x59, 0x72, 0x77, 0xa7, 0xa7, 0xc3, 0x0f, 0x16, 0xfe, 0xc4, 0xf1, 0x7a, 0x5a, 0xa3, 0xb4,
	0x79, 0xbf, 0x3e, 0x9f, 0x35, 0x15, 0x94, 0x60, 0x32, 0x8b, 0x94, 0xce, 0xe2, 0x0c, 0xa5, 0x95,
	0x2a, 0xae, 0x43, 0x2c, 0xe7, 0xc5, 0xdd, 0xcf, 0xe0, 0xb1, 0x33, 0xe7, 0x5d, 0x9b, 0x7f, 0xf4,
	0x3b, 0x00, 0x00, 0xff, 0xff, 0x1e, 0x2f, 0x62, 0xb6, 0x35, 0x05, 0x00, 0x00,
}
