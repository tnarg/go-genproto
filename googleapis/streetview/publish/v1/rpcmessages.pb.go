// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/streetview/publish/v1/rpcmessages.proto

package publish

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf2 "google.golang.org/genproto/protobuf/field_mask"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Specifies which view of the `Photo` should be included in the response.
type PhotoView int32

const (
	// Server reponses do not include the download URL for the photo bytes.
	// The default value.
	PhotoView_BASIC PhotoView = 0
	// Server responses include the download URL for the photo bytes.
	PhotoView_INCLUDE_DOWNLOAD_URL PhotoView = 1
)

var PhotoView_name = map[int32]string{
	0: "BASIC",
	1: "INCLUDE_DOWNLOAD_URL",
}
var PhotoView_value = map[string]int32{
	"BASIC":                0,
	"INCLUDE_DOWNLOAD_URL": 1,
}

func (x PhotoView) String() string {
	return proto.EnumName(PhotoView_name, int32(x))
}
func (PhotoView) EnumDescriptor() ([]byte, []int) { return fileDescriptorRpcmessages, []int{0} }

// Request to create a photo.
type CreatePhotoRequest struct {
	// Required. Photo to create.
	Photo *Photo `protobuf:"bytes,1,opt,name=photo" json:"photo,omitempty"`
}

func (m *CreatePhotoRequest) Reset()                    { *m = CreatePhotoRequest{} }
func (m *CreatePhotoRequest) String() string            { return proto.CompactTextString(m) }
func (*CreatePhotoRequest) ProtoMessage()               {}
func (*CreatePhotoRequest) Descriptor() ([]byte, []int) { return fileDescriptorRpcmessages, []int{0} }

func (m *CreatePhotoRequest) GetPhoto() *Photo {
	if m != nil {
		return m.Photo
	}
	return nil
}

// Request to get a photo.
//
// By default
// - does not return the download URL for the photo bytes.
//
// Parameters:
// - 'view' controls if the download URL for the photo bytes will be returned.
type GetPhotoRequest struct {
	// Required. ID of the photo.
	PhotoId string `protobuf:"bytes,1,opt,name=photo_id,json=photoId,proto3" json:"photo_id,omitempty"`
	// Specifies if a download URL for the photo bytes should be returned in the
	// Photo response.
	View PhotoView `protobuf:"varint,2,opt,name=view,proto3,enum=google.streetview.publish.v1.PhotoView" json:"view,omitempty"`
}

func (m *GetPhotoRequest) Reset()                    { *m = GetPhotoRequest{} }
func (m *GetPhotoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPhotoRequest) ProtoMessage()               {}
func (*GetPhotoRequest) Descriptor() ([]byte, []int) { return fileDescriptorRpcmessages, []int{1} }

func (m *GetPhotoRequest) GetPhotoId() string {
	if m != nil {
		return m.PhotoId
	}
	return ""
}

func (m *GetPhotoRequest) GetView() PhotoView {
	if m != nil {
		return m.View
	}
	return PhotoView_BASIC
}

// Request to get one or more photos.
// By default
// - does not return the download URL for the photo bytes.
//
// Parameters:
// - 'view' controls if the download URL for the photo bytes will be returned.
type BatchGetPhotosRequest struct {
	// Required. IDs of the photos.
	PhotoIds []string `protobuf:"bytes,1,rep,name=photo_ids,json=photoIds" json:"photo_ids,omitempty"`
	// Specifies if a download URL for the photo bytes should be returned in the
	// Photo response.
	View PhotoView `protobuf:"varint,2,opt,name=view,proto3,enum=google.streetview.publish.v1.PhotoView" json:"view,omitempty"`
}

func (m *BatchGetPhotosRequest) Reset()                    { *m = BatchGetPhotosRequest{} }
func (m *BatchGetPhotosRequest) String() string            { return proto.CompactTextString(m) }
func (*BatchGetPhotosRequest) ProtoMessage()               {}
func (*BatchGetPhotosRequest) Descriptor() ([]byte, []int) { return fileDescriptorRpcmessages, []int{2} }

func (m *BatchGetPhotosRequest) GetPhotoIds() []string {
	if m != nil {
		return m.PhotoIds
	}
	return nil
}

func (m *BatchGetPhotosRequest) GetView() PhotoView {
	if m != nil {
		return m.View
	}
	return PhotoView_BASIC
}

// Response to batch get of photos.
type BatchGetPhotosResponse struct {
	// List of results for each individual photo requested, in the same order as
	// the request.
	Results []*PhotoResponse `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *BatchGetPhotosResponse) Reset()         { *m = BatchGetPhotosResponse{} }
func (m *BatchGetPhotosResponse) String() string { return proto.CompactTextString(m) }
func (*BatchGetPhotosResponse) ProtoMessage()    {}
func (*BatchGetPhotosResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorRpcmessages, []int{3}
}

func (m *BatchGetPhotosResponse) GetResults() []*PhotoResponse {
	if m != nil {
		return m.Results
	}
	return nil
}

// Response payload for a single `Photo` in batch operations including
// `BatchGetPhotosRequest` and `BatchUpdatePhotosRequest`.
type PhotoResponse struct {
	// The status for the operation to get or update a single photo in the batch
	// request.
	Status *google_rpc.Status `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	// The photo resource, if the request was successful.
	Photo *Photo `protobuf:"bytes,2,opt,name=photo" json:"photo,omitempty"`
}

func (m *PhotoResponse) Reset()                    { *m = PhotoResponse{} }
func (m *PhotoResponse) String() string            { return proto.CompactTextString(m) }
func (*PhotoResponse) ProtoMessage()               {}
func (*PhotoResponse) Descriptor() ([]byte, []int) { return fileDescriptorRpcmessages, []int{4} }

func (m *PhotoResponse) GetStatus() *google_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *PhotoResponse) GetPhoto() *Photo {
	if m != nil {
		return m.Photo
	}
	return nil
}

// Request to list all photos that belong to the user sending the request.
//
// By default
// - does not return the download URL for the photo bytes.
//
// Parameters:
// - 'view' controls if the download URL for the photo bytes will be returned.
// - 'page_size' determines the maximum number of photos to return.
// - 'page_token' is the next page token value returned from a previous List
//     request, if any.
type ListPhotosRequest struct {
	// Specifies if a download URL for the photos bytes should be returned in the
	// Photos response.
	View PhotoView `protobuf:"varint,1,opt,name=view,proto3,enum=google.streetview.publish.v1.PhotoView" json:"view,omitempty"`
	// The maximum number of photos to return.
	// `page_size` must be non-negative. If `page_size` is zero or is not
	// provided, the default page size of 100 will be used.
	// The number of photos returned in the response may be less than `page_size`
	// if the number of photos that belong to the user is less than `page_size`.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// The next_page_token value returned from a previous List request, if any.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The filter expression.
	// Example: `placeId=ChIJj61dQgK6j4AR4GeTYWZsKWw`
	Filter string `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
}

func (m *ListPhotosRequest) Reset()                    { *m = ListPhotosRequest{} }
func (m *ListPhotosRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPhotosRequest) ProtoMessage()               {}
func (*ListPhotosRequest) Descriptor() ([]byte, []int) { return fileDescriptorRpcmessages, []int{5} }

func (m *ListPhotosRequest) GetView() PhotoView {
	if m != nil {
		return m.View
	}
	return PhotoView_BASIC
}

func (m *ListPhotosRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListPhotosRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListPhotosRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

// Response to list all photos that belong to a user.
type ListPhotosResponse struct {
	// List of photos. There will be a maximum number of items returned based on
	// the page_size field in the request.
	Photos []*Photo `protobuf:"bytes,1,rep,name=photos" json:"photos,omitempty"`
	// Token to retrieve the next page of results, or empty if there are no
	// more results in the list.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *ListPhotosResponse) Reset()                    { *m = ListPhotosResponse{} }
func (m *ListPhotosResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPhotosResponse) ProtoMessage()               {}
func (*ListPhotosResponse) Descriptor() ([]byte, []int) { return fileDescriptorRpcmessages, []int{6} }

func (m *ListPhotosResponse) GetPhotos() []*Photo {
	if m != nil {
		return m.Photos
	}
	return nil
}

func (m *ListPhotosResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Request to update the metadata of a photo.
// Updating the pixels of a photo is not supported.
type UpdatePhotoRequest struct {
	// Required. Photo object containing the new metadata. Only the fields
	// specified in `update_mask` are used. If `update_mask` is not present, the
	// update applies to all fields.
	// **Note:** To update `pose.altitude`, `pose.latlngpair` has to be filled as
	// well. Otherwise, the request will fail.
	Photo *Photo `protobuf:"bytes,1,opt,name=photo" json:"photo,omitempty"`
	// Mask that identifies fields on the photo metadata to update.
	// If not present, the old Photo metadata will be entirely replaced with the
	// new Photo metadata in this request. The update fails if invalid fields are
	// specified. Multiple fields can be specified in a comma-delimited list.
	//
	// The following fields are valid:
	//
	// * `pose.heading`
	// * `pose.latlngpair`
	// * `pose.pitch`
	// * `pose.roll`
	// * `pose.level`
	// * `pose.altitude`
	// * `connections`
	// * `places`
	//
	//
	// **Note:** Repeated fields in `update_mask` mean the entire set of repeated
	// values will be replaced with the new contents. For example, if
	// `UpdatePhotoRequest.photo.update_mask` contains `connections` and
	// `UpdatePhotoRequest.photo.connections` is empty, all connections will be
	// removed.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdatePhotoRequest) Reset()                    { *m = UpdatePhotoRequest{} }
func (m *UpdatePhotoRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdatePhotoRequest) ProtoMessage()               {}
func (*UpdatePhotoRequest) Descriptor() ([]byte, []int) { return fileDescriptorRpcmessages, []int{7} }

func (m *UpdatePhotoRequest) GetPhoto() *Photo {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *UpdatePhotoRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// Request to update the metadata of photos.
// Updating the pixels of photos is not supported.
type BatchUpdatePhotosRequest struct {
	// Required. List of update photo requests.
	UpdatePhotoRequests []*UpdatePhotoRequest `protobuf:"bytes,1,rep,name=update_photo_requests,json=updatePhotoRequests" json:"update_photo_requests,omitempty"`
}

func (m *BatchUpdatePhotosRequest) Reset()         { *m = BatchUpdatePhotosRequest{} }
func (m *BatchUpdatePhotosRequest) String() string { return proto.CompactTextString(m) }
func (*BatchUpdatePhotosRequest) ProtoMessage()    {}
func (*BatchUpdatePhotosRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorRpcmessages, []int{8}
}

func (m *BatchUpdatePhotosRequest) GetUpdatePhotoRequests() []*UpdatePhotoRequest {
	if m != nil {
		return m.UpdatePhotoRequests
	}
	return nil
}

// Response to batch update of metadata of one or more photos.
type BatchUpdatePhotosResponse struct {
	// List of results for each individual photo updated, in the same order as
	// the request.
	Results []*PhotoResponse `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *BatchUpdatePhotosResponse) Reset()         { *m = BatchUpdatePhotosResponse{} }
func (m *BatchUpdatePhotosResponse) String() string { return proto.CompactTextString(m) }
func (*BatchUpdatePhotosResponse) ProtoMessage()    {}
func (*BatchUpdatePhotosResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorRpcmessages, []int{9}
}

func (m *BatchUpdatePhotosResponse) GetResults() []*PhotoResponse {
	if m != nil {
		return m.Results
	}
	return nil
}

// Request to delete a photo.
type DeletePhotoRequest struct {
	// Required. ID of the photo.
	PhotoId string `protobuf:"bytes,1,opt,name=photo_id,json=photoId,proto3" json:"photo_id,omitempty"`
}

func (m *DeletePhotoRequest) Reset()                    { *m = DeletePhotoRequest{} }
func (m *DeletePhotoRequest) String() string            { return proto.CompactTextString(m) }
func (*DeletePhotoRequest) ProtoMessage()               {}
func (*DeletePhotoRequest) Descriptor() ([]byte, []int) { return fileDescriptorRpcmessages, []int{10} }

func (m *DeletePhotoRequest) GetPhotoId() string {
	if m != nil {
		return m.PhotoId
	}
	return ""
}

// Request to delete multiple photos.
type BatchDeletePhotosRequest struct {
	// Required. List of delete photo requests.
	PhotoIds []string `protobuf:"bytes,1,rep,name=photo_ids,json=photoIds" json:"photo_ids,omitempty"`
}

func (m *BatchDeletePhotosRequest) Reset()         { *m = BatchDeletePhotosRequest{} }
func (m *BatchDeletePhotosRequest) String() string { return proto.CompactTextString(m) }
func (*BatchDeletePhotosRequest) ProtoMessage()    {}
func (*BatchDeletePhotosRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorRpcmessages, []int{11}
}

func (m *BatchDeletePhotosRequest) GetPhotoIds() []string {
	if m != nil {
		return m.PhotoIds
	}
	return nil
}

// Response to batch delete of one or more photos.
type BatchDeletePhotosResponse struct {
	// The status for the operation to delete a single photo in the batch request.
	Status []*google_rpc.Status `protobuf:"bytes,1,rep,name=status" json:"status,omitempty"`
}

func (m *BatchDeletePhotosResponse) Reset()         { *m = BatchDeletePhotosResponse{} }
func (m *BatchDeletePhotosResponse) String() string { return proto.CompactTextString(m) }
func (*BatchDeletePhotosResponse) ProtoMessage()    {}
func (*BatchDeletePhotosResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorRpcmessages, []int{12}
}

func (m *BatchDeletePhotosResponse) GetStatus() []*google_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func init() {
	proto.RegisterType((*CreatePhotoRequest)(nil), "google.streetview.publish.v1.CreatePhotoRequest")
	proto.RegisterType((*GetPhotoRequest)(nil), "google.streetview.publish.v1.GetPhotoRequest")
	proto.RegisterType((*BatchGetPhotosRequest)(nil), "google.streetview.publish.v1.BatchGetPhotosRequest")
	proto.RegisterType((*BatchGetPhotosResponse)(nil), "google.streetview.publish.v1.BatchGetPhotosResponse")
	proto.RegisterType((*PhotoResponse)(nil), "google.streetview.publish.v1.PhotoResponse")
	proto.RegisterType((*ListPhotosRequest)(nil), "google.streetview.publish.v1.ListPhotosRequest")
	proto.RegisterType((*ListPhotosResponse)(nil), "google.streetview.publish.v1.ListPhotosResponse")
	proto.RegisterType((*UpdatePhotoRequest)(nil), "google.streetview.publish.v1.UpdatePhotoRequest")
	proto.RegisterType((*BatchUpdatePhotosRequest)(nil), "google.streetview.publish.v1.BatchUpdatePhotosRequest")
	proto.RegisterType((*BatchUpdatePhotosResponse)(nil), "google.streetview.publish.v1.BatchUpdatePhotosResponse")
	proto.RegisterType((*DeletePhotoRequest)(nil), "google.streetview.publish.v1.DeletePhotoRequest")
	proto.RegisterType((*BatchDeletePhotosRequest)(nil), "google.streetview.publish.v1.BatchDeletePhotosRequest")
	proto.RegisterType((*BatchDeletePhotosResponse)(nil), "google.streetview.publish.v1.BatchDeletePhotosResponse")
	proto.RegisterEnum("google.streetview.publish.v1.PhotoView", PhotoView_name, PhotoView_value)
}
func (m *CreatePhotoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePhotoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Photo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(m.Photo.Size()))
		n1, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *GetPhotoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPhotoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhotoId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(len(m.PhotoId)))
		i += copy(dAtA[i:], m.PhotoId)
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(m.View))
	}
	return i, nil
}

func (m *BatchGetPhotosRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchGetPhotosRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhotoIds) > 0 {
		for _, s := range m.PhotoIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(m.View))
	}
	return i, nil
}

func (m *BatchGetPhotosResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchGetPhotosResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PhotoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Photo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(m.Photo.Size()))
		n3, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ListPhotosRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPhotosRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.View != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(m.View))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if len(m.Filter) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	return i, nil
}

func (m *ListPhotosResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPhotosResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Photos) > 0 {
		for _, msg := range m.Photos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *UpdatePhotoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePhotoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Photo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(m.Photo.Size()))
		n4, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.UpdateMask != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(m.UpdateMask.Size()))
		n5, err := m.UpdateMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *BatchUpdatePhotosRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchUpdatePhotosRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UpdatePhotoRequests) > 0 {
		for _, msg := range m.UpdatePhotoRequests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BatchUpdatePhotosResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchUpdatePhotosResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeletePhotoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePhotoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhotoId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcmessages(dAtA, i, uint64(len(m.PhotoId)))
		i += copy(dAtA[i:], m.PhotoId)
	}
	return i, nil
}

func (m *BatchDeletePhotosRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchDeletePhotosRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhotoIds) > 0 {
		for _, s := range m.PhotoIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *BatchDeletePhotosResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchDeletePhotosResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		for _, msg := range m.Status {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcmessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Rpcmessages(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Rpcmessages(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRpcmessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CreatePhotoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	return n
}

func (m *GetPhotoRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhotoId)
	if l > 0 {
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	if m.View != 0 {
		n += 1 + sovRpcmessages(uint64(m.View))
	}
	return n
}

func (m *BatchGetPhotosRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.PhotoIds) > 0 {
		for _, s := range m.PhotoIds {
			l = len(s)
			n += 1 + l + sovRpcmessages(uint64(l))
		}
	}
	if m.View != 0 {
		n += 1 + sovRpcmessages(uint64(m.View))
	}
	return n
}

func (m *BatchGetPhotosResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovRpcmessages(uint64(l))
		}
	}
	return n
}

func (m *PhotoResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	return n
}

func (m *ListPhotosRequest) Size() (n int) {
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovRpcmessages(uint64(m.View))
	}
	if m.PageSize != 0 {
		n += 1 + sovRpcmessages(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	return n
}

func (m *ListPhotosResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Photos) > 0 {
		for _, e := range m.Photos {
			l = e.Size()
			n += 1 + l + sovRpcmessages(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	return n
}

func (m *UpdatePhotoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	if m.UpdateMask != nil {
		l = m.UpdateMask.Size()
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	return n
}

func (m *BatchUpdatePhotosRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.UpdatePhotoRequests) > 0 {
		for _, e := range m.UpdatePhotoRequests {
			l = e.Size()
			n += 1 + l + sovRpcmessages(uint64(l))
		}
	}
	return n
}

func (m *BatchUpdatePhotosResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovRpcmessages(uint64(l))
		}
	}
	return n
}

func (m *DeletePhotoRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhotoId)
	if l > 0 {
		n += 1 + l + sovRpcmessages(uint64(l))
	}
	return n
}

func (m *BatchDeletePhotosRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.PhotoIds) > 0 {
		for _, s := range m.PhotoIds {
			l = len(s)
			n += 1 + l + sovRpcmessages(uint64(l))
		}
	}
	return n
}

func (m *BatchDeletePhotosResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Status) > 0 {
		for _, e := range m.Status {
			l = e.Size()
			n += 1 + l + sovRpcmessages(uint64(l))
		}
	}
	return n
}

func sovRpcmessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRpcmessages(x uint64) (n int) {
	return sovRpcmessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreatePhotoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePhotoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePhotoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &Photo{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPhotoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPhotoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPhotoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= (PhotoView(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchGetPhotosRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchGetPhotosRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchGetPhotosRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoIds = append(m.PhotoIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= (PhotoView(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchGetPhotosResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchGetPhotosResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchGetPhotosResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &PhotoResponse{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhotoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &google_rpc.Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &Photo{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPhotosRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPhotosRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPhotosRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= (PhotoView(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPhotosResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPhotosResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPhotosResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photos = append(m.Photos, &Photo{})
			if err := m.Photos[len(m.Photos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePhotoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePhotoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePhotoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &Photo{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateMask == nil {
				m.UpdateMask = &google_protobuf2.FieldMask{}
			}
			if err := m.UpdateMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchUpdatePhotosRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchUpdatePhotosRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchUpdatePhotosRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePhotoRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatePhotoRequests = append(m.UpdatePhotoRequests, &UpdatePhotoRequest{})
			if err := m.UpdatePhotoRequests[len(m.UpdatePhotoRequests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchUpdatePhotosResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchUpdatePhotosResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchUpdatePhotosResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &PhotoResponse{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePhotoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePhotoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePhotoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchDeletePhotosRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchDeletePhotosRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchDeletePhotosRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoIds = append(m.PhotoIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchDeletePhotosResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchDeletePhotosResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchDeletePhotosResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcmessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, &google_rpc.Status{})
			if err := m.Status[len(m.Status)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcmessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcmessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpcmessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpcmessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcmessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRpcmessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRpcmessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRpcmessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRpcmessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpcmessages   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("google/streetview/publish/v1/rpcmessages.proto", fileDescriptorRpcmessages)
}

var fileDescriptorRpcmessages = []byte{
	// 661 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x4e, 0xdb, 0x4a,
	0x14, 0xbe, 0xc3, 0x4f, 0x20, 0x07, 0x71, 0xe1, 0xce, 0xbd, 0x70, 0x4d, 0x4a, 0x51, 0xe4, 0x4a,
	0x6d, 0x44, 0x2b, 0x1b, 0xe8, 0xa2, 0xaa, 0xb2, 0x22, 0x09, 0x45, 0x48, 0xe1, 0x47, 0x4e, 0x69,
	0xa5, 0x6e, 0x2c, 0xc7, 0x39, 0x18, 0x0b, 0x93, 0x31, 0x9e, 0x71, 0x68, 0x59, 0xf5, 0x01, 0xfa,
	0x02, 0xdd, 0xf7, 0x61, 0xba, 0xec, 0x23, 0x54, 0x3c, 0x49, 0xe5, 0xf1, 0x0c, 0x04, 0x48, 0xa3,
	0xb4, 0x65, 0x67, 0x9f, 0x9f, 0xef, 0xfb, 0xe6, 0x3b, 0x73, 0x6c, 0xb0, 0x02, 0xc6, 0x82, 0x08,
	0x6d, 0x2e, 0x12, 0x44, 0xd1, 0x0b, 0xf1, 0xdc, 0x8e, 0xd3, 0x76, 0x14, 0xf2, 0x63, 0xbb, 0xb7,
	0x6e, 0x27, 0xb1, 0x7f, 0x8a, 0x9c, 0x7b, 0x01, 0x72, 0x2b, 0x4e, 0x98, 0x60, 0x74, 0x39, 0xaf,
	0xb7, 0xae, 0xeb, 0x2d, 0x55, 0x6f, 0xf5, 0xd6, 0x4b, 0x65, 0x85, 0x26, 0x6b, 0xdb, 0xe9, 0x91,
	0x7d, 0x14, 0x62, 0xd4, 0x71, 0x4f, 0x3d, 0x7e, 0x92, 0xf7, 0x97, 0xfe, 0x57, 0x15, 0x49, 0xec,
	0xdb, 0x5c, 0x78, 0x22, 0x55, 0xc0, 0xa5, 0x67, 0xc3, 0x85, 0x20, 0x67, 0x69, 0xe2, 0x6b, 0x19,
	0xe6, 0x3e, 0xd0, 0x7a, 0x82, 0x9e, 0xc0, 0x83, 0x63, 0x26, 0x98, 0x83, 0x67, 0x29, 0x72, 0x41,
	0x5f, 0xc2, 0x64, 0x9c, 0xbd, 0x1b, 0xa4, 0x4c, 0x2a, 0x33, 0x1b, 0x8f, 0xac, 0x61, 0x62, 0xad,
	0xbc, 0x35, 0xef, 0x30, 0x43, 0x98, 0xdb, 0x46, 0x71, 0x03, 0x6d, 0x09, 0xa6, 0x65, 0xce, 0x0d,
	0x3b, 0x12, 0xb0, 0xe8, 0x4c, 0xc9, 0xf7, 0x9d, 0x0e, 0xad, 0xc2, 0x44, 0x86, 0x66, 0x8c, 0x95,
	0x49, 0xe5, 0xef, 0x8d, 0x27, 0x23, 0xf0, 0xbc, 0x09, 0xf1, 0xdc, 0x91, 0x4d, 0xe6, 0x19, 0x2c,
	0xd4, 0x3c, 0xe1, 0x1f, 0x6b, 0x3e, 0xae, 0x09, 0x1f, 0x40, 0x51, 0x13, 0x72, 0x83, 0x94, 0xc7,
	0x2b, 0x45, 0x67, 0x5a, 0x31, 0xf2, 0x3f, 0xa3, 0x74, 0x61, 0xf1, 0x36, 0x25, 0x8f, 0x59, 0x97,
	0x23, 0xdd, 0x82, 0xa9, 0x04, 0x79, 0x1a, 0x89, 0x9c, 0x71, 0x66, 0xe3, 0xe9, 0x28, 0xa6, 0xa9,
	0x6e, 0x47, 0xf7, 0x9a, 0x3d, 0x98, 0xbd, 0x91, 0xa1, 0xab, 0x50, 0xc8, 0xc7, 0xab, 0x66, 0x41,
	0x35, 0x6c, 0x12, 0xfb, 0x56, 0x4b, 0x66, 0x1c, 0x55, 0x71, 0x3d, 0xb6, 0xb1, 0x5f, 0x1e, 0xdb,
	0x17, 0x02, 0xff, 0x34, 0x43, 0x7e, 0xcb, 0x48, 0xed, 0x15, 0xf9, 0x0d, 0xaf, 0xe4, 0x14, 0xbc,
	0x00, 0x5d, 0x1e, 0x5e, 0xa0, 0x54, 0x34, 0xe9, 0x4c, 0x67, 0x81, 0x56, 0x78, 0x81, 0xf4, 0x21,
	0x80, 0x4c, 0x0a, 0x76, 0x82, 0x5d, 0x63, 0x5c, 0xde, 0x0a, 0x59, 0xfe, 0x3a, 0x0b, 0xd0, 0x45,
	0x28, 0x1c, 0x85, 0x91, 0xc0, 0xc4, 0x98, 0x90, 0x29, 0xf5, 0x66, 0x7e, 0x00, 0xda, 0xaf, 0x52,
	0x79, 0x54, 0x85, 0x82, 0x3c, 0x85, 0xb6, 0x7e, 0xa4, 0x83, 0xab, 0x16, 0xfa, 0x18, 0xe6, 0xba,
	0xf8, 0x5e, 0xb8, 0x7d, 0x72, 0xc6, 0x24, 0xe7, 0x6c, 0x16, 0x3e, 0xd0, 0x92, 0xcc, 0x4f, 0x04,
	0xe8, 0x61, 0xdc, 0xb9, 0xbf, 0x55, 0xa1, 0x55, 0x98, 0x49, 0x25, 0xa0, 0xdc, 0x6b, 0x35, 0xb4,
	0x92, 0x06, 0xd0, 0xab, 0x6f, 0xbd, 0xca, 0x56, 0x7f, 0xd7, 0xe3, 0x27, 0x0e, 0xe4, 0xe5, 0xd9,
	0xb3, 0xf9, 0x91, 0x80, 0x21, 0xaf, 0x62, 0x9f, 0xa6, 0xab, 0xb9, 0x75, 0x60, 0x41, 0x21, 0xe7,
	0x7b, 0x90, 0xe4, 0x71, 0xed, 0xcf, 0xda, 0x70, 0x91, 0x77, 0x4f, 0xe9, 0xfc, 0x9b, 0xde, 0x89,
	0x71, 0xb3, 0x0d, 0x4b, 0x03, 0x14, 0xdc, 0xef, 0x3e, 0xd8, 0x40, 0x1b, 0x18, 0xe1, 0x2d, 0xd3,
	0x7f, 0xfe, 0x45, 0x31, 0x5f, 0x28, 0x5b, 0xfa, 0xba, 0x46, 0xfa, 0x2e, 0x98, 0xdb, 0xea, 0x34,
	0x37, 0x1b, 0x07, 0x6c, 0xe1, 0xf8, 0xf0, 0x2d, 0x5c, 0x5d, 0x83, 0xe2, 0xd5, 0x2a, 0xd0, 0x22,
	0x4c, 0xd6, 0x36, 0x5b, 0x3b, 0xf5, 0xf9, 0xbf, 0xa8, 0x01, 0xff, 0xed, 0xec, 0xd5, 0x9b, 0x87,
	0x8d, 0x2d, 0xb7, 0xb1, 0xff, 0x76, 0xaf, 0xb9, 0xbf, 0xd9, 0x70, 0x0f, 0x9d, 0xe6, 0x3c, 0xa9,
	0x7d, 0x26, 0x5f, 0x2f, 0x57, 0xc8, 0xb7, 0xcb, 0x15, 0xf2, 0xfd, 0x72, 0x85, 0x40, 0xc5, 0x67,
	0xa7, 0x1a, 0x3f, 0x40, 0x66, 0xa5, 0x81, 0x3f, 0xd8, 0xb4, 0xda, 0x72, 0x4b, 0x86, 0x33, 0xa6,
	0x83, 0x3c, 0xea, 0xc4, 0xfe, 0xae, 0xfa, 0xd1, 0xbc, 0xab, 0x6b, 0x0c, 0x16, 0x79, 0xdd, 0xc0,
	0x62, 0x49, 0x60, 0x07, 0xd8, 0x95, 0xf7, 0xca, 0xce, 0x53, 0x5e, 0x1c, 0xf2, 0xc1, 0x3f, 0x8a,
	0xaa, 0x7a, 0x6c, 0x17, 0x64, 0xfd, 0xf3, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x07, 0x41, 0xae,
	0x75, 0xe0, 0x06, 0x00, 0x00,
}
