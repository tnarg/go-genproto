// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/assistant/embedded/v1alpha1/embedded_assistant.proto

/*
	Package embedded is a generated protocol buffer package.

	It is generated from these files:
		google/assistant/embedded/v1alpha1/embedded_assistant.proto

	It has these top-level messages:
		ConverseConfig
		AudioInConfig
		AudioOutConfig
		ConverseState
		AudioOut
		ConverseResult
		ConverseRequest
		ConverseResponse
*/
package embedded

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Audio encoding of the data sent in the audio message.
// Audio must be one-channel (mono). The only language supported is "en-US".
type AudioInConfig_Encoding int32

const (
	// Not specified. Will return result [google.rpc.Code.INVALID_ARGUMENT][].
	AudioInConfig_ENCODING_UNSPECIFIED AudioInConfig_Encoding = 0
	// Uncompressed 16-bit signed little-endian samples (Linear PCM).
	// This encoding includes no header, only the raw audio bytes.
	AudioInConfig_LINEAR16 AudioInConfig_Encoding = 1
	// [`FLAC`](https://xiph.org/flac/documentation.html) (Free Lossless Audio
	// Codec) is the recommended encoding because it is
	// lossless--therefore recognition is not compromised--and
	// requires only about half the bandwidth of `LINEAR16`. This encoding
	// includes the `FLAC` stream header followed by audio data. It supports
	// 16-bit and 24-bit samples, however, not all fields in `STREAMINFO` are
	// supported.
	AudioInConfig_FLAC AudioInConfig_Encoding = 2
)

var AudioInConfig_Encoding_name = map[int32]string{
	0: "ENCODING_UNSPECIFIED",
	1: "LINEAR16",
	2: "FLAC",
}
var AudioInConfig_Encoding_value = map[string]int32{
	"ENCODING_UNSPECIFIED": 0,
	"LINEAR16":             1,
	"FLAC":                 2,
}

func (x AudioInConfig_Encoding) String() string {
	return proto.EnumName(AudioInConfig_Encoding_name, int32(x))
}
func (AudioInConfig_Encoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorEmbeddedAssistant, []int{1, 0}
}

// Audio encoding of the data returned in the audio message. All encodings are
// raw audio bytes with no header, except as indicated below.
type AudioOutConfig_Encoding int32

const (
	// Not specified. Will return result [google.rpc.Code.INVALID_ARGUMENT][].
	AudioOutConfig_ENCODING_UNSPECIFIED AudioOutConfig_Encoding = 0
	// Uncompressed 16-bit signed little-endian samples (Linear PCM).
	AudioOutConfig_LINEAR16 AudioOutConfig_Encoding = 1
	// MP3 audio encoding. The sample rate is encoded in the payload.
	AudioOutConfig_MP3 AudioOutConfig_Encoding = 2
	// Opus-encoded audio wrapped in an ogg container. The result will be a
	// file which can be played natively on Android and in some browsers (such
	// as Chrome). The quality of the encoding is considerably higher than MP3
	// while using the same bitrate. The sample rate is encoded in the payload.
	AudioOutConfig_OPUS_IN_OGG AudioOutConfig_Encoding = 3
)

var AudioOutConfig_Encoding_name = map[int32]string{
	0: "ENCODING_UNSPECIFIED",
	1: "LINEAR16",
	2: "MP3",
	3: "OPUS_IN_OGG",
}
var AudioOutConfig_Encoding_value = map[string]int32{
	"ENCODING_UNSPECIFIED": 0,
	"LINEAR16":             1,
	"MP3":                  2,
	"OPUS_IN_OGG":          3,
}

func (x AudioOutConfig_Encoding) String() string {
	return proto.EnumName(AudioOutConfig_Encoding_name, int32(x))
}
func (AudioOutConfig_Encoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorEmbeddedAssistant, []int{2, 0}
}

// Possible states of the microphone after a `Converse` RPC completes.
type ConverseResult_MicrophoneMode int32

const (
	// No mode specified.
	ConverseResult_MICROPHONE_MODE_UNSPECIFIED ConverseResult_MicrophoneMode = 0
	// The service is not expecting a follow-on question from the user.
	// The microphone should remain off until the user re-activates it.
	ConverseResult_CLOSE_MICROPHONE ConverseResult_MicrophoneMode = 1
	// The service is expecting a follow-on question from the user. The
	// microphone should be re-opened when the `AudioOut` playback completes
	// (by starting a new `Converse` RPC call to send the new audio).
	ConverseResult_DIALOG_FOLLOW_ON ConverseResult_MicrophoneMode = 2
)

var ConverseResult_MicrophoneMode_name = map[int32]string{
	0: "MICROPHONE_MODE_UNSPECIFIED",
	1: "CLOSE_MICROPHONE",
	2: "DIALOG_FOLLOW_ON",
}
var ConverseResult_MicrophoneMode_value = map[string]int32{
	"MICROPHONE_MODE_UNSPECIFIED": 0,
	"CLOSE_MICROPHONE":            1,
	"DIALOG_FOLLOW_ON":            2,
}

func (x ConverseResult_MicrophoneMode) String() string {
	return proto.EnumName(ConverseResult_MicrophoneMode_name, int32(x))
}
func (ConverseResult_MicrophoneMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorEmbeddedAssistant, []int{5, 0}
}

// Indicates the type of event.
type ConverseResponse_EventType int32

const (
	// No event specified.
	ConverseResponse_EVENT_TYPE_UNSPECIFIED ConverseResponse_EventType = 0
	// This event indicates that the server has detected the end of the user's
	// speech utterance and expects no additional speech. Therefore, the server
	// will not process additional audio (although it may subsequently return
	// additional results). The client should stop sending additional audio
	// data, half-close the gRPC connection, and wait for any additional results
	// until the server closes the gRPC connection.
	ConverseResponse_END_OF_UTTERANCE ConverseResponse_EventType = 1
)

var ConverseResponse_EventType_name = map[int32]string{
	0: "EVENT_TYPE_UNSPECIFIED",
	1: "END_OF_UTTERANCE",
}
var ConverseResponse_EventType_value = map[string]int32{
	"EVENT_TYPE_UNSPECIFIED": 0,
	"END_OF_UTTERANCE":       1,
}

func (x ConverseResponse_EventType) String() string {
	return proto.EnumName(ConverseResponse_EventType_name, int32(x))
}
func (ConverseResponse_EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorEmbeddedAssistant, []int{7, 0}
}

// Specifies how to process the `ConverseRequest` messages.
type ConverseConfig struct {
	// *Required* Specifies how to process the subsequent incoming audio.
	AudioInConfig *AudioInConfig `protobuf:"bytes,1,opt,name=audio_in_config,json=audioInConfig" json:"audio_in_config,omitempty"`
	// *Required* Specifies how to format the audio that will be returned.
	AudioOutConfig *AudioOutConfig `protobuf:"bytes,2,opt,name=audio_out_config,json=audioOutConfig" json:"audio_out_config,omitempty"`
	// *Required* Represents the current dialog state.
	ConverseState *ConverseState `protobuf:"bytes,3,opt,name=converse_state,json=converseState" json:"converse_state,omitempty"`
}

func (m *ConverseConfig) Reset()                    { *m = ConverseConfig{} }
func (m *ConverseConfig) String() string            { return proto.CompactTextString(m) }
func (*ConverseConfig) ProtoMessage()               {}
func (*ConverseConfig) Descriptor() ([]byte, []int) { return fileDescriptorEmbeddedAssistant, []int{0} }

func (m *ConverseConfig) GetAudioInConfig() *AudioInConfig {
	if m != nil {
		return m.AudioInConfig
	}
	return nil
}

func (m *ConverseConfig) GetAudioOutConfig() *AudioOutConfig {
	if m != nil {
		return m.AudioOutConfig
	}
	return nil
}

func (m *ConverseConfig) GetConverseState() *ConverseState {
	if m != nil {
		return m.ConverseState
	}
	return nil
}

// Specifies how to process the `audio_in` data that will be provided in
// subsequent requests. For recommended settings, see the Google Assistant SDK
// [best practices](https://developers.google.com/assistant/sdk/develop/grpc/best-practices/audio).
type AudioInConfig struct {
	// *Required* Encoding of audio data sent in all `audio_in` messages.
	Encoding AudioInConfig_Encoding `protobuf:"varint,1,opt,name=encoding,proto3,enum=google.assistant.embedded.v1alpha1.AudioInConfig_Encoding" json:"encoding,omitempty"`
	// *Required* Sample rate (in Hertz) of the audio data sent in all `audio_in`
	// messages. Valid values are from 16000-24000, but 16000 is optimal.
	// For best results, set the sampling rate of the audio source to 16000 Hz.
	// If that's not possible, use the native sample rate of the audio source
	// (instead of re-sampling).
	SampleRateHertz int32 `protobuf:"varint,2,opt,name=sample_rate_hertz,json=sampleRateHertz,proto3" json:"sample_rate_hertz,omitempty"`
}

func (m *AudioInConfig) Reset()                    { *m = AudioInConfig{} }
func (m *AudioInConfig) String() string            { return proto.CompactTextString(m) }
func (*AudioInConfig) ProtoMessage()               {}
func (*AudioInConfig) Descriptor() ([]byte, []int) { return fileDescriptorEmbeddedAssistant, []int{1} }

func (m *AudioInConfig) GetEncoding() AudioInConfig_Encoding {
	if m != nil {
		return m.Encoding
	}
	return AudioInConfig_ENCODING_UNSPECIFIED
}

func (m *AudioInConfig) GetSampleRateHertz() int32 {
	if m != nil {
		return m.SampleRateHertz
	}
	return 0
}

// Specifies the desired format for the server to use when it returns
// `audio_out` messages.
type AudioOutConfig struct {
	// *Required* The encoding of audio data to be returned in all `audio_out`
	// messages.
	Encoding AudioOutConfig_Encoding `protobuf:"varint,1,opt,name=encoding,proto3,enum=google.assistant.embedded.v1alpha1.AudioOutConfig_Encoding" json:"encoding,omitempty"`
	// *Required* The sample rate in Hertz of the audio data returned in
	// `audio_out` messages. Valid values are: 16000-24000.
	SampleRateHertz int32 `protobuf:"varint,2,opt,name=sample_rate_hertz,json=sampleRateHertz,proto3" json:"sample_rate_hertz,omitempty"`
	// *Required* Current volume setting of the device's audio output.
	// Valid values are 1 to 100 (corresponding to 1% to 100%).
	VolumePercentage int32 `protobuf:"varint,3,opt,name=volume_percentage,json=volumePercentage,proto3" json:"volume_percentage,omitempty"`
}

func (m *AudioOutConfig) Reset()                    { *m = AudioOutConfig{} }
func (m *AudioOutConfig) String() string            { return proto.CompactTextString(m) }
func (*AudioOutConfig) ProtoMessage()               {}
func (*AudioOutConfig) Descriptor() ([]byte, []int) { return fileDescriptorEmbeddedAssistant, []int{2} }

func (m *AudioOutConfig) GetEncoding() AudioOutConfig_Encoding {
	if m != nil {
		return m.Encoding
	}
	return AudioOutConfig_ENCODING_UNSPECIFIED
}

func (m *AudioOutConfig) GetSampleRateHertz() int32 {
	if m != nil {
		return m.SampleRateHertz
	}
	return 0
}

func (m *AudioOutConfig) GetVolumePercentage() int32 {
	if m != nil {
		return m.VolumePercentage
	}
	return 0
}

// Provides information about the current dialog state.
type ConverseState struct {
	// *Required* The `conversation_state` value returned in the prior
	// `ConverseResponse`. Omit (do not set the field) if there was no prior
	// `ConverseResponse`. If there was a prior `ConverseResponse`, do not omit
	// this field; doing so will end that conversation (and this new request will
	// start a new conversation).
	ConversationState []byte `protobuf:"bytes,1,opt,name=conversation_state,json=conversationState,proto3" json:"conversation_state,omitempty"`
}

func (m *ConverseState) Reset()                    { *m = ConverseState{} }
func (m *ConverseState) String() string            { return proto.CompactTextString(m) }
func (*ConverseState) ProtoMessage()               {}
func (*ConverseState) Descriptor() ([]byte, []int) { return fileDescriptorEmbeddedAssistant, []int{3} }

func (m *ConverseState) GetConversationState() []byte {
	if m != nil {
		return m.ConversationState
	}
	return nil
}

// The audio containing the assistant's response to the query. Sequential chunks
// of audio data are received in sequential `ConverseResponse` messages.
type AudioOut struct {
	// *Output-only* The audio data containing the assistant's response to the
	// query. Sequential chunks of audio data are received in sequential
	// `ConverseResponse` messages.
	AudioData []byte `protobuf:"bytes,1,opt,name=audio_data,json=audioData,proto3" json:"audio_data,omitempty"`
}

func (m *AudioOut) Reset()                    { *m = AudioOut{} }
func (m *AudioOut) String() string            { return proto.CompactTextString(m) }
func (*AudioOut) ProtoMessage()               {}
func (*AudioOut) Descriptor() ([]byte, []int) { return fileDescriptorEmbeddedAssistant, []int{4} }

func (m *AudioOut) GetAudioData() []byte {
	if m != nil {
		return m.AudioData
	}
	return nil
}

// The semantic result for the user's spoken query.
type ConverseResult struct {
	// *Output-only* The recognized transcript of what the user said.
	SpokenRequestText string `protobuf:"bytes,1,opt,name=spoken_request_text,json=spokenRequestText,proto3" json:"spoken_request_text,omitempty"`
	// *Output-only* The text of the assistant's spoken response. This is only
	// returned for an IFTTT action.
	SpokenResponseText string `protobuf:"bytes,2,opt,name=spoken_response_text,json=spokenResponseText,proto3" json:"spoken_response_text,omitempty"`
	// *Output-only* State information for subsequent `ConverseRequest`. This
	// value should be saved in the client and returned in the
	// `conversation_state` with the next `ConverseRequest`. (The client does not
	// need to interpret or otherwise use this value.) There is no need to save
	// this information across device restarts.
	ConversationState []byte `protobuf:"bytes,3,opt,name=conversation_state,json=conversationState,proto3" json:"conversation_state,omitempty"`
	// *Output-only* Specifies the mode of the microphone after this `Converse`
	// RPC is processed.
	MicrophoneMode ConverseResult_MicrophoneMode `protobuf:"varint,4,opt,name=microphone_mode,json=microphoneMode,proto3,enum=google.assistant.embedded.v1alpha1.ConverseResult_MicrophoneMode" json:"microphone_mode,omitempty"`
	// *Output-only* Updated volume level. The value will be 0 or omitted
	// (indicating no change) unless a voice command such as "Increase the volume"
	// or "Set volume level 4" was recognized, in which case the value will be
	// between 1 and 100 (corresponding to the new volume level of 1% to 100%).
	// Typically, a client should use this volume level when playing the
	// `audio_out` data, and retain this value as the current volume level and
	// supply it in the `AudioOutConfig` of the next `ConverseRequest`. (Some
	// clients may also implement other ways to allow the current volume level to
	// be changed, for example, by providing a knob that the user can turn.)
	VolumePercentage int32 `protobuf:"varint,5,opt,name=volume_percentage,json=volumePercentage,proto3" json:"volume_percentage,omitempty"`
}

func (m *ConverseResult) Reset()                    { *m = ConverseResult{} }
func (m *ConverseResult) String() string            { return proto.CompactTextString(m) }
func (*ConverseResult) ProtoMessage()               {}
func (*ConverseResult) Descriptor() ([]byte, []int) { return fileDescriptorEmbeddedAssistant, []int{5} }

func (m *ConverseResult) GetSpokenRequestText() string {
	if m != nil {
		return m.SpokenRequestText
	}
	return ""
}

func (m *ConverseResult) GetSpokenResponseText() string {
	if m != nil {
		return m.SpokenResponseText
	}
	return ""
}

func (m *ConverseResult) GetConversationState() []byte {
	if m != nil {
		return m.ConversationState
	}
	return nil
}

func (m *ConverseResult) GetMicrophoneMode() ConverseResult_MicrophoneMode {
	if m != nil {
		return m.MicrophoneMode
	}
	return ConverseResult_MICROPHONE_MODE_UNSPECIFIED
}

func (m *ConverseResult) GetVolumePercentage() int32 {
	if m != nil {
		return m.VolumePercentage
	}
	return 0
}

// The top-level message sent by the client. Clients must send at least two, and
// typically numerous `ConverseRequest` messages. The first message must
// contain a `config` message and must not contain `audio_in` data. All
// subsequent messages must contain `audio_in` data and must not contain a
// `config` message.
type ConverseRequest struct {
	// Exactly one of these fields must be specified in each `ConverseRequest`.
	//
	// Types that are valid to be assigned to ConverseRequest:
	//	*ConverseRequest_Config
	//	*ConverseRequest_AudioIn
	ConverseRequest isConverseRequest_ConverseRequest `protobuf_oneof:"converse_request"`
}

func (m *ConverseRequest) Reset()                    { *m = ConverseRequest{} }
func (m *ConverseRequest) String() string            { return proto.CompactTextString(m) }
func (*ConverseRequest) ProtoMessage()               {}
func (*ConverseRequest) Descriptor() ([]byte, []int) { return fileDescriptorEmbeddedAssistant, []int{6} }

type isConverseRequest_ConverseRequest interface {
	isConverseRequest_ConverseRequest()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConverseRequest_Config struct {
	Config *ConverseConfig `protobuf:"bytes,1,opt,name=config,oneof"`
}
type ConverseRequest_AudioIn struct {
	AudioIn []byte `protobuf:"bytes,2,opt,name=audio_in,json=audioIn,proto3,oneof"`
}

func (*ConverseRequest_Config) isConverseRequest_ConverseRequest()  {}
func (*ConverseRequest_AudioIn) isConverseRequest_ConverseRequest() {}

func (m *ConverseRequest) GetConverseRequest() isConverseRequest_ConverseRequest {
	if m != nil {
		return m.ConverseRequest
	}
	return nil
}

func (m *ConverseRequest) GetConfig() *ConverseConfig {
	if x, ok := m.GetConverseRequest().(*ConverseRequest_Config); ok {
		return x.Config
	}
	return nil
}

func (m *ConverseRequest) GetAudioIn() []byte {
	if x, ok := m.GetConverseRequest().(*ConverseRequest_AudioIn); ok {
		return x.AudioIn
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ConverseRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ConverseRequest_OneofMarshaler, _ConverseRequest_OneofUnmarshaler, _ConverseRequest_OneofSizer, []interface{}{
		(*ConverseRequest_Config)(nil),
		(*ConverseRequest_AudioIn)(nil),
	}
}

func _ConverseRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ConverseRequest)
	// converse_request
	switch x := m.ConverseRequest.(type) {
	case *ConverseRequest_Config:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Config); err != nil {
			return err
		}
	case *ConverseRequest_AudioIn:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.AudioIn)
	case nil:
	default:
		return fmt.Errorf("ConverseRequest.ConverseRequest has unexpected type %T", x)
	}
	return nil
}

func _ConverseRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ConverseRequest)
	switch tag {
	case 1: // converse_request.config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConverseConfig)
		err := b.DecodeMessage(msg)
		m.ConverseRequest = &ConverseRequest_Config{msg}
		return true, err
	case 2: // converse_request.audio_in
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ConverseRequest = &ConverseRequest_AudioIn{x}
		return true, err
	default:
		return false, nil
	}
}

func _ConverseRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ConverseRequest)
	// converse_request
	switch x := m.ConverseRequest.(type) {
	case *ConverseRequest_Config:
		s := proto.Size(x.Config)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConverseRequest_AudioIn:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.AudioIn)))
		n += len(x.AudioIn)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The top-level message received by the client. A series of one or more
// `ConverseResponse` messages are streamed back to the client.
type ConverseResponse struct {
	// Exactly one of these fields will be populated in each `ConverseResponse`.
	//
	// Types that are valid to be assigned to ConverseResponse:
	//	*ConverseResponse_Error
	//	*ConverseResponse_EventType_
	//	*ConverseResponse_AudioOut
	//	*ConverseResponse_Result
	ConverseResponse isConverseResponse_ConverseResponse `protobuf_oneof:"converse_response"`
}

func (m *ConverseResponse) Reset()         { *m = ConverseResponse{} }
func (m *ConverseResponse) String() string { return proto.CompactTextString(m) }
func (*ConverseResponse) ProtoMessage()    {}
func (*ConverseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorEmbeddedAssistant, []int{7}
}

type isConverseResponse_ConverseResponse interface {
	isConverseResponse_ConverseResponse()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConverseResponse_Error struct {
	Error *google_rpc.Status `protobuf:"bytes,1,opt,name=error,oneof"`
}
type ConverseResponse_EventType_ struct {
	EventType ConverseResponse_EventType `protobuf:"varint,2,opt,name=event_type,json=eventType,proto3,enum=google.assistant.embedded.v1alpha1.ConverseResponse_EventType,oneof"`
}
type ConverseResponse_AudioOut struct {
	AudioOut *AudioOut `protobuf:"bytes,3,opt,name=audio_out,json=audioOut,oneof"`
}
type ConverseResponse_Result struct {
	Result *ConverseResult `protobuf:"bytes,5,opt,name=result,oneof"`
}

func (*ConverseResponse_Error) isConverseResponse_ConverseResponse()      {}
func (*ConverseResponse_EventType_) isConverseResponse_ConverseResponse() {}
func (*ConverseResponse_AudioOut) isConverseResponse_ConverseResponse()   {}
func (*ConverseResponse_Result) isConverseResponse_ConverseResponse()     {}

func (m *ConverseResponse) GetConverseResponse() isConverseResponse_ConverseResponse {
	if m != nil {
		return m.ConverseResponse
	}
	return nil
}

func (m *ConverseResponse) GetError() *google_rpc.Status {
	if x, ok := m.GetConverseResponse().(*ConverseResponse_Error); ok {
		return x.Error
	}
	return nil
}

func (m *ConverseResponse) GetEventType() ConverseResponse_EventType {
	if x, ok := m.GetConverseResponse().(*ConverseResponse_EventType_); ok {
		return x.EventType
	}
	return ConverseResponse_EVENT_TYPE_UNSPECIFIED
}

func (m *ConverseResponse) GetAudioOut() *AudioOut {
	if x, ok := m.GetConverseResponse().(*ConverseResponse_AudioOut); ok {
		return x.AudioOut
	}
	return nil
}

func (m *ConverseResponse) GetResult() *ConverseResult {
	if x, ok := m.GetConverseResponse().(*ConverseResponse_Result); ok {
		return x.Result
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ConverseResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ConverseResponse_OneofMarshaler, _ConverseResponse_OneofUnmarshaler, _ConverseResponse_OneofSizer, []interface{}{
		(*ConverseResponse_Error)(nil),
		(*ConverseResponse_EventType_)(nil),
		(*ConverseResponse_AudioOut)(nil),
		(*ConverseResponse_Result)(nil),
	}
}

func _ConverseResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ConverseResponse)
	// converse_response
	switch x := m.ConverseResponse.(type) {
	case *ConverseResponse_Error:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *ConverseResponse_EventType_:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.EventType))
	case *ConverseResponse_AudioOut:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AudioOut); err != nil {
			return err
		}
	case *ConverseResponse_Result:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ConverseResponse.ConverseResponse has unexpected type %T", x)
	}
	return nil
}

func _ConverseResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ConverseResponse)
	switch tag {
	case 1: // converse_response.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_rpc.Status)
		err := b.DecodeMessage(msg)
		m.ConverseResponse = &ConverseResponse_Error{msg}
		return true, err
	case 2: // converse_response.event_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConverseResponse = &ConverseResponse_EventType_{ConverseResponse_EventType(x)}
		return true, err
	case 3: // converse_response.audio_out
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AudioOut)
		err := b.DecodeMessage(msg)
		m.ConverseResponse = &ConverseResponse_AudioOut{msg}
		return true, err
	case 5: // converse_response.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConverseResult)
		err := b.DecodeMessage(msg)
		m.ConverseResponse = &ConverseResponse_Result{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ConverseResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ConverseResponse)
	// converse_response
	switch x := m.ConverseResponse.(type) {
	case *ConverseResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConverseResponse_EventType_:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.EventType))
	case *ConverseResponse_AudioOut:
		s := proto.Size(x.AudioOut)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConverseResponse_Result:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*ConverseConfig)(nil), "google.assistant.embedded.v1alpha1.ConverseConfig")
	proto.RegisterType((*AudioInConfig)(nil), "google.assistant.embedded.v1alpha1.AudioInConfig")
	proto.RegisterType((*AudioOutConfig)(nil), "google.assistant.embedded.v1alpha1.AudioOutConfig")
	proto.RegisterType((*ConverseState)(nil), "google.assistant.embedded.v1alpha1.ConverseState")
	proto.RegisterType((*AudioOut)(nil), "google.assistant.embedded.v1alpha1.AudioOut")
	proto.RegisterType((*ConverseResult)(nil), "google.assistant.embedded.v1alpha1.ConverseResult")
	proto.RegisterType((*ConverseRequest)(nil), "google.assistant.embedded.v1alpha1.ConverseRequest")
	proto.RegisterType((*ConverseResponse)(nil), "google.assistant.embedded.v1alpha1.ConverseResponse")
	proto.RegisterEnum("google.assistant.embedded.v1alpha1.AudioInConfig_Encoding", AudioInConfig_Encoding_name, AudioInConfig_Encoding_value)
	proto.RegisterEnum("google.assistant.embedded.v1alpha1.AudioOutConfig_Encoding", AudioOutConfig_Encoding_name, AudioOutConfig_Encoding_value)
	proto.RegisterEnum("google.assistant.embedded.v1alpha1.ConverseResult_MicrophoneMode", ConverseResult_MicrophoneMode_name, ConverseResult_MicrophoneMode_value)
	proto.RegisterEnum("google.assistant.embedded.v1alpha1.ConverseResponse_EventType", ConverseResponse_EventType_name, ConverseResponse_EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EmbeddedAssistant service

type EmbeddedAssistantClient interface {
	// Initiates or continues a conversation with the embedded assistant service.
	// Each call performs one round-trip, sending an audio request to the service
	// and receiving the audio response. Uses bidirectional streaming to receive
	// results, such as the `END_OF_UTTERANCE` event, while sending audio.
	//
	// A conversation is one or more gRPC connections, each consisting of several
	// streamed requests and responses.
	// For example, the user says *Add to my shopping list* and the assistant
	// responds *What do you want to add?*. The sequence of streamed requests and
	// responses in the first gRPC message could be:
	//
	// *   ConverseRequest.config
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseResponse.event_type.END_OF_UTTERANCE
	// *   ConverseResponse.result.microphone_mode.DIALOG_FOLLOW_ON
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	//
	// The user then says *bagels* and the assistant responds
	// *OK, I've added bagels to your shopping list*. This is sent as another gRPC
	// connection call to the `Converse` method, again with streamed requests and
	// responses, such as:
	//
	// *   ConverseRequest.config
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseResponse.event_type.END_OF_UTTERANCE
	// *   ConverseResponse.result.microphone_mode.CLOSE_MICROPHONE
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	//
	// Although the precise order of responses is not guaranteed, sequential
	// ConverseResponse.audio_out messages will always contain sequential portions
	// of audio.
	Converse(ctx context.Context, opts ...grpc.CallOption) (EmbeddedAssistant_ConverseClient, error)
}

type embeddedAssistantClient struct {
	cc *grpc.ClientConn
}

func NewEmbeddedAssistantClient(cc *grpc.ClientConn) EmbeddedAssistantClient {
	return &embeddedAssistantClient{cc}
}

func (c *embeddedAssistantClient) Converse(ctx context.Context, opts ...grpc.CallOption) (EmbeddedAssistant_ConverseClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EmbeddedAssistant_serviceDesc.Streams[0], c.cc, "/google.assistant.embedded.v1alpha1.EmbeddedAssistant/Converse", opts...)
	if err != nil {
		return nil, err
	}
	x := &embeddedAssistantConverseClient{stream}
	return x, nil
}

type EmbeddedAssistant_ConverseClient interface {
	Send(*ConverseRequest) error
	Recv() (*ConverseResponse, error)
	grpc.ClientStream
}

type embeddedAssistantConverseClient struct {
	grpc.ClientStream
}

func (x *embeddedAssistantConverseClient) Send(m *ConverseRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *embeddedAssistantConverseClient) Recv() (*ConverseResponse, error) {
	m := new(ConverseResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EmbeddedAssistant service

type EmbeddedAssistantServer interface {
	// Initiates or continues a conversation with the embedded assistant service.
	// Each call performs one round-trip, sending an audio request to the service
	// and receiving the audio response. Uses bidirectional streaming to receive
	// results, such as the `END_OF_UTTERANCE` event, while sending audio.
	//
	// A conversation is one or more gRPC connections, each consisting of several
	// streamed requests and responses.
	// For example, the user says *Add to my shopping list* and the assistant
	// responds *What do you want to add?*. The sequence of streamed requests and
	// responses in the first gRPC message could be:
	//
	// *   ConverseRequest.config
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseResponse.event_type.END_OF_UTTERANCE
	// *   ConverseResponse.result.microphone_mode.DIALOG_FOLLOW_ON
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	//
	// The user then says *bagels* and the assistant responds
	// *OK, I've added bagels to your shopping list*. This is sent as another gRPC
	// connection call to the `Converse` method, again with streamed requests and
	// responses, such as:
	//
	// *   ConverseRequest.config
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseRequest.audio_in
	// *   ConverseResponse.event_type.END_OF_UTTERANCE
	// *   ConverseResponse.result.microphone_mode.CLOSE_MICROPHONE
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	// *   ConverseResponse.audio_out
	//
	// Although the precise order of responses is not guaranteed, sequential
	// ConverseResponse.audio_out messages will always contain sequential portions
	// of audio.
	Converse(EmbeddedAssistant_ConverseServer) error
}

func RegisterEmbeddedAssistantServer(s *grpc.Server, srv EmbeddedAssistantServer) {
	s.RegisterService(&_EmbeddedAssistant_serviceDesc, srv)
}

func _EmbeddedAssistant_Converse_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EmbeddedAssistantServer).Converse(&embeddedAssistantConverseServer{stream})
}

type EmbeddedAssistant_ConverseServer interface {
	Send(*ConverseResponse) error
	Recv() (*ConverseRequest, error)
	grpc.ServerStream
}

type embeddedAssistantConverseServer struct {
	grpc.ServerStream
}

func (x *embeddedAssistantConverseServer) Send(m *ConverseResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *embeddedAssistantConverseServer) Recv() (*ConverseRequest, error) {
	m := new(ConverseRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EmbeddedAssistant_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.assistant.embedded.v1alpha1.EmbeddedAssistant",
	HandlerType: (*EmbeddedAssistantServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Converse",
			Handler:       _EmbeddedAssistant_Converse_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "google/assistant/embedded/v1alpha1/embedded_assistant.proto",
}

func (m *ConverseConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConverseConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AudioInConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.AudioInConfig.Size()))
		n1, err := m.AudioInConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.AudioOutConfig != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.AudioOutConfig.Size()))
		n2, err := m.AudioOutConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ConverseState != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.ConverseState.Size()))
		n3, err := m.ConverseState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *AudioInConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioInConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Encoding != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.Encoding))
	}
	if m.SampleRateHertz != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.SampleRateHertz))
	}
	return i, nil
}

func (m *AudioOutConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioOutConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Encoding != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.Encoding))
	}
	if m.SampleRateHertz != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.SampleRateHertz))
	}
	if m.VolumePercentage != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.VolumePercentage))
	}
	return i, nil
}

func (m *ConverseState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConverseState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConversationState) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(len(m.ConversationState)))
		i += copy(dAtA[i:], m.ConversationState)
	}
	return i, nil
}

func (m *AudioOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioOut) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AudioData) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(len(m.AudioData)))
		i += copy(dAtA[i:], m.AudioData)
	}
	return i, nil
}

func (m *ConverseResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConverseResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SpokenRequestText) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(len(m.SpokenRequestText)))
		i += copy(dAtA[i:], m.SpokenRequestText)
	}
	if len(m.SpokenResponseText) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(len(m.SpokenResponseText)))
		i += copy(dAtA[i:], m.SpokenResponseText)
	}
	if len(m.ConversationState) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(len(m.ConversationState)))
		i += copy(dAtA[i:], m.ConversationState)
	}
	if m.MicrophoneMode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.MicrophoneMode))
	}
	if m.VolumePercentage != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.VolumePercentage))
	}
	return i, nil
}

func (m *ConverseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConverseRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConverseRequest != nil {
		nn4, err := m.ConverseRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	return i, nil
}

func (m *ConverseRequest_Config) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Config != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.Config.Size()))
		n5, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *ConverseRequest_AudioIn) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AudioIn != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(len(m.AudioIn)))
		i += copy(dAtA[i:], m.AudioIn)
	}
	return i, nil
}
func (m *ConverseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConverseResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConverseResponse != nil {
		nn6, err := m.ConverseResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	return i, nil
}

func (m *ConverseResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.Error.Size()))
		n7, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *ConverseResponse_EventType_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.EventType))
	return i, nil
}
func (m *ConverseResponse_AudioOut) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AudioOut != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.AudioOut.Size()))
		n8, err := m.AudioOut.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ConverseResponse_Result) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Result != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEmbeddedAssistant(dAtA, i, uint64(m.Result.Size()))
		n9, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func encodeFixed64EmbeddedAssistant(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32EmbeddedAssistant(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEmbeddedAssistant(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ConverseConfig) Size() (n int) {
	var l int
	_ = l
	if m.AudioInConfig != nil {
		l = m.AudioInConfig.Size()
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	if m.AudioOutConfig != nil {
		l = m.AudioOutConfig.Size()
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	if m.ConverseState != nil {
		l = m.ConverseState.Size()
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	return n
}

func (m *AudioInConfig) Size() (n int) {
	var l int
	_ = l
	if m.Encoding != 0 {
		n += 1 + sovEmbeddedAssistant(uint64(m.Encoding))
	}
	if m.SampleRateHertz != 0 {
		n += 1 + sovEmbeddedAssistant(uint64(m.SampleRateHertz))
	}
	return n
}

func (m *AudioOutConfig) Size() (n int) {
	var l int
	_ = l
	if m.Encoding != 0 {
		n += 1 + sovEmbeddedAssistant(uint64(m.Encoding))
	}
	if m.SampleRateHertz != 0 {
		n += 1 + sovEmbeddedAssistant(uint64(m.SampleRateHertz))
	}
	if m.VolumePercentage != 0 {
		n += 1 + sovEmbeddedAssistant(uint64(m.VolumePercentage))
	}
	return n
}

func (m *ConverseState) Size() (n int) {
	var l int
	_ = l
	l = len(m.ConversationState)
	if l > 0 {
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	return n
}

func (m *AudioOut) Size() (n int) {
	var l int
	_ = l
	l = len(m.AudioData)
	if l > 0 {
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	return n
}

func (m *ConverseResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.SpokenRequestText)
	if l > 0 {
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	l = len(m.SpokenResponseText)
	if l > 0 {
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	l = len(m.ConversationState)
	if l > 0 {
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	if m.MicrophoneMode != 0 {
		n += 1 + sovEmbeddedAssistant(uint64(m.MicrophoneMode))
	}
	if m.VolumePercentage != 0 {
		n += 1 + sovEmbeddedAssistant(uint64(m.VolumePercentage))
	}
	return n
}

func (m *ConverseRequest) Size() (n int) {
	var l int
	_ = l
	if m.ConverseRequest != nil {
		n += m.ConverseRequest.Size()
	}
	return n
}

func (m *ConverseRequest_Config) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	return n
}
func (m *ConverseRequest_AudioIn) Size() (n int) {
	var l int
	_ = l
	if m.AudioIn != nil {
		l = len(m.AudioIn)
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	return n
}
func (m *ConverseResponse) Size() (n int) {
	var l int
	_ = l
	if m.ConverseResponse != nil {
		n += m.ConverseResponse.Size()
	}
	return n
}

func (m *ConverseResponse_Error) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	return n
}
func (m *ConverseResponse_EventType_) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovEmbeddedAssistant(uint64(m.EventType))
	return n
}
func (m *ConverseResponse_AudioOut) Size() (n int) {
	var l int
	_ = l
	if m.AudioOut != nil {
		l = m.AudioOut.Size()
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	return n
}
func (m *ConverseResponse_Result) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovEmbeddedAssistant(uint64(l))
	}
	return n
}

func sovEmbeddedAssistant(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEmbeddedAssistant(x uint64) (n int) {
	return sovEmbeddedAssistant(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConverseConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEmbeddedAssistant
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConverseConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConverseConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioInConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AudioInConfig == nil {
				m.AudioInConfig = &AudioInConfig{}
			}
			if err := m.AudioInConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioOutConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AudioOutConfig == nil {
				m.AudioOutConfig = &AudioOutConfig{}
			}
			if err := m.AudioOutConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConverseState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConverseState == nil {
				m.ConverseState = &ConverseState{}
			}
			if err := m.ConverseState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEmbeddedAssistant(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioInConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEmbeddedAssistant
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioInConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioInConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= (AudioInConfig_Encoding(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleRateHertz", wireType)
			}
			m.SampleRateHertz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleRateHertz |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEmbeddedAssistant(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioOutConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEmbeddedAssistant
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioOutConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioOutConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= (AudioOutConfig_Encoding(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleRateHertz", wireType)
			}
			m.SampleRateHertz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleRateHertz |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumePercentage", wireType)
			}
			m.VolumePercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumePercentage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEmbeddedAssistant(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConverseState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEmbeddedAssistant
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConverseState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConverseState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationState", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConversationState = append(m.ConversationState[:0], dAtA[iNdEx:postIndex]...)
			if m.ConversationState == nil {
				m.ConversationState = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEmbeddedAssistant(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEmbeddedAssistant
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AudioData = append(m.AudioData[:0], dAtA[iNdEx:postIndex]...)
			if m.AudioData == nil {
				m.AudioData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEmbeddedAssistant(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConverseResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEmbeddedAssistant
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConverseResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConverseResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpokenRequestText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpokenRequestText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpokenResponseText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpokenResponseText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversationState", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConversationState = append(m.ConversationState[:0], dAtA[iNdEx:postIndex]...)
			if m.ConversationState == nil {
				m.ConversationState = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MicrophoneMode", wireType)
			}
			m.MicrophoneMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MicrophoneMode |= (ConverseResult_MicrophoneMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumePercentage", wireType)
			}
			m.VolumePercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumePercentage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEmbeddedAssistant(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConverseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEmbeddedAssistant
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConverseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConverseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConverseConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConverseRequest = &ConverseRequest_Config{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioIn", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.ConverseRequest = &ConverseRequest_AudioIn{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEmbeddedAssistant(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConverseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEmbeddedAssistant
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConverseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConverseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &google_rpc.Status{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConverseResponse = &ConverseResponse_Error{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			var v ConverseResponse_EventType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ConverseResponse_EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConverseResponse = &ConverseResponse_EventType_{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AudioOut{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConverseResponse = &ConverseResponse_AudioOut{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConverseResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConverseResponse = &ConverseResponse_Result{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEmbeddedAssistant(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEmbeddedAssistant
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEmbeddedAssistant(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEmbeddedAssistant
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEmbeddedAssistant
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEmbeddedAssistant
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEmbeddedAssistant
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEmbeddedAssistant(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEmbeddedAssistant = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEmbeddedAssistant   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("google/assistant/embedded/v1alpha1/embedded_assistant.proto", fileDescriptorEmbeddedAssistant)
}

var fileDescriptorEmbeddedAssistant = []byte{
	// 909 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xd1, 0x72, 0xdb, 0x44,
	0x14, 0xb5, 0xec, 0xa6, 0xb5, 0x6f, 0x13, 0x59, 0xde, 0x66, 0x20, 0x93, 0x42, 0x60, 0xf4, 0xc0,
	0x94, 0x02, 0x72, 0xe3, 0x30, 0x3c, 0x10, 0xe8, 0x8c, 0x63, 0x2b, 0xb1, 0xc1, 0x96, 0x3c, 0x6b,
	0xa7, 0xa5, 0x0c, 0xcc, 0xce, 0x56, 0x5e, 0x1c, 0x81, 0xad, 0x15, 0xd2, 0x3a, 0xd3, 0xf0, 0x11,
	0x1d, 0x86, 0x37, 0x9e, 0xf9, 0x19, 0x1e, 0xe1, 0x0f, 0x98, 0x7c, 0x09, 0xa3, 0x5d, 0x49, 0xb6,
	0x21, 0x85, 0x38, 0x7d, 0xdc, 0x7b, 0xf7, 0x1c, 0xdd, 0x7b, 0xee, 0xd9, 0x3b, 0x82, 0xc3, 0x09,
	0xe7, 0x93, 0x29, 0xab, 0xd3, 0x38, 0xf6, 0x63, 0x41, 0x03, 0x51, 0x67, 0xb3, 0xe7, 0x6c, 0x3c,
	0x66, 0xe3, 0xfa, 0xf9, 0x3e, 0x9d, 0x86, 0x67, 0x74, 0x3f, 0x8f, 0x90, 0xfc, 0x92, 0x15, 0x46,
	0x5c, 0x70, 0x64, 0x2a, 0xb0, 0xb5, 0x88, 0x67, 0x57, 0xad, 0x0c, 0xbc, 0xfb, 0x56, 0xf6, 0x81,
	0xd0, 0xaf, 0xd3, 0x20, 0xe0, 0x82, 0x0a, 0x9f, 0x07, 0xb1, 0x62, 0xd8, 0x7d, 0x33, 0xcd, 0x46,
	0xa1, 0x57, 0x8f, 0x05, 0x15, 0xf3, 0x34, 0x61, 0xfe, 0x56, 0x04, 0xbd, 0xc5, 0x83, 0x73, 0x16,
	0xc5, 0xac, 0xc5, 0x83, 0xef, 0xfc, 0x09, 0x7a, 0x06, 0x55, 0x3a, 0x1f, 0xfb, 0x9c, 0xf8, 0x01,
	0xf1, 0x64, 0x68, 0x47, 0x7b, 0x57, 0x7b, 0x70, 0xb7, 0xb1, 0x6f, 0xfd, 0x7f, 0x1d, 0x56, 0x33,
	0x81, 0x76, 0x03, 0xc5, 0x85, 0xb7, 0xe8, 0xf2, 0x11, 0x7d, 0x03, 0x86, 0xa2, 0xe6, 0x73, 0x91,
	0x71, 0x17, 0x25, 0x77, 0xe3, 0xda, 0xdc, 0xee, 0x5c, 0xa4, 0xe4, 0x3a, 0x5d, 0x39, 0xa3, 0xaf,
	0x40, 0xf7, 0xd2, 0x56, 0x48, 0xd2, 0x24, 0xdb, 0x29, 0x5d, 0xbf, 0xee, 0x4c, 0x84, 0x61, 0x02,
	0xc4, 0x5b, 0xde, 0xf2, 0xd1, 0xfc, 0x53, 0x83, 0xad, 0x95, 0xc6, 0xd0, 0x13, 0x28, 0xb3, 0xc0,
	0xe3, 0x63, 0x3f, 0x50, 0xea, 0xe8, 0x8d, 0x4f, 0xd7, 0x56, 0xc7, 0xb2, 0x53, 0x06, 0x9c, 0x73,
	0xa1, 0x87, 0x50, 0x8b, 0xe9, 0x2c, 0x9c, 0x32, 0x12, 0x51, 0xc1, 0xc8, 0x19, 0x8b, 0xc4, 0x4f,
	0x52, 0xa2, 0x0d, 0x5c, 0x55, 0x09, 0x4c, 0x05, 0xeb, 0x24, 0x61, 0xf3, 0x33, 0x28, 0x67, 0x0c,
	0x68, 0x07, 0xb6, 0x6d, 0xa7, 0xe5, 0xb6, 0xbb, 0xce, 0x09, 0x39, 0x75, 0x86, 0x03, 0xbb, 0xd5,
	0x3d, 0xee, 0xda, 0x6d, 0xa3, 0x80, 0x36, 0xa1, 0xdc, 0xeb, 0x3a, 0x76, 0x13, 0xef, 0x7f, 0x62,
	0x68, 0xa8, 0x0c, 0xb7, 0x8e, 0x7b, 0xcd, 0x96, 0x51, 0x34, 0x7f, 0x2e, 0x82, 0xbe, 0x2a, 0x28,
	0x7a, 0xfa, 0xaf, 0xa6, 0x0e, 0xd7, 0x1f, 0xcb, 0x6b, 0x76, 0x85, 0x3e, 0x80, 0xda, 0x39, 0x9f,
	0xce, 0x67, 0x8c, 0x84, 0x2c, 0xf2, 0x58, 0x20, 0xe8, 0x44, 0x0d, 0x72, 0x03, 0x1b, 0x2a, 0x31,
	0xc8, 0xe3, 0x66, 0xef, 0x06, 0x12, 0xdc, 0x81, 0x52, 0x7f, 0x70, 0x60, 0x14, 0x51, 0x15, 0xee,
	0xba, 0x83, 0xd3, 0x21, 0xe9, 0x3a, 0xc4, 0x3d, 0x39, 0x31, 0x4a, 0xe6, 0x63, 0xd8, 0x5a, 0xb1,
	0x01, 0xfa, 0x08, 0x50, 0x6a, 0x04, 0xf9, 0x9a, 0x52, 0x57, 0x25, 0xd2, 0x6c, 0xe2, 0xda, 0x72,
	0x46, 0xd9, 0xe4, 0x7d, 0x28, 0x67, 0x5a, 0xa0, 0xb7, 0x01, 0x94, 0xd5, 0xc7, 0x54, 0xd0, 0x14,
	0x52, 0x91, 0x91, 0x36, 0x15, 0xd4, 0xfc, 0xb5, 0xb4, 0x78, 0x77, 0x98, 0xc5, 0xf3, 0xa9, 0x40,
	0x16, 0xdc, 0x8b, 0x43, 0xfe, 0x03, 0x0b, 0x48, 0xc4, 0x7e, 0x9c, 0xb3, 0x58, 0x10, 0xc1, 0x5e,
	0x08, 0x09, 0xad, 0xe0, 0x9a, 0x4a, 0x61, 0x95, 0x19, 0xb1, 0x17, 0x02, 0x3d, 0x82, 0xed, 0xfc,
	0x7e, 0x1c, 0xf2, 0x20, 0x66, 0x0a, 0x50, 0x94, 0x00, 0x94, 0x01, 0x54, 0x4a, 0x22, 0xae, 0x6e,
	0xa7, 0xf4, 0x8a, 0x76, 0xd0, 0xf7, 0x50, 0x9d, 0xf9, 0x5e, 0xc4, 0xc3, 0x33, 0x1e, 0x30, 0x32,
	0xe3, 0x63, 0xb6, 0x73, 0x4b, 0xba, 0xa2, 0xb9, 0xce, 0x83, 0x52, 0xdd, 0x59, 0xfd, 0x9c, 0xa9,
	0xcf, 0xc7, 0x0c, 0xeb, 0xb3, 0x95, 0xf3, 0xd5, 0x53, 0xdf, 0x78, 0xc5, 0xd4, 0xbf, 0x05, 0x7d,
	0x95, 0x0e, 0xbd, 0x03, 0xf7, 0xfb, 0xdd, 0x16, 0x76, 0x07, 0x1d, 0xd7, 0xb1, 0x49, 0xdf, 0x6d,
	0xdb, 0xff, 0xb0, 0xc0, 0x36, 0x18, 0xad, 0x9e, 0x3b, 0xb4, 0xc9, 0xe2, 0x9a, 0xa1, 0x25, 0xd1,
	0x76, 0xb7, 0xd9, 0x73, 0x4f, 0xc8, 0xb1, 0xdb, 0xeb, 0xb9, 0x4f, 0x89, 0xeb, 0x24, 0x2f, 0x43,
	0x83, 0xea, 0xa2, 0x7a, 0x29, 0x38, 0xea, 0xc1, 0xed, 0x95, 0x5d, 0xd8, 0x58, 0x47, 0x02, 0xf5,
	0x30, 0x3a, 0x05, 0x9c, 0x72, 0xa0, 0xfb, 0x50, 0xce, 0x56, 0xac, 0x1c, 0xd7, 0x66, 0xa7, 0x80,
	0xef, 0xa4, 0xab, 0xf2, 0x08, 0x81, 0x91, 0xaf, 0xb1, 0xd4, 0x09, 0xe6, 0xcb, 0x12, 0x18, 0x4b,
	0x82, 0xca, 0x91, 0xa2, 0x87, 0xb0, 0xc1, 0xa2, 0x88, 0x47, 0x69, 0x49, 0x28, 0x2b, 0x29, 0x0a,
	0x3d, 0x6b, 0x28, 0x97, 0x7c, 0xa7, 0x80, 0xd5, 0x15, 0x44, 0x00, 0xd8, 0x39, 0x0b, 0x04, 0x11,
	0x17, 0x21, 0x93, 0xdf, 0xd4, 0x1b, 0x8f, 0xd7, 0x1c, 0xa3, 0xfc, 0xaa, 0x65, 0x27, 0x34, 0xa3,
	0x8b, 0x90, 0x75, 0x0a, 0xb8, 0xc2, 0xb2, 0x03, 0xfa, 0x12, 0x2a, 0xf9, 0x6a, 0x4f, 0xf7, 0xee,
	0x87, 0xeb, 0x2c, 0x8f, 0x4e, 0x01, 0x97, 0xb3, 0x7d, 0x9e, 0xa8, 0x1d, 0x49, 0xdb, 0x48, 0x0b,
	0xac, 0xa9, 0xb6, 0x32, 0x5c, 0xa2, 0xb6, 0xe2, 0x30, 0x3f, 0x87, 0x4a, 0x5e, 0x34, 0xda, 0x85,
	0x37, 0xec, 0x27, 0xb6, 0x33, 0x22, 0xa3, 0x67, 0x83, 0x2b, 0x4c, 0x62, 0x3b, 0x6d, 0xe2, 0x1e,
	0x93, 0xd3, 0xd1, 0xc8, 0xc6, 0x4d, 0xa7, 0x65, 0x1b, 0xda, 0xd1, 0x3d, 0xa8, 0x2d, 0xcd, 0x43,
	0xa9, 0xd0, 0x78, 0xa9, 0x41, 0xcd, 0x4e, 0x4b, 0x68, 0x66, 0x45, 0xa1, 0x0b, 0x28, 0x67, 0x55,
	0xa0, 0x83, 0xf5, 0x6a, 0x96, 0x73, 0xde, 0xfd, 0xf8, 0x26, 0x23, 0x79, 0xa0, 0x3d, 0xd2, 0x8e,
	0x7e, 0xd1, 0x7e, 0xbf, 0xdc, 0xd3, 0xfe, 0xb8, 0xdc, 0xd3, 0xfe, 0xba, 0xdc, 0xd3, 0xe0, 0x3d,
	0x8f, 0xcf, 0xae, 0xc1, 0x75, 0xa4, 0xe7, 0xc5, 0x0f, 0x92, 0xff, 0x81, 0x81, 0xf6, 0xf5, 0x17,
	0x29, 0x6a, 0xc2, 0xa7, 0x34, 0x98, 0x58, 0x3c, 0x9a, 0xd4, 0x27, 0x2c, 0x90, 0x7f, 0x0b, 0x75,
	0x95, 0xa2, 0xa1, 0x1f, 0xff, 0xd7, 0x8f, 0xcc, 0x61, 0x16, 0x79, 0x7e, 0x5b, 0xc2, 0x0e, 0xfe,
	0x0e, 0x00, 0x00, 0xff, 0xff, 0xd3, 0x0a, 0x54, 0xc6, 0xfe, 0x08, 0x00, 0x00,
}
