// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/devtools/clouderrorreporting/v1beta1/error_stats_service.proto

package clouderrorreporting

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf2 "github.com/gogo/protobuf/types"
import google_protobuf1 "github.com/gogo/protobuf/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Specifies how the time periods of error group counts are aligned.
type TimedCountAlignment int32

const (
	// No alignment specified.
	TimedCountAlignment_ERROR_COUNT_ALIGNMENT_UNSPECIFIED TimedCountAlignment = 0
	// The time periods shall be consecutive, have width equal to the
	// requested duration, and be aligned at the `alignment_time` provided in
	// the request.
	// The `alignment_time` does not have to be inside the query period but
	// even if it is outside, only time periods are returned which overlap
	// with the query period.
	// A rounded alignment will typically result in a
	// different size of the first or the last time period.
	TimedCountAlignment_ALIGNMENT_EQUAL_ROUNDED TimedCountAlignment = 1
	// The time periods shall be consecutive, have width equal to the
	// requested duration, and be aligned at the end of the requested time
	// period. This can result in a different size of the
	// first time period.
	TimedCountAlignment_ALIGNMENT_EQUAL_AT_END TimedCountAlignment = 2
)

var TimedCountAlignment_name = map[int32]string{
	0: "ERROR_COUNT_ALIGNMENT_UNSPECIFIED",
	1: "ALIGNMENT_EQUAL_ROUNDED",
	2: "ALIGNMENT_EQUAL_AT_END",
}
var TimedCountAlignment_value = map[string]int32{
	"ERROR_COUNT_ALIGNMENT_UNSPECIFIED": 0,
	"ALIGNMENT_EQUAL_ROUNDED":           1,
	"ALIGNMENT_EQUAL_AT_END":            2,
}

func (x TimedCountAlignment) String() string {
	return proto.EnumName(TimedCountAlignment_name, int32(x))
}
func (TimedCountAlignment) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{0}
}

// A sorting order of error groups.
type ErrorGroupOrder int32

const (
	// No group order specified.
	ErrorGroupOrder_GROUP_ORDER_UNSPECIFIED ErrorGroupOrder = 0
	// Total count of errors in the given time window in descending order.
	ErrorGroupOrder_COUNT_DESC ErrorGroupOrder = 1
	// Timestamp when the group was last seen in the given time window
	// in descending order.
	ErrorGroupOrder_LAST_SEEN_DESC ErrorGroupOrder = 2
	// Timestamp when the group was created in descending order.
	ErrorGroupOrder_CREATED_DESC ErrorGroupOrder = 3
	// Number of affected users in the given time window in descending order.
	ErrorGroupOrder_AFFECTED_USERS_DESC ErrorGroupOrder = 4
)

var ErrorGroupOrder_name = map[int32]string{
	0: "GROUP_ORDER_UNSPECIFIED",
	1: "COUNT_DESC",
	2: "LAST_SEEN_DESC",
	3: "CREATED_DESC",
	4: "AFFECTED_USERS_DESC",
}
var ErrorGroupOrder_value = map[string]int32{
	"GROUP_ORDER_UNSPECIFIED": 0,
	"COUNT_DESC":              1,
	"LAST_SEEN_DESC":          2,
	"CREATED_DESC":            3,
	"AFFECTED_USERS_DESC":     4,
}

func (x ErrorGroupOrder) String() string {
	return proto.EnumName(ErrorGroupOrder_name, int32(x))
}
func (ErrorGroupOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{1}
}

// The supported time ranges.
type QueryTimeRange_Period int32

const (
	// Do not use.
	QueryTimeRange_PERIOD_UNSPECIFIED QueryTimeRange_Period = 0
	// Retrieve data for the last hour.
	// Recommended minimum timed count duration: 1 min.
	QueryTimeRange_PERIOD_1_HOUR QueryTimeRange_Period = 1
	// Retrieve data for the last 6 hours.
	// Recommended minimum timed count duration: 10 min.
	QueryTimeRange_PERIOD_6_HOURS QueryTimeRange_Period = 2
	// Retrieve data for the last day.
	// Recommended minimum timed count duration: 1 hour.
	QueryTimeRange_PERIOD_1_DAY QueryTimeRange_Period = 3
	// Retrieve data for the last week.
	// Recommended minimum timed count duration: 6 hours.
	QueryTimeRange_PERIOD_1_WEEK QueryTimeRange_Period = 4
	// Retrieve data for the last 30 days.
	// Recommended minimum timed count duration: 1 day.
	QueryTimeRange_PERIOD_30_DAYS QueryTimeRange_Period = 5
)

var QueryTimeRange_Period_name = map[int32]string{
	0: "PERIOD_UNSPECIFIED",
	1: "PERIOD_1_HOUR",
	2: "PERIOD_6_HOURS",
	3: "PERIOD_1_DAY",
	4: "PERIOD_1_WEEK",
	5: "PERIOD_30_DAYS",
}
var QueryTimeRange_Period_value = map[string]int32{
	"PERIOD_UNSPECIFIED": 0,
	"PERIOD_1_HOUR":      1,
	"PERIOD_6_HOURS":     2,
	"PERIOD_1_DAY":       3,
	"PERIOD_1_WEEK":      4,
	"PERIOD_30_DAYS":     5,
}

func (x QueryTimeRange_Period) String() string {
	return proto.EnumName(QueryTimeRange_Period_name, int32(x))
}
func (QueryTimeRange_Period) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{6, 0}
}

// Specifies a set of `ErrorGroupStats` to return.
type ListGroupStatsRequest struct {
	// [Required] The resource name of the Google Cloud Platform project. Written
	// as <code>projects/</code> plus the
	// <a href="https://support.google.com/cloud/answer/6158840">Google Cloud
	// Platform project ID</a>.
	//
	// Example: <code>projects/my-project-123</code>.
	ProjectName string `protobuf:"bytes,1,opt,name=project_name,json=projectName,proto3" json:"project_name,omitempty"`
	// [Optional] List all <code>ErrorGroupStats</code> with these IDs.
	GroupId []string `protobuf:"bytes,2,rep,name=group_id,json=groupId" json:"group_id,omitempty"`
	// [Optional] List only <code>ErrorGroupStats</code> which belong to a service
	// context that matches the filter.
	// Data for all service contexts is returned if this field is not specified.
	ServiceFilter *ServiceContextFilter `protobuf:"bytes,3,opt,name=service_filter,json=serviceFilter" json:"service_filter,omitempty"`
	// [Optional] List data for the given time range.
	// If not set a default time range is used. The field time_range_begin
	// in the response will specify the beginning of this time range.
	// Only <code>ErrorGroupStats</code> with a non-zero count in the given time
	// range are returned, unless the request contains an explicit group_id list.
	// If a group_id list is given, also <code>ErrorGroupStats</code> with zero
	// occurrences are returned.
	TimeRange *QueryTimeRange `protobuf:"bytes,5,opt,name=time_range,json=timeRange" json:"time_range,omitempty"`
	// [Optional] The preferred duration for a single returned `TimedCount`.
	// If not set, no timed counts are returned.
	TimedCountDuration *google_protobuf2.Duration `protobuf:"bytes,6,opt,name=timed_count_duration,json=timedCountDuration" json:"timed_count_duration,omitempty"`
	// [Optional] The alignment of the timed counts to be returned.
	// Default is `ALIGNMENT_EQUAL_AT_END`.
	Alignment TimedCountAlignment `protobuf:"varint,7,opt,name=alignment,proto3,enum=google.devtools.clouderrorreporting.v1beta1.TimedCountAlignment" json:"alignment,omitempty"`
	// [Optional] Time where the timed counts shall be aligned if rounded
	// alignment is chosen. Default is 00:00 UTC.
	AlignmentTime *google_protobuf1.Timestamp `protobuf:"bytes,8,opt,name=alignment_time,json=alignmentTime" json:"alignment_time,omitempty"`
	// [Optional] The sort order in which the results are returned.
	// Default is `COUNT_DESC`.
	Order ErrorGroupOrder `protobuf:"varint,9,opt,name=order,proto3,enum=google.devtools.clouderrorreporting.v1beta1.ErrorGroupOrder" json:"order,omitempty"`
	// [Optional] The maximum number of results to return per response.
	// Default is 20.
	PageSize int32 `protobuf:"varint,11,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// [Optional] A `next_page_token` provided by a previous response. To view
	// additional results, pass this token along with the identical query
	// parameters as the first request.
	PageToken string `protobuf:"bytes,12,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
}

func (m *ListGroupStatsRequest) Reset()         { *m = ListGroupStatsRequest{} }
func (m *ListGroupStatsRequest) String() string { return proto.CompactTextString(m) }
func (*ListGroupStatsRequest) ProtoMessage()    {}
func (*ListGroupStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{0}
}

func (m *ListGroupStatsRequest) GetProjectName() string {
	if m != nil {
		return m.ProjectName
	}
	return ""
}

func (m *ListGroupStatsRequest) GetGroupId() []string {
	if m != nil {
		return m.GroupId
	}
	return nil
}

func (m *ListGroupStatsRequest) GetServiceFilter() *ServiceContextFilter {
	if m != nil {
		return m.ServiceFilter
	}
	return nil
}

func (m *ListGroupStatsRequest) GetTimeRange() *QueryTimeRange {
	if m != nil {
		return m.TimeRange
	}
	return nil
}

func (m *ListGroupStatsRequest) GetTimedCountDuration() *google_protobuf2.Duration {
	if m != nil {
		return m.TimedCountDuration
	}
	return nil
}

func (m *ListGroupStatsRequest) GetAlignment() TimedCountAlignment {
	if m != nil {
		return m.Alignment
	}
	return TimedCountAlignment_ERROR_COUNT_ALIGNMENT_UNSPECIFIED
}

func (m *ListGroupStatsRequest) GetAlignmentTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.AlignmentTime
	}
	return nil
}

func (m *ListGroupStatsRequest) GetOrder() ErrorGroupOrder {
	if m != nil {
		return m.Order
	}
	return ErrorGroupOrder_GROUP_ORDER_UNSPECIFIED
}

func (m *ListGroupStatsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListGroupStatsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Contains a set of requested error group stats.
type ListGroupStatsResponse struct {
	// The error group stats which match the given request.
	ErrorGroupStats []*ErrorGroupStats `protobuf:"bytes,1,rep,name=error_group_stats,json=errorGroupStats" json:"error_group_stats,omitempty"`
	// If non-empty, more results are available.
	// Pass this token, along with the same query parameters as the first
	// request, to view the next page of results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	// The timestamp specifies the start time to which the request was restricted.
	// The start time is set based on the requested time range. It may be adjusted
	// to a later time if a project has exceeded the storage quota and older data
	// has been deleted.
	TimeRangeBegin *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=time_range_begin,json=timeRangeBegin" json:"time_range_begin,omitempty"`
}

func (m *ListGroupStatsResponse) Reset()         { *m = ListGroupStatsResponse{} }
func (m *ListGroupStatsResponse) String() string { return proto.CompactTextString(m) }
func (*ListGroupStatsResponse) ProtoMessage()    {}
func (*ListGroupStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{1}
}

func (m *ListGroupStatsResponse) GetErrorGroupStats() []*ErrorGroupStats {
	if m != nil {
		return m.ErrorGroupStats
	}
	return nil
}

func (m *ListGroupStatsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListGroupStatsResponse) GetTimeRangeBegin() *google_protobuf1.Timestamp {
	if m != nil {
		return m.TimeRangeBegin
	}
	return nil
}

// Data extracted for a specific group based on certain filter criteria,
// such as a given time period and/or service filter.
type ErrorGroupStats struct {
	// Group data that is independent of the filter criteria.
	Group *ErrorGroup `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	// Approximate total number of events in the given group that match
	// the filter criteria.
	Count int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// Approximate number of affected users in the given group that
	// match the filter criteria.
	// Users are distinguished by data in the `ErrorContext` of the
	// individual error events, such as their login name or their remote
	// IP address in case of HTTP requests.
	// The number of affected users can be zero even if the number of
	// errors is non-zero if no data was provided from which the
	// affected user could be deduced.
	// Users are counted based on data in the request
	// context that was provided in the error report. If more users are
	// implicitly affected, such as due to a crash of the whole service,
	// this is not reflected here.
	AffectedUsersCount int64 `protobuf:"varint,3,opt,name=affected_users_count,json=affectedUsersCount,proto3" json:"affected_users_count,omitempty"`
	// Approximate number of occurrences over time.
	// Timed counts returned by ListGroups are guaranteed to be:
	//
	// - Inside the requested time interval
	// - Non-overlapping, and
	// - Ordered by ascending time.
	TimedCounts []*TimedCount `protobuf:"bytes,4,rep,name=timed_counts,json=timedCounts" json:"timed_counts,omitempty"`
	// Approximate first occurrence that was ever seen for this group
	// and which matches the given filter criteria, ignoring the
	// time_range that was specified in the request.
	FirstSeenTime *google_protobuf1.Timestamp `protobuf:"bytes,5,opt,name=first_seen_time,json=firstSeenTime" json:"first_seen_time,omitempty"`
	// Approximate last occurrence that was ever seen for this group and
	// which matches the given filter criteria, ignoring the time_range
	// that was specified in the request.
	LastSeenTime *google_protobuf1.Timestamp `protobuf:"bytes,6,opt,name=last_seen_time,json=lastSeenTime" json:"last_seen_time,omitempty"`
	// Service contexts with a non-zero error count for the given filter
	// criteria. This list can be truncated if multiple services are affected.
	// Refer to `num_affected_services` for the total count.
	AffectedServices []*ServiceContext `protobuf:"bytes,7,rep,name=affected_services,json=affectedServices" json:"affected_services,omitempty"`
	// The total number of services with a non-zero error count for the given
	// filter criteria.
	NumAffectedServices int32 `protobuf:"varint,8,opt,name=num_affected_services,json=numAffectedServices,proto3" json:"num_affected_services,omitempty"`
	// An arbitrary event that is chosen as representative for the whole group.
	// The representative event is intended to be used as a quick preview for
	// the whole group. Events in the group are usually sufficiently similar
	// to each other such that showing an arbitrary representative provides
	// insight into the characteristics of the group as a whole.
	Representative *ErrorEvent `protobuf:"bytes,9,opt,name=representative" json:"representative,omitempty"`
}

func (m *ErrorGroupStats) Reset()                    { *m = ErrorGroupStats{} }
func (m *ErrorGroupStats) String() string            { return proto.CompactTextString(m) }
func (*ErrorGroupStats) ProtoMessage()               {}
func (*ErrorGroupStats) Descriptor() ([]byte, []int) { return fileDescriptorErrorStatsService, []int{2} }

func (m *ErrorGroupStats) GetGroup() *ErrorGroup {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ErrorGroupStats) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ErrorGroupStats) GetAffectedUsersCount() int64 {
	if m != nil {
		return m.AffectedUsersCount
	}
	return 0
}

func (m *ErrorGroupStats) GetTimedCounts() []*TimedCount {
	if m != nil {
		return m.TimedCounts
	}
	return nil
}

func (m *ErrorGroupStats) GetFirstSeenTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.FirstSeenTime
	}
	return nil
}

func (m *ErrorGroupStats) GetLastSeenTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.LastSeenTime
	}
	return nil
}

func (m *ErrorGroupStats) GetAffectedServices() []*ServiceContext {
	if m != nil {
		return m.AffectedServices
	}
	return nil
}

func (m *ErrorGroupStats) GetNumAffectedServices() int32 {
	if m != nil {
		return m.NumAffectedServices
	}
	return 0
}

func (m *ErrorGroupStats) GetRepresentative() *ErrorEvent {
	if m != nil {
		return m.Representative
	}
	return nil
}

// The number of errors in a given time period.
// All numbers are approximate since the error events are sampled
// before counting them.
type TimedCount struct {
	// Approximate number of occurrences in the given time period.
	Count int64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// Start of the time period to which `count` refers (included).
	StartTime *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// End of the time period to which `count` refers (excluded).
	EndTime *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
}

func (m *TimedCount) Reset()                    { *m = TimedCount{} }
func (m *TimedCount) String() string            { return proto.CompactTextString(m) }
func (*TimedCount) ProtoMessage()               {}
func (*TimedCount) Descriptor() ([]byte, []int) { return fileDescriptorErrorStatsService, []int{3} }

func (m *TimedCount) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *TimedCount) GetStartTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *TimedCount) GetEndTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// Specifies a set of error events to return.
type ListEventsRequest struct {
	// [Required] The resource name of the Google Cloud Platform project. Written
	// as `projects/` plus the
	// [Google Cloud Platform project
	// ID](https://support.google.com/cloud/answer/6158840).
	// Example: `projects/my-project-123`.
	ProjectName string `protobuf:"bytes,1,opt,name=project_name,json=projectName,proto3" json:"project_name,omitempty"`
	// [Required] The group for which events shall be returned.
	GroupId string `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// [Optional] List only ErrorGroups which belong to a service context that
	// matches the filter.
	// Data for all service contexts is returned if this field is not specified.
	ServiceFilter *ServiceContextFilter `protobuf:"bytes,3,opt,name=service_filter,json=serviceFilter" json:"service_filter,omitempty"`
	// [Optional] List only data for the given time range.
	// If not set a default time range is used. The field time_range_begin
	// in the response will specify the beginning of this time range.
	TimeRange *QueryTimeRange `protobuf:"bytes,4,opt,name=time_range,json=timeRange" json:"time_range,omitempty"`
	// [Optional] The maximum number of results to return per response.
	PageSize int32 `protobuf:"varint,6,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// [Optional] A `next_page_token` provided by a previous response.
	PageToken string `protobuf:"bytes,7,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
}

func (m *ListEventsRequest) Reset()         { *m = ListEventsRequest{} }
func (m *ListEventsRequest) String() string { return proto.CompactTextString(m) }
func (*ListEventsRequest) ProtoMessage()    {}
func (*ListEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{4}
}

func (m *ListEventsRequest) GetProjectName() string {
	if m != nil {
		return m.ProjectName
	}
	return ""
}

func (m *ListEventsRequest) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *ListEventsRequest) GetServiceFilter() *ServiceContextFilter {
	if m != nil {
		return m.ServiceFilter
	}
	return nil
}

func (m *ListEventsRequest) GetTimeRange() *QueryTimeRange {
	if m != nil {
		return m.TimeRange
	}
	return nil
}

func (m *ListEventsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListEventsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Contains a set of requested error events.
type ListEventsResponse struct {
	// The error events which match the given request.
	ErrorEvents []*ErrorEvent `protobuf:"bytes,1,rep,name=error_events,json=errorEvents" json:"error_events,omitempty"`
	// If non-empty, more results are available.
	// Pass this token, along with the same query parameters as the first
	// request, to view the next page of results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	// The timestamp specifies the start time to which the request was restricted.
	TimeRangeBegin *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=time_range_begin,json=timeRangeBegin" json:"time_range_begin,omitempty"`
}

func (m *ListEventsResponse) Reset()         { *m = ListEventsResponse{} }
func (m *ListEventsResponse) String() string { return proto.CompactTextString(m) }
func (*ListEventsResponse) ProtoMessage()    {}
func (*ListEventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{5}
}

func (m *ListEventsResponse) GetErrorEvents() []*ErrorEvent {
	if m != nil {
		return m.ErrorEvents
	}
	return nil
}

func (m *ListEventsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListEventsResponse) GetTimeRangeBegin() *google_protobuf1.Timestamp {
	if m != nil {
		return m.TimeRangeBegin
	}
	return nil
}

// Requests might be rejected or the resulting timed count durations might be
// adjusted for lower durations.
type QueryTimeRange struct {
	// Restricts the query to the specified time range.
	Period QueryTimeRange_Period `protobuf:"varint,1,opt,name=period,proto3,enum=google.devtools.clouderrorreporting.v1beta1.QueryTimeRange_Period" json:"period,omitempty"`
}

func (m *QueryTimeRange) Reset()                    { *m = QueryTimeRange{} }
func (m *QueryTimeRange) String() string            { return proto.CompactTextString(m) }
func (*QueryTimeRange) ProtoMessage()               {}
func (*QueryTimeRange) Descriptor() ([]byte, []int) { return fileDescriptorErrorStatsService, []int{6} }

func (m *QueryTimeRange) GetPeriod() QueryTimeRange_Period {
	if m != nil {
		return m.Period
	}
	return QueryTimeRange_PERIOD_UNSPECIFIED
}

// Specifies criteria for filtering a subset of service contexts.
// The fields in the filter correspond to the fields in `ServiceContext`.
// Only exact, case-sensitive matches are supported.
// If a field is unset or empty, it matches arbitrary values.
type ServiceContextFilter struct {
	// [Optional] The exact value to match against
	// [`ServiceContext.service`](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.service).
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	// [Optional] The exact value to match against
	// [`ServiceContext.version`](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.version).
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// [Optional] The exact value to match against
	// [`ServiceContext.resource_type`](/error-reporting/reference/rest/v1beta1/ServiceContext#FIELDS.resource_type).
	ResourceType string `protobuf:"bytes,4,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
}

func (m *ServiceContextFilter) Reset()         { *m = ServiceContextFilter{} }
func (m *ServiceContextFilter) String() string { return proto.CompactTextString(m) }
func (*ServiceContextFilter) ProtoMessage()    {}
func (*ServiceContextFilter) Descriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{7}
}

func (m *ServiceContextFilter) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *ServiceContextFilter) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ServiceContextFilter) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

// Deletes all events in the project.
type DeleteEventsRequest struct {
	// [Required] The resource name of the Google Cloud Platform project. Written
	// as `projects/` plus the
	// [Google Cloud Platform project
	// ID](https://support.google.com/cloud/answer/6158840).
	// Example: `projects/my-project-123`.
	ProjectName string `protobuf:"bytes,1,opt,name=project_name,json=projectName,proto3" json:"project_name,omitempty"`
}

func (m *DeleteEventsRequest) Reset()         { *m = DeleteEventsRequest{} }
func (m *DeleteEventsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteEventsRequest) ProtoMessage()    {}
func (*DeleteEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{8}
}

func (m *DeleteEventsRequest) GetProjectName() string {
	if m != nil {
		return m.ProjectName
	}
	return ""
}

// Response message for deleting error events.
type DeleteEventsResponse struct {
}

func (m *DeleteEventsResponse) Reset()         { *m = DeleteEventsResponse{} }
func (m *DeleteEventsResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteEventsResponse) ProtoMessage()    {}
func (*DeleteEventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorErrorStatsService, []int{9}
}

func init() {
	proto.RegisterType((*ListGroupStatsRequest)(nil), "google.devtools.clouderrorreporting.v1beta1.ListGroupStatsRequest")
	proto.RegisterType((*ListGroupStatsResponse)(nil), "google.devtools.clouderrorreporting.v1beta1.ListGroupStatsResponse")
	proto.RegisterType((*ErrorGroupStats)(nil), "google.devtools.clouderrorreporting.v1beta1.ErrorGroupStats")
	proto.RegisterType((*TimedCount)(nil), "google.devtools.clouderrorreporting.v1beta1.TimedCount")
	proto.RegisterType((*ListEventsRequest)(nil), "google.devtools.clouderrorreporting.v1beta1.ListEventsRequest")
	proto.RegisterType((*ListEventsResponse)(nil), "google.devtools.clouderrorreporting.v1beta1.ListEventsResponse")
	proto.RegisterType((*QueryTimeRange)(nil), "google.devtools.clouderrorreporting.v1beta1.QueryTimeRange")
	proto.RegisterType((*ServiceContextFilter)(nil), "google.devtools.clouderrorreporting.v1beta1.ServiceContextFilter")
	proto.RegisterType((*DeleteEventsRequest)(nil), "google.devtools.clouderrorreporting.v1beta1.DeleteEventsRequest")
	proto.RegisterType((*DeleteEventsResponse)(nil), "google.devtools.clouderrorreporting.v1beta1.DeleteEventsResponse")
	proto.RegisterEnum("google.devtools.clouderrorreporting.v1beta1.TimedCountAlignment", TimedCountAlignment_name, TimedCountAlignment_value)
	proto.RegisterEnum("google.devtools.clouderrorreporting.v1beta1.ErrorGroupOrder", ErrorGroupOrder_name, ErrorGroupOrder_value)
	proto.RegisterEnum("google.devtools.clouderrorreporting.v1beta1.QueryTimeRange_Period", QueryTimeRange_Period_name, QueryTimeRange_Period_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ErrorStatsService service

type ErrorStatsServiceClient interface {
	// Lists the specified groups.
	ListGroupStats(ctx context.Context, in *ListGroupStatsRequest, opts ...grpc.CallOption) (*ListGroupStatsResponse, error)
	// Lists the specified events.
	ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (*ListEventsResponse, error)
	// Deletes all error events of a given project.
	DeleteEvents(ctx context.Context, in *DeleteEventsRequest, opts ...grpc.CallOption) (*DeleteEventsResponse, error)
}

type errorStatsServiceClient struct {
	cc *grpc.ClientConn
}

func NewErrorStatsServiceClient(cc *grpc.ClientConn) ErrorStatsServiceClient {
	return &errorStatsServiceClient{cc}
}

func (c *errorStatsServiceClient) ListGroupStats(ctx context.Context, in *ListGroupStatsRequest, opts ...grpc.CallOption) (*ListGroupStatsResponse, error) {
	out := new(ListGroupStatsResponse)
	err := grpc.Invoke(ctx, "/google.devtools.clouderrorreporting.v1beta1.ErrorStatsService/ListGroupStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *errorStatsServiceClient) ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (*ListEventsResponse, error) {
	out := new(ListEventsResponse)
	err := grpc.Invoke(ctx, "/google.devtools.clouderrorreporting.v1beta1.ErrorStatsService/ListEvents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *errorStatsServiceClient) DeleteEvents(ctx context.Context, in *DeleteEventsRequest, opts ...grpc.CallOption) (*DeleteEventsResponse, error) {
	out := new(DeleteEventsResponse)
	err := grpc.Invoke(ctx, "/google.devtools.clouderrorreporting.v1beta1.ErrorStatsService/DeleteEvents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ErrorStatsService service

type ErrorStatsServiceServer interface {
	// Lists the specified groups.
	ListGroupStats(context.Context, *ListGroupStatsRequest) (*ListGroupStatsResponse, error)
	// Lists the specified events.
	ListEvents(context.Context, *ListEventsRequest) (*ListEventsResponse, error)
	// Deletes all error events of a given project.
	DeleteEvents(context.Context, *DeleteEventsRequest) (*DeleteEventsResponse, error)
}

func RegisterErrorStatsServiceServer(s *grpc.Server, srv ErrorStatsServiceServer) {
	s.RegisterService(&_ErrorStatsService_serviceDesc, srv)
}

func _ErrorStatsService_ListGroupStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorStatsServiceServer).ListGroupStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.devtools.clouderrorreporting.v1beta1.ErrorStatsService/ListGroupStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorStatsServiceServer).ListGroupStats(ctx, req.(*ListGroupStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ErrorStatsService_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorStatsServiceServer).ListEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.devtools.clouderrorreporting.v1beta1.ErrorStatsService/ListEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorStatsServiceServer).ListEvents(ctx, req.(*ListEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ErrorStatsService_DeleteEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ErrorStatsServiceServer).DeleteEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.devtools.clouderrorreporting.v1beta1.ErrorStatsService/DeleteEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ErrorStatsServiceServer).DeleteEvents(ctx, req.(*DeleteEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ErrorStatsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.devtools.clouderrorreporting.v1beta1.ErrorStatsService",
	HandlerType: (*ErrorStatsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListGroupStats",
			Handler:    _ErrorStatsService_ListGroupStats_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _ErrorStatsService_ListEvents_Handler,
		},
		{
			MethodName: "DeleteEvents",
			Handler:    _ErrorStatsService_DeleteEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/devtools/clouderrorreporting/v1beta1/error_stats_service.proto",
}

func (m *ListGroupStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListGroupStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProjectName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.ProjectName)))
		i += copy(dAtA[i:], m.ProjectName)
	}
	if len(m.GroupId) > 0 {
		for _, s := range m.GroupId {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ServiceFilter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.ServiceFilter.Size()))
		n1, err := m.ServiceFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.TimeRange != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.TimeRange.Size()))
		n2, err := m.TimeRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.TimedCountDuration != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.TimedCountDuration.Size()))
		n3, err := m.TimedCountDuration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Alignment != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.Alignment))
	}
	if m.AlignmentTime != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.AlignmentTime.Size()))
		n4, err := m.AlignmentTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Order != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.Order))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	return i, nil
}

func (m *ListGroupStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListGroupStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ErrorGroupStats) > 0 {
		for _, msg := range m.ErrorGroupStats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintErrorStatsService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TimeRangeBegin != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.TimeRangeBegin.Size()))
		n5, err := m.TimeRangeBegin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *ErrorGroupStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorGroupStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.Group.Size()))
		n6, err := m.Group.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.Count))
	}
	if m.AffectedUsersCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.AffectedUsersCount))
	}
	if len(m.TimedCounts) > 0 {
		for _, msg := range m.TimedCounts {
			dAtA[i] = 0x22
			i++
			i = encodeVarintErrorStatsService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FirstSeenTime != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.FirstSeenTime.Size()))
		n7, err := m.FirstSeenTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.LastSeenTime != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.LastSeenTime.Size()))
		n8, err := m.LastSeenTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.AffectedServices) > 0 {
		for _, msg := range m.AffectedServices {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintErrorStatsService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NumAffectedServices != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.NumAffectedServices))
	}
	if m.Representative != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.Representative.Size()))
		n9, err := m.Representative.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *TimedCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimedCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.Count))
	}
	if m.StartTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.StartTime.Size()))
		n10, err := m.StartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.EndTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.EndTime.Size()))
		n11, err := m.EndTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *ListEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProjectName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.ProjectName)))
		i += copy(dAtA[i:], m.ProjectName)
	}
	if len(m.GroupId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.GroupId)))
		i += copy(dAtA[i:], m.GroupId)
	}
	if m.ServiceFilter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.ServiceFilter.Size()))
		n12, err := m.ServiceFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.TimeRange != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.TimeRange.Size()))
		n13, err := m.TimeRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	return i, nil
}

func (m *ListEventsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListEventsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ErrorEvents) > 0 {
		for _, msg := range m.ErrorEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintErrorStatsService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TimeRangeBegin != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.TimeRangeBegin.Size()))
		n14, err := m.TimeRangeBegin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *QueryTimeRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTimeRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Period != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(m.Period))
	}
	return i, nil
}

func (m *ServiceContextFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceContextFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Service) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.Service)))
		i += copy(dAtA[i:], m.Service)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.ResourceType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.ResourceType)))
		i += copy(dAtA[i:], m.ResourceType)
	}
	return i, nil
}

func (m *DeleteEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProjectName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrorStatsService(dAtA, i, uint64(len(m.ProjectName)))
		i += copy(dAtA[i:], m.ProjectName)
	}
	return i, nil
}

func (m *DeleteEventsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteEventsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64ErrorStatsService(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32ErrorStatsService(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintErrorStatsService(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ListGroupStatsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if len(m.GroupId) > 0 {
		for _, s := range m.GroupId {
			l = len(s)
			n += 1 + l + sovErrorStatsService(uint64(l))
		}
	}
	if m.ServiceFilter != nil {
		l = m.ServiceFilter.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.TimeRange != nil {
		l = m.TimeRange.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.TimedCountDuration != nil {
		l = m.TimedCountDuration.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.Alignment != 0 {
		n += 1 + sovErrorStatsService(uint64(m.Alignment))
	}
	if m.AlignmentTime != nil {
		l = m.AlignmentTime.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovErrorStatsService(uint64(m.Order))
	}
	if m.PageSize != 0 {
		n += 1 + sovErrorStatsService(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	return n
}

func (m *ListGroupStatsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ErrorGroupStats) > 0 {
		for _, e := range m.ErrorGroupStats {
			l = e.Size()
			n += 1 + l + sovErrorStatsService(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.TimeRangeBegin != nil {
		l = m.TimeRangeBegin.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	return n
}

func (m *ErrorGroupStats) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovErrorStatsService(uint64(m.Count))
	}
	if m.AffectedUsersCount != 0 {
		n += 1 + sovErrorStatsService(uint64(m.AffectedUsersCount))
	}
	if len(m.TimedCounts) > 0 {
		for _, e := range m.TimedCounts {
			l = e.Size()
			n += 1 + l + sovErrorStatsService(uint64(l))
		}
	}
	if m.FirstSeenTime != nil {
		l = m.FirstSeenTime.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.LastSeenTime != nil {
		l = m.LastSeenTime.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if len(m.AffectedServices) > 0 {
		for _, e := range m.AffectedServices {
			l = e.Size()
			n += 1 + l + sovErrorStatsService(uint64(l))
		}
	}
	if m.NumAffectedServices != 0 {
		n += 1 + sovErrorStatsService(uint64(m.NumAffectedServices))
	}
	if m.Representative != nil {
		l = m.Representative.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	return n
}

func (m *TimedCount) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovErrorStatsService(uint64(m.Count))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	return n
}

func (m *ListEventsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.ServiceFilter != nil {
		l = m.ServiceFilter.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.TimeRange != nil {
		l = m.TimeRange.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovErrorStatsService(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	return n
}

func (m *ListEventsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ErrorEvents) > 0 {
		for _, e := range m.ErrorEvents {
			l = e.Size()
			n += 1 + l + sovErrorStatsService(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	if m.TimeRangeBegin != nil {
		l = m.TimeRangeBegin.Size()
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	return n
}

func (m *QueryTimeRange) Size() (n int) {
	var l int
	_ = l
	if m.Period != 0 {
		n += 1 + sovErrorStatsService(uint64(m.Period))
	}
	return n
}

func (m *ServiceContextFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	return n
}

func (m *DeleteEventsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovErrorStatsService(uint64(l))
	}
	return n
}

func (m *DeleteEventsResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovErrorStatsService(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozErrorStatsService(x uint64) (n int) {
	return sovErrorStatsService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ListGroupStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListGroupStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListGroupStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = append(m.GroupId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceFilter == nil {
				m.ServiceFilter = &ServiceContextFilter{}
			}
			if err := m.ServiceFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeRange == nil {
				m.TimeRange = &QueryTimeRange{}
			}
			if err := m.TimeRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimedCountDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimedCountDuration == nil {
				m.TimedCountDuration = &google_protobuf2.Duration{}
			}
			if err := m.TimedCountDuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alignment", wireType)
			}
			m.Alignment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alignment |= (TimedCountAlignment(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlignmentTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AlignmentTime == nil {
				m.AlignmentTime = &google_protobuf1.Timestamp{}
			}
			if err := m.AlignmentTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (ErrorGroupOrder(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListGroupStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListGroupStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListGroupStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorGroupStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorGroupStats = append(m.ErrorGroupStats, &ErrorGroupStats{})
			if err := m.ErrorGroupStats[len(m.ErrorGroupStats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRangeBegin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeRangeBegin == nil {
				m.TimeRangeBegin = &google_protobuf1.Timestamp{}
			}
			if err := m.TimeRangeBegin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorGroupStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorGroupStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorGroupStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &ErrorGroup{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedUsersCount", wireType)
			}
			m.AffectedUsersCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedUsersCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimedCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimedCounts = append(m.TimedCounts, &TimedCount{})
			if err := m.TimedCounts[len(m.TimedCounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSeenTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstSeenTime == nil {
				m.FirstSeenTime = &google_protobuf1.Timestamp{}
			}
			if err := m.FirstSeenTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeenTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSeenTime == nil {
				m.LastSeenTime = &google_protobuf1.Timestamp{}
			}
			if err := m.LastSeenTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AffectedServices = append(m.AffectedServices, &ServiceContext{})
			if err := m.AffectedServices[len(m.AffectedServices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAffectedServices", wireType)
			}
			m.NumAffectedServices = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAffectedServices |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Representative", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Representative == nil {
				m.Representative = &ErrorEvent{}
			}
			if err := m.Representative.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimedCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimedCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimedCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &google_protobuf1.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &google_protobuf1.Timestamp{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceFilter == nil {
				m.ServiceFilter = &ServiceContextFilter{}
			}
			if err := m.ServiceFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeRange == nil {
				m.TimeRange = &QueryTimeRange{}
			}
			if err := m.TimeRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListEventsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListEventsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListEventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorEvents = append(m.ErrorEvents, &ErrorEvent{})
			if err := m.ErrorEvents[len(m.ErrorEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRangeBegin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeRangeBegin == nil {
				m.TimeRangeBegin = &google_protobuf1.Timestamp{}
			}
			if err := m.TimeRangeBegin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTimeRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTimeRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTimeRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= (QueryTimeRange_Period(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceContextFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceContextFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceContextFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteEventsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteEventsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteEventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrorStatsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrorStatsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipErrorStatsService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowErrorStatsService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowErrorStatsService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthErrorStatsService
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowErrorStatsService
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipErrorStatsService(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthErrorStatsService = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowErrorStatsService   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("google/devtools/clouderrorreporting/v1beta1/error_stats_service.proto", fileDescriptorErrorStatsService)
}

var fileDescriptorErrorStatsService = []byte{
	// 1328 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0x67, 0xed, 0x38, 0x89, 0x9f, 0x1d, 0xc7, 0x99, 0xa4, 0xe9, 0xd6, 0x85, 0x90, 0xba, 0x02,
	0x85, 0x54, 0xd8, 0x4d, 0xaa, 0xd2, 0xa2, 0xf2, 0xa7, 0x8e, 0xbd, 0x09, 0x51, 0x53, 0xdb, 0x1d,
	0xdb, 0x20, 0x72, 0xe8, 0x6a, 0x63, 0xbf, 0x6c, 0x17, 0xec, 0xdd, 0x65, 0x77, 0x1c, 0xb5, 0x45,
	0x95, 0x10, 0x37, 0xce, 0x70, 0xe3, 0x1b, 0xf0, 0x29, 0x38, 0x21, 0x8e, 0x95, 0x7a, 0x06, 0xa1,
	0x8a, 0x3b, 0x88, 0x4f, 0x80, 0x66, 0x66, 0xd7, 0xff, 0x6a, 0x91, 0xda, 0x41, 0x88, 0xdb, 0xce,
	0x7b, 0xf3, 0x7e, 0xef, 0xcf, 0xfc, 0xde, 0x9b, 0x59, 0xd0, 0x4c, 0xc7, 0x31, 0xdb, 0x98, 0x6f,
	0xe1, 0x09, 0x73, 0x9c, 0xb6, 0x9f, 0x6f, 0xb6, 0x9d, 0x6e, 0x0b, 0x3d, 0xcf, 0xf1, 0x3c, 0x74,
	0x1d, 0x8f, 0x59, 0xb6, 0x99, 0x3f, 0xd9, 0x3a, 0x42, 0x66, 0x6c, 0xe5, 0x85, 0x58, 0xf7, 0x99,
	0xc1, 0x7c, 0xdd, 0x47, 0xef, 0xc4, 0x6a, 0x62, 0xce, 0xf5, 0x1c, 0xe6, 0x90, 0x2b, 0x12, 0x26,
	0x17, 0xc2, 0xe4, 0xc6, 0xc0, 0xe4, 0x02, 0x98, 0xcc, 0xab, 0x81, 0x4f, 0xc3, 0xb5, 0xf2, 0x86,
	0x6d, 0x3b, 0xcc, 0x60, 0x96, 0x63, 0xfb, 0x12, 0x2a, 0x73, 0x73, 0x92, 0x88, 0x9a, 0x4e, 0xa7,
	0xe3, 0xd8, 0x81, 0xe5, 0x5a, 0x60, 0x29, 0x56, 0x47, 0xdd, 0xe3, 0x7c, 0xab, 0xeb, 0x09, 0xe8,
	0x40, 0xff, 0xfa, 0xa8, 0x9e, 0x59, 0x1d, 0xf4, 0x99, 0xd1, 0x71, 0xe5, 0x86, 0xec, 0xf7, 0x31,
	0x38, 0x77, 0x60, 0xf9, 0x6c, 0xcf, 0x73, 0xba, 0x6e, 0x8d, 0xa7, 0x49, 0xf1, 0x8b, 0x2e, 0xfa,
	0x8c, 0x5c, 0x82, 0xa4, 0xeb, 0x39, 0x9f, 0x61, 0x93, 0xe9, 0xb6, 0xd1, 0x41, 0x55, 0x59, 0x57,
	0x36, 0xe2, 0x34, 0x11, 0xc8, 0xca, 0x46, 0x07, 0xc9, 0x05, 0x98, 0x37, 0xb9, 0x9d, 0x6e, 0xb5,
	0xd4, 0xc8, 0x7a, 0x74, 0x23, 0x4e, 0xe7, 0xc4, 0x7a, 0xbf, 0x45, 0x1e, 0x40, 0x2a, 0x28, 0x97,
	0x7e, 0x6c, 0xb5, 0x19, 0x7a, 0x6a, 0x74, 0x5d, 0xd9, 0x48, 0x6c, 0x17, 0x72, 0x13, 0x94, 0x2d,
	0x57, 0x93, 0x10, 0x45, 0xc7, 0x66, 0xf8, 0x90, 0xed, 0x0a, 0x20, 0xba, 0x10, 0x00, 0xcb, 0x25,
	0x39, 0x04, 0xe0, 0x49, 0xe9, 0x9e, 0x61, 0x9b, 0xa8, 0xc6, 0x84, 0x97, 0x5b, 0x13, 0x79, 0xb9,
	0xd7, 0x45, 0xef, 0x51, 0xdd, 0xea, 0x20, 0xe5, 0x10, 0x34, 0xce, 0xc2, 0x4f, 0x72, 0x07, 0x56,
	0xf8, 0xa2, 0xa5, 0x37, 0x9d, 0xae, 0xcd, 0xf4, 0xb0, 0xb8, 0xea, 0xac, 0xf0, 0x72, 0x21, 0xf4,
	0x12, 0x56, 0x37, 0x57, 0x0a, 0x36, 0x50, 0x22, 0xcc, 0x8a, 0xdc, 0x2a, 0x94, 0x91, 0xfb, 0x10,
	0x37, 0xda, 0x96, 0x69, 0x77, 0xd0, 0x66, 0xea, 0xdc, 0xba, 0xb2, 0x91, 0xda, 0xbe, 0x3d, 0x51,
	0x9c, 0xf5, 0x1e, 0x66, 0x21, 0xc4, 0xa1, 0x7d, 0x48, 0x52, 0x80, 0x54, 0x6f, 0xa1, 0x73, 0xff,
	0xea, 0xbc, 0x08, 0x33, 0xf3, 0x42, 0x98, 0xf5, 0x90, 0x04, 0x74, 0xa1, 0x67, 0xc1, 0x65, 0x84,
	0x42, 0xcc, 0xf1, 0x5a, 0xe8, 0xa9, 0x71, 0x11, 0xde, 0x7b, 0x13, 0x85, 0xa7, 0x71, 0xb1, 0xe0,
	0x51, 0x85, 0x63, 0x50, 0x09, 0x45, 0x2e, 0x42, 0xdc, 0x35, 0x4c, 0xd4, 0x7d, 0xeb, 0x31, 0xaa,
	0x89, 0x75, 0x65, 0x23, 0x46, 0xe7, 0xb9, 0xa0, 0x66, 0x3d, 0x46, 0xf2, 0x1a, 0x80, 0x50, 0x32,
	0xe7, 0x73, 0xb4, 0xd5, 0xa4, 0xa0, 0x98, 0xd8, 0x5e, 0xe7, 0x82, 0xec, 0x9f, 0x0a, 0xac, 0x8e,
	0xb2, 0xd3, 0x77, 0x1d, 0xdb, 0x47, 0xf2, 0x00, 0x96, 0x64, 0x6f, 0x4a, 0x06, 0x8a, 0x0e, 0x55,
	0x95, 0xf5, 0xe8, 0x46, 0x62, 0xea, 0xb0, 0xa5, 0x83, 0x45, 0x1c, 0x16, 0x90, 0x37, 0x61, 0xd1,
	0xc6, 0x87, 0x4c, 0x1f, 0x08, 0x34, 0x22, 0x02, 0x5d, 0xe0, 0xe2, 0x6a, 0x18, 0x2c, 0x29, 0x41,
	0xba, 0x4f, 0x44, 0xfd, 0x08, 0x4d, 0xcb, 0x56, 0x67, 0x4e, 0x3d, 0x81, 0x54, 0x8f, 0x6d, 0x3b,
	0xdc, 0x22, 0xfb, 0x4d, 0x0c, 0x16, 0x47, 0x42, 0x22, 0x77, 0x21, 0x26, 0xb2, 0x14, 0x3d, 0x98,
	0xd8, 0xbe, 0x31, 0x65, 0x7e, 0x54, 0xa2, 0x90, 0x15, 0x88, 0x09, 0x3e, 0x8b, 0x34, 0xa2, 0x54,
	0x2e, 0xc8, 0x55, 0x58, 0x31, 0x8e, 0x8f, 0xb1, 0xc9, 0xb0, 0xa5, 0x77, 0x7d, 0xf4, 0x7c, 0x49,
	0x7a, 0xd1, 0xb7, 0x51, 0x4a, 0x42, 0x5d, 0x83, 0xab, 0x04, 0x09, 0xc9, 0x21, 0x24, 0x07, 0xba,
	0xc3, 0x57, 0x67, 0x44, 0xf5, 0x6f, 0x4c, 0xc9, 0x69, 0x9a, 0xe8, 0xf7, 0x8c, 0x4f, 0x76, 0x60,
	0xf1, 0xd8, 0xf2, 0x7c, 0xa6, 0xfb, 0x88, 0xb6, 0x64, 0x73, 0xec, 0x74, 0x36, 0x0b, 0x93, 0x1a,
	0xa2, 0x2d, 0xd8, 0x7c, 0x1b, 0x52, 0x6d, 0x63, 0x08, 0x62, 0xf6, 0x54, 0x88, 0x24, 0xb7, 0xe8,
	0x21, 0x3c, 0x80, 0xa5, 0x5e, 0x4d, 0x82, 0xa9, 0xe3, 0xab, 0x73, 0x22, 0xcd, 0x5b, 0x67, 0x18,
	0x64, 0x34, 0x1d, 0xa2, 0x06, 0x72, 0x9f, 0x6c, 0xc3, 0x39, 0xbb, 0xdb, 0xd1, 0x5f, 0xf4, 0x36,
	0x2f, 0x3a, 0x66, 0xd9, 0xee, 0x76, 0x0a, 0xa3, 0x36, 0x3a, 0xa4, 0x3c, 0x74, 0x3d, 0xf4, 0xd1,
	0xe6, 0xf7, 0xc9, 0x09, 0x8a, 0xb6, 0x9d, 0x8a, 0x1f, 0xda, 0x09, 0x1f, 0x26, 0x23, 0x70, 0xd9,
	0xef, 0x14, 0x80, 0xfe, 0x01, 0xf5, 0x79, 0xa3, 0x0c, 0xf2, 0xe6, 0x5d, 0x00, 0x9f, 0x19, 0x5e,
	0x30, 0x72, 0x22, 0xa7, 0x56, 0x38, 0x2e, 0x76, 0x8b, 0xf2, 0x5e, 0x87, 0x79, 0xb4, 0x5b, 0xd2,
	0x30, 0x7a, 0xaa, 0xe1, 0x1c, 0xda, 0x2d, 0xbe, 0xca, 0x3e, 0x8b, 0xc0, 0x12, 0x9f, 0x0a, 0x22,
	0xe8, 0xe9, 0xef, 0x2b, 0xe5, 0xff, 0x70, 0x5f, 0xcd, 0xfc, 0xab, 0xf7, 0xd5, 0xd0, 0xac, 0x9d,
	0xfd, 0xc7, 0x59, 0x3b, 0x37, 0x3a, 0x6b, 0x7f, 0x55, 0x80, 0x0c, 0x56, 0x35, 0x98, 0xb3, 0x87,
	0x90, 0x94, 0x73, 0x16, 0x85, 0x3c, 0x18, 0xb1, 0x53, 0x53, 0x2c, 0x81, 0xbd, 0xef, 0xff, 0x7a,
	0xb2, 0xfe, 0xa1, 0x40, 0x6a, 0xb8, 0x74, 0xe4, 0x10, 0x66, 0x5d, 0xf4, 0x2c, 0xa7, 0x25, 0xd8,
	0x92, 0xda, 0xde, 0x39, 0xc3, 0x39, 0xe4, 0xaa, 0x02, 0x89, 0x06, 0x88, 0xd9, 0xaf, 0x14, 0x98,
	0x95, 0x22, 0xb2, 0x0a, 0xa4, 0xaa, 0xd1, 0xfd, 0x4a, 0x49, 0x6f, 0x94, 0x6b, 0x55, 0xad, 0xb8,
	0xbf, 0xbb, 0xaf, 0x95, 0xd2, 0xaf, 0x90, 0x25, 0x58, 0x08, 0xe4, 0x5b, 0xfa, 0x47, 0x95, 0x06,
	0x4d, 0x2b, 0x84, 0x40, 0x2a, 0x10, 0xbd, 0x23, 0x44, 0xb5, 0x74, 0x84, 0xa4, 0x21, 0xd9, 0xdb,
	0x56, 0x2a, 0x7c, 0x9a, 0x8e, 0x0e, 0x19, 0x7e, 0xa2, 0x69, 0x77, 0xd2, 0x33, 0x03, 0x86, 0xd7,
	0xae, 0xf2, 0x5d, 0xb5, 0x74, 0x2c, 0xeb, 0xc0, 0xca, 0x38, 0x46, 0x12, 0x15, 0xe6, 0x02, 0x4e,
	0x86, 0x6d, 0x10, 0x2c, 0xb9, 0xe6, 0x04, 0x3d, 0x9f, 0xbf, 0x71, 0xa2, 0x52, 0x13, 0x2c, 0xc9,
	0x65, 0x58, 0xf0, 0xd0, 0x77, 0xba, 0x5e, 0x13, 0x75, 0xf6, 0xc8, 0x95, 0xcc, 0x8d, 0xd3, 0x64,
	0x28, 0xac, 0x3f, 0x72, 0x31, 0x7b, 0x13, 0x96, 0x4b, 0xd8, 0x46, 0x86, 0x93, 0xb6, 0x66, 0x76,
	0x15, 0x56, 0x86, 0x2d, 0x25, 0xfd, 0x36, 0xbb, 0xb0, 0x3c, 0xe6, 0xd9, 0x43, 0xde, 0x80, 0x4b,
	0x1a, 0xa5, 0x15, 0xaa, 0x17, 0x2b, 0x8d, 0x72, 0x5d, 0x2f, 0x1c, 0xec, 0xef, 0x95, 0xef, 0x6a,
	0xe5, 0xfa, 0x48, 0x81, 0x2f, 0xc2, 0xf9, 0xbe, 0x4a, 0xbb, 0xd7, 0x28, 0x1c, 0xe8, 0xb4, 0xd2,
	0x28, 0x97, 0xb4, 0x52, 0x5a, 0x21, 0x19, 0x58, 0x1d, 0x55, 0x16, 0xea, 0xba, 0x56, 0x2e, 0xa5,
	0x23, 0x9b, 0x4f, 0x06, 0x2f, 0xe1, 0x4a, 0xf0, 0x8e, 0x39, 0xbf, 0x47, 0x2b, 0x8d, 0xaa, 0x5e,
	0xa1, 0x25, 0x8d, 0x8e, 0x38, 0x4a, 0x01, 0xc8, 0x48, 0x4a, 0x5a, 0xad, 0x28, 0x8f, 0xf1, 0xa0,
	0x50, 0xab, 0xeb, 0x35, 0x4d, 0x2b, 0x4b, 0x99, 0x38, 0xc6, 0x22, 0xd5, 0x0a, 0x75, 0xad, 0x24,
	0x25, 0x51, 0x72, 0x1e, 0x96, 0x0b, 0xbb, 0xbb, 0x5a, 0x91, 0x8b, 0x1a, 0x35, 0x8d, 0xd6, 0xa4,
	0x62, 0x66, 0xfb, 0xaf, 0x19, 0x58, 0x12, 0xfe, 0xc5, 0xfd, 0x1f, 0x9c, 0x21, 0x79, 0xaa, 0x40,
	0x6a, 0xf8, 0x35, 0x44, 0x26, 0x23, 0xec, 0xd8, 0x87, 0x7e, 0xa6, 0x78, 0x26, 0x0c, 0x79, 0x4e,
	0xd9, 0xeb, 0x5f, 0x3f, 0xfb, 0xfd, 0xdb, 0x48, 0x9e, 0xbc, 0xdd, 0xfb, 0x4f, 0xf9, 0x72, 0xf0,
	0xc8, 0xdf, 0x0f, 0x16, 0x7e, 0x7e, 0xf3, 0x49, 0xde, 0xec, 0xc7, 0xff, 0xa3, 0x02, 0xd0, 0x1f,
	0x3a, 0xe4, 0x83, 0x89, 0x43, 0x19, 0x22, 0x5a, 0xe6, 0xc3, 0xa9, 0xed, 0x83, 0x34, 0xb6, 0x44,
	0x1a, 0x57, 0xc8, 0x5b, 0x2f, 0x91, 0x86, 0x1c, 0x88, 0xe4, 0x27, 0x05, 0x92, 0x83, 0xd4, 0x25,
	0x93, 0x3d, 0xea, 0xc7, 0xf4, 0x4b, 0xa6, 0x70, 0x06, 0x84, 0xe1, 0x44, 0x36, 0x5f, 0x3e, 0x91,
	0x9d, 0x5f, 0x94, 0x9f, 0x9f, 0xaf, 0x29, 0x4f, 0x9f, 0xaf, 0x29, 0xbf, 0x3d, 0x5f, 0x53, 0x80,
	0xff, 0x68, 0x4e, 0x12, 0xc7, 0xce, 0xea, 0x0b, 0x8c, 0xad, 0xf2, 0xa1, 0x5c, 0x55, 0x0e, 0xef,
	0x07, 0x30, 0xa6, 0xd3, 0x36, 0x6c, 0x33, 0xe7, 0x78, 0x66, 0xde, 0x44, 0x5b, 0x8c, 0xec, 0xbc,
	0x54, 0x19, 0xae, 0xe5, 0xbf, 0xd4, 0xef, 0xef, 0xad, 0x31, 0xba, 0x1f, 0x22, 0x97, 0xf7, 0xa4,
	0x83, 0x22, 0x57, 0xca, 0xeb, 0x86, 0xf6, 0xe2, 0xfb, 0x78, 0x6b, 0x87, 0x5b, 0x1e, 0xcd, 0x0a,
	0x87, 0xd7, 0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x32, 0x2e, 0x69, 0xb3, 0x00, 0x10, 0x00, 0x00,
}
