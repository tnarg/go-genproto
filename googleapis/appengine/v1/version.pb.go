// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/appengine/v1/version.proto

package appengine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Available inbound services.
type InboundServiceType int32

const (
	// Not specified.
	InboundServiceType_INBOUND_SERVICE_UNSPECIFIED InboundServiceType = 0
	// Allows an application to receive mail.
	InboundServiceType_INBOUND_SERVICE_MAIL InboundServiceType = 1
	// Allows an application to receive email-bound notifications.
	InboundServiceType_INBOUND_SERVICE_MAIL_BOUNCE InboundServiceType = 2
	// Allows an application to receive error stanzas.
	InboundServiceType_INBOUND_SERVICE_XMPP_ERROR InboundServiceType = 3
	// Allows an application to receive instant messages.
	InboundServiceType_INBOUND_SERVICE_XMPP_MESSAGE InboundServiceType = 4
	// Allows an application to receive user subscription POSTs.
	InboundServiceType_INBOUND_SERVICE_XMPP_SUBSCRIBE InboundServiceType = 5
	// Allows an application to receive a user's chat presence.
	InboundServiceType_INBOUND_SERVICE_XMPP_PRESENCE InboundServiceType = 6
	// Registers an application for notifications when a client connects or
	// disconnects from a channel.
	InboundServiceType_INBOUND_SERVICE_CHANNEL_PRESENCE InboundServiceType = 7
	// Enables warmup requests.
	InboundServiceType_INBOUND_SERVICE_WARMUP InboundServiceType = 9
)

var InboundServiceType_name = map[int32]string{
	0: "INBOUND_SERVICE_UNSPECIFIED",
	1: "INBOUND_SERVICE_MAIL",
	2: "INBOUND_SERVICE_MAIL_BOUNCE",
	3: "INBOUND_SERVICE_XMPP_ERROR",
	4: "INBOUND_SERVICE_XMPP_MESSAGE",
	5: "INBOUND_SERVICE_XMPP_SUBSCRIBE",
	6: "INBOUND_SERVICE_XMPP_PRESENCE",
	7: "INBOUND_SERVICE_CHANNEL_PRESENCE",
	9: "INBOUND_SERVICE_WARMUP",
}
var InboundServiceType_value = map[string]int32{
	"INBOUND_SERVICE_UNSPECIFIED":      0,
	"INBOUND_SERVICE_MAIL":             1,
	"INBOUND_SERVICE_MAIL_BOUNCE":      2,
	"INBOUND_SERVICE_XMPP_ERROR":       3,
	"INBOUND_SERVICE_XMPP_MESSAGE":     4,
	"INBOUND_SERVICE_XMPP_SUBSCRIBE":   5,
	"INBOUND_SERVICE_XMPP_PRESENCE":    6,
	"INBOUND_SERVICE_CHANNEL_PRESENCE": 7,
	"INBOUND_SERVICE_WARMUP":           9,
}

func (x InboundServiceType) String() string {
	return proto.EnumName(InboundServiceType_name, int32(x))
}
func (InboundServiceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorVersion, []int{0} }

// Run states of a version.
type ServingStatus int32

const (
	// Not specified.
	ServingStatus_SERVING_STATUS_UNSPECIFIED ServingStatus = 0
	// Currently serving. Instances are created according to the
	// scaling settings of the version.
	ServingStatus_SERVING ServingStatus = 1
	// Disabled. No instances will be created and the scaling
	// settings are ignored until the state of the version changes
	// to `SERVING`.
	ServingStatus_STOPPED ServingStatus = 2
)

var ServingStatus_name = map[int32]string{
	0: "SERVING_STATUS_UNSPECIFIED",
	1: "SERVING",
	2: "STOPPED",
}
var ServingStatus_value = map[string]int32{
	"SERVING_STATUS_UNSPECIFIED": 0,
	"SERVING":                    1,
	"STOPPED":                    2,
}

func (x ServingStatus) String() string {
	return proto.EnumName(ServingStatus_name, int32(x))
}
func (ServingStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorVersion, []int{1} }

// A Version resource is a specific set of source code and configuration files
// that are deployed into a service.
type Version struct {
	// Full path to the Version resource in the API.  Example:
	// `apps/myapp/services/default/versions/v1`.
	//
	// @OutputOnly
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Relative name of the version within the service.  Example: `v1`.
	// Version names can contain only lowercase letters, numbers, or hyphens.
	// Reserved names: "default", "latest", and any name with the prefix "ah-".
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Controls how instances are created.
	//
	// Defaults to `AutomaticScaling`.
	//
	// Types that are valid to be assigned to Scaling:
	//	*Version_AutomaticScaling
	//	*Version_BasicScaling
	//	*Version_ManualScaling
	Scaling isVersion_Scaling `protobuf_oneof:"scaling"`
	// Before an application can receive email or XMPP messages, the application
	// must be configured to enable the service.
	InboundServices []InboundServiceType `protobuf:"varint,6,rep,packed,name=inbound_services,json=inboundServices,enum=google.appengine.v1.InboundServiceType" json:"inbound_services,omitempty"`
	// Instance class that is used to run this version. Valid values are:
	// * AutomaticScaling: `F1`, `F2`, `F4`, `F4_1G`
	// * ManualScaling or BasicScaling: `B1`, `B2`, `B4`, `B8`, `B4_1G`
	//
	// Defaults to `F1` for AutomaticScaling and `B1` for ManualScaling or
	// BasicScaling.
	InstanceClass string `protobuf:"bytes,7,opt,name=instance_class,json=instanceClass,proto3" json:"instance_class,omitempty"`
	// Extra network settings. Only applicable for VM runtimes.
	Network *Network `protobuf:"bytes,8,opt,name=network" json:"network,omitempty"`
	// Machine resources for this version. Only applicable for VM runtimes.
	Resources *Resources `protobuf:"bytes,9,opt,name=resources" json:"resources,omitempty"`
	// Desired runtime. Example: `python27`.
	Runtime string `protobuf:"bytes,10,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// Whether multiple requests can be dispatched to this version at once.
	Threadsafe bool `protobuf:"varint,11,opt,name=threadsafe,proto3" json:"threadsafe,omitempty"`
	// Whether to deploy this version in a container on a virtual machine.
	Vm bool `protobuf:"varint,12,opt,name=vm,proto3" json:"vm,omitempty"`
	// Metadata settings that are supplied to this version to enable
	// beta runtime features.
	BetaSettings map[string]string `protobuf:"bytes,13,rep,name=beta_settings,json=betaSettings" json:"beta_settings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// App Engine execution environment for this version.
	//
	// Defaults to `standard`.
	Env string `protobuf:"bytes,14,opt,name=env,proto3" json:"env,omitempty"`
	// Current serving status of this version. Only the versions with a
	// `SERVING` status create instances and can be billed.
	//
	// `SERVING_STATUS_UNSPECIFIED` is an invalid value. Defaults to `SERVING`.
	ServingStatus ServingStatus `protobuf:"varint,15,opt,name=serving_status,json=servingStatus,proto3,enum=google.appengine.v1.ServingStatus" json:"serving_status,omitempty"`
	// Email address of the user who created this version.
	//
	// @OutputOnly
	CreatedBy string `protobuf:"bytes,16,opt,name=created_by,json=createdBy,proto3" json:"created_by,omitempty"`
	// Time that this version was created.
	//
	// @OutputOnly
	CreateTime *google_protobuf2.Timestamp `protobuf:"bytes,17,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Total size in bytes of all the files that are included in this version
	// and curerntly hosted on the App Engine disk.
	//
	// @OutputOnly
	DiskUsageBytes int64 `protobuf:"varint,18,opt,name=disk_usage_bytes,json=diskUsageBytes,proto3" json:"disk_usage_bytes,omitempty"`
	// An ordered list of URL-matching patterns that should be applied to incoming
	// requests. The first matching URL handles the request and other request
	// handlers are not attempted.
	//
	// Only returned in `GET` requests if `view=FULL` is set.
	Handlers []*UrlMap `protobuf:"bytes,100,rep,name=handlers" json:"handlers,omitempty"`
	// Custom static error pages. Limited to 10KB per page.
	//
	// Only returned in `GET` requests if `view=FULL` is set.
	ErrorHandlers []*ErrorHandler `protobuf:"bytes,101,rep,name=error_handlers,json=errorHandlers" json:"error_handlers,omitempty"`
	// Configuration for third-party Python runtime libraries that are required
	// by the application.
	//
	// Only returned in `GET` requests if `view=FULL` is set.
	Libraries []*Library `protobuf:"bytes,102,rep,name=libraries" json:"libraries,omitempty"`
	// Serving configuration for
	// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/).
	//
	// Only returned in `GET` requests if `view=FULL` is set.
	ApiConfig *ApiConfigHandler `protobuf:"bytes,103,opt,name=api_config,json=apiConfig" json:"api_config,omitempty"`
	// Environment variables available to the application.
	//
	// Only returned in `GET` requests if `view=FULL` is set.
	EnvVariables map[string]string `protobuf:"bytes,104,rep,name=env_variables,json=envVariables" json:"env_variables,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Duration that static files should be cached by web proxies and browsers.
	// Only applicable if the corresponding
	// [StaticFilesHandler](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions#staticfileshandler)
	// does not specify its own expiration time.
	//
	// Only returned in `GET` requests if `view=FULL` is set.
	DefaultExpiration *google_protobuf1.Duration `protobuf:"bytes,105,opt,name=default_expiration,json=defaultExpiration" json:"default_expiration,omitempty"`
	// Configures health checking for VM instances. Unhealthy instances are
	// stopped and replaced with new instances. Only applicable for VM
	// runtimes.
	//
	// Only returned in `GET` requests if `view=FULL` is set.
	HealthCheck *HealthCheck `protobuf:"bytes,106,opt,name=health_check,json=healthCheck" json:"health_check,omitempty"`
	// Files that match this pattern will not be built into this version.
	// Only applicable for Go runtimes.
	//
	// Only returned in `GET` requests if `view=FULL` is set.
	NobuildFilesRegex string `protobuf:"bytes,107,opt,name=nobuild_files_regex,json=nobuildFilesRegex,proto3" json:"nobuild_files_regex,omitempty"`
	// Code and application artifacts that make up this version.
	//
	// Only returned in `GET` requests if `view=FULL` is set.
	Deployment *Deployment `protobuf:"bytes,108,opt,name=deployment" json:"deployment,omitempty"`
	// Serving URL for this version. Example:
	// "https://myversion-dot-myservice-dot-myapp.appspot.com"
	//
	// @OutputOnly
	VersionUrl string `protobuf:"bytes,109,opt,name=version_url,json=versionUrl,proto3" json:"version_url,omitempty"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{0} }

type isVersion_Scaling interface {
	isVersion_Scaling()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Version_AutomaticScaling struct {
	AutomaticScaling *AutomaticScaling `protobuf:"bytes,3,opt,name=automatic_scaling,json=automaticScaling,oneof"`
}
type Version_BasicScaling struct {
	BasicScaling *BasicScaling `protobuf:"bytes,4,opt,name=basic_scaling,json=basicScaling,oneof"`
}
type Version_ManualScaling struct {
	ManualScaling *ManualScaling `protobuf:"bytes,5,opt,name=manual_scaling,json=manualScaling,oneof"`
}

func (*Version_AutomaticScaling) isVersion_Scaling() {}
func (*Version_BasicScaling) isVersion_Scaling()     {}
func (*Version_ManualScaling) isVersion_Scaling()    {}

func (m *Version) GetScaling() isVersion_Scaling {
	if m != nil {
		return m.Scaling
	}
	return nil
}

func (m *Version) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Version) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Version) GetAutomaticScaling() *AutomaticScaling {
	if x, ok := m.GetScaling().(*Version_AutomaticScaling); ok {
		return x.AutomaticScaling
	}
	return nil
}

func (m *Version) GetBasicScaling() *BasicScaling {
	if x, ok := m.GetScaling().(*Version_BasicScaling); ok {
		return x.BasicScaling
	}
	return nil
}

func (m *Version) GetManualScaling() *ManualScaling {
	if x, ok := m.GetScaling().(*Version_ManualScaling); ok {
		return x.ManualScaling
	}
	return nil
}

func (m *Version) GetInboundServices() []InboundServiceType {
	if m != nil {
		return m.InboundServices
	}
	return nil
}

func (m *Version) GetInstanceClass() string {
	if m != nil {
		return m.InstanceClass
	}
	return ""
}

func (m *Version) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *Version) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Version) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *Version) GetThreadsafe() bool {
	if m != nil {
		return m.Threadsafe
	}
	return false
}

func (m *Version) GetVm() bool {
	if m != nil {
		return m.Vm
	}
	return false
}

func (m *Version) GetBetaSettings() map[string]string {
	if m != nil {
		return m.BetaSettings
	}
	return nil
}

func (m *Version) GetEnv() string {
	if m != nil {
		return m.Env
	}
	return ""
}

func (m *Version) GetServingStatus() ServingStatus {
	if m != nil {
		return m.ServingStatus
	}
	return ServingStatus_SERVING_STATUS_UNSPECIFIED
}

func (m *Version) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *Version) GetCreateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Version) GetDiskUsageBytes() int64 {
	if m != nil {
		return m.DiskUsageBytes
	}
	return 0
}

func (m *Version) GetHandlers() []*UrlMap {
	if m != nil {
		return m.Handlers
	}
	return nil
}

func (m *Version) GetErrorHandlers() []*ErrorHandler {
	if m != nil {
		return m.ErrorHandlers
	}
	return nil
}

func (m *Version) GetLibraries() []*Library {
	if m != nil {
		return m.Libraries
	}
	return nil
}

func (m *Version) GetApiConfig() *ApiConfigHandler {
	if m != nil {
		return m.ApiConfig
	}
	return nil
}

func (m *Version) GetEnvVariables() map[string]string {
	if m != nil {
		return m.EnvVariables
	}
	return nil
}

func (m *Version) GetDefaultExpiration() *google_protobuf1.Duration {
	if m != nil {
		return m.DefaultExpiration
	}
	return nil
}

func (m *Version) GetHealthCheck() *HealthCheck {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

func (m *Version) GetNobuildFilesRegex() string {
	if m != nil {
		return m.NobuildFilesRegex
	}
	return ""
}

func (m *Version) GetDeployment() *Deployment {
	if m != nil {
		return m.Deployment
	}
	return nil
}

func (m *Version) GetVersionUrl() string {
	if m != nil {
		return m.VersionUrl
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Version) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Version_OneofMarshaler, _Version_OneofUnmarshaler, _Version_OneofSizer, []interface{}{
		(*Version_AutomaticScaling)(nil),
		(*Version_BasicScaling)(nil),
		(*Version_ManualScaling)(nil),
	}
}

func _Version_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Version)
	// scaling
	switch x := m.Scaling.(type) {
	case *Version_AutomaticScaling:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AutomaticScaling); err != nil {
			return err
		}
	case *Version_BasicScaling:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BasicScaling); err != nil {
			return err
		}
	case *Version_ManualScaling:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ManualScaling); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Version.Scaling has unexpected type %T", x)
	}
	return nil
}

func _Version_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Version)
	switch tag {
	case 3: // scaling.automatic_scaling
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AutomaticScaling)
		err := b.DecodeMessage(msg)
		m.Scaling = &Version_AutomaticScaling{msg}
		return true, err
	case 4: // scaling.basic_scaling
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BasicScaling)
		err := b.DecodeMessage(msg)
		m.Scaling = &Version_BasicScaling{msg}
		return true, err
	case 5: // scaling.manual_scaling
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ManualScaling)
		err := b.DecodeMessage(msg)
		m.Scaling = &Version_ManualScaling{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Version_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Version)
	// scaling
	switch x := m.Scaling.(type) {
	case *Version_AutomaticScaling:
		s := proto.Size(x.AutomaticScaling)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Version_BasicScaling:
		s := proto.Size(x.BasicScaling)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Version_ManualScaling:
		s := proto.Size(x.ManualScaling)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Automatic scaling is based on request rate, response latencies, and other
// application metrics.
type AutomaticScaling struct {
	// Amount of time that the
	// [Autoscaler](https://cloud.google.com/compute/docs/autoscaler/)
	// should wait between changes to the number of virtual machines.
	// Only applicable for VM runtimes.
	CoolDownPeriod *google_protobuf1.Duration `protobuf:"bytes,1,opt,name=cool_down_period,json=coolDownPeriod" json:"cool_down_period,omitempty"`
	// Target scaling by CPU usage.
	CpuUtilization *CpuUtilization `protobuf:"bytes,2,opt,name=cpu_utilization,json=cpuUtilization" json:"cpu_utilization,omitempty"`
	// Number of concurrent requests an automatic scaling instance can accept
	// before the scheduler spawns a new instance.
	//
	// Defaults to a runtime-specific value.
	MaxConcurrentRequests int32 `protobuf:"varint,3,opt,name=max_concurrent_requests,json=maxConcurrentRequests,proto3" json:"max_concurrent_requests,omitempty"`
	// Maximum number of idle instances that should be maintained for this
	// version.
	MaxIdleInstances int32 `protobuf:"varint,4,opt,name=max_idle_instances,json=maxIdleInstances,proto3" json:"max_idle_instances,omitempty"`
	// Maximum number of instances that should be started to handle requests.
	MaxTotalInstances int32 `protobuf:"varint,5,opt,name=max_total_instances,json=maxTotalInstances,proto3" json:"max_total_instances,omitempty"`
	// Maximum amount of time that a request should wait in the pending queue
	// before starting a new instance to handle it.
	MaxPendingLatency *google_protobuf1.Duration `protobuf:"bytes,6,opt,name=max_pending_latency,json=maxPendingLatency" json:"max_pending_latency,omitempty"`
	// Minimum number of idle instances that should be maintained for
	// this version. Only applicable for the default version of a service.
	MinIdleInstances int32 `protobuf:"varint,7,opt,name=min_idle_instances,json=minIdleInstances,proto3" json:"min_idle_instances,omitempty"`
	// Minimum number of instances that should be maintained for this version.
	MinTotalInstances int32 `protobuf:"varint,8,opt,name=min_total_instances,json=minTotalInstances,proto3" json:"min_total_instances,omitempty"`
	// Minimum amount of time a request should wait in the pending queue before
	// starting a new instance to handle it.
	MinPendingLatency *google_protobuf1.Duration `protobuf:"bytes,9,opt,name=min_pending_latency,json=minPendingLatency" json:"min_pending_latency,omitempty"`
	// Target scaling by request utilization.
	RequestUtilization *RequestUtilization `protobuf:"bytes,10,opt,name=request_utilization,json=requestUtilization" json:"request_utilization,omitempty"`
	// Target scaling by disk usage.
	DiskUtilization *DiskUtilization `protobuf:"bytes,11,opt,name=disk_utilization,json=diskUtilization" json:"disk_utilization,omitempty"`
	// Target scaling by network usage.
	NetworkUtilization *NetworkUtilization `protobuf:"bytes,12,opt,name=network_utilization,json=networkUtilization" json:"network_utilization,omitempty"`
}

func (m *AutomaticScaling) Reset()                    { *m = AutomaticScaling{} }
func (m *AutomaticScaling) String() string            { return proto.CompactTextString(m) }
func (*AutomaticScaling) ProtoMessage()               {}
func (*AutomaticScaling) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{1} }

func (m *AutomaticScaling) GetCoolDownPeriod() *google_protobuf1.Duration {
	if m != nil {
		return m.CoolDownPeriod
	}
	return nil
}

func (m *AutomaticScaling) GetCpuUtilization() *CpuUtilization {
	if m != nil {
		return m.CpuUtilization
	}
	return nil
}

func (m *AutomaticScaling) GetMaxConcurrentRequests() int32 {
	if m != nil {
		return m.MaxConcurrentRequests
	}
	return 0
}

func (m *AutomaticScaling) GetMaxIdleInstances() int32 {
	if m != nil {
		return m.MaxIdleInstances
	}
	return 0
}

func (m *AutomaticScaling) GetMaxTotalInstances() int32 {
	if m != nil {
		return m.MaxTotalInstances
	}
	return 0
}

func (m *AutomaticScaling) GetMaxPendingLatency() *google_protobuf1.Duration {
	if m != nil {
		return m.MaxPendingLatency
	}
	return nil
}

func (m *AutomaticScaling) GetMinIdleInstances() int32 {
	if m != nil {
		return m.MinIdleInstances
	}
	return 0
}

func (m *AutomaticScaling) GetMinTotalInstances() int32 {
	if m != nil {
		return m.MinTotalInstances
	}
	return 0
}

func (m *AutomaticScaling) GetMinPendingLatency() *google_protobuf1.Duration {
	if m != nil {
		return m.MinPendingLatency
	}
	return nil
}

func (m *AutomaticScaling) GetRequestUtilization() *RequestUtilization {
	if m != nil {
		return m.RequestUtilization
	}
	return nil
}

func (m *AutomaticScaling) GetDiskUtilization() *DiskUtilization {
	if m != nil {
		return m.DiskUtilization
	}
	return nil
}

func (m *AutomaticScaling) GetNetworkUtilization() *NetworkUtilization {
	if m != nil {
		return m.NetworkUtilization
	}
	return nil
}

// A service with basic scaling will create an instance when the application
// receives a request. The instance will be turned down when the app becomes
// idle. Basic scaling is ideal for work that is intermittent or driven by
// user activity.
type BasicScaling struct {
	// Duration of time after the last request that an instance must wait before
	// the instance is shut down.
	IdleTimeout *google_protobuf1.Duration `protobuf:"bytes,1,opt,name=idle_timeout,json=idleTimeout" json:"idle_timeout,omitempty"`
	// Maximum number of instances to create for this version.
	MaxInstances int32 `protobuf:"varint,2,opt,name=max_instances,json=maxInstances,proto3" json:"max_instances,omitempty"`
}

func (m *BasicScaling) Reset()                    { *m = BasicScaling{} }
func (m *BasicScaling) String() string            { return proto.CompactTextString(m) }
func (*BasicScaling) ProtoMessage()               {}
func (*BasicScaling) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{2} }

func (m *BasicScaling) GetIdleTimeout() *google_protobuf1.Duration {
	if m != nil {
		return m.IdleTimeout
	}
	return nil
}

func (m *BasicScaling) GetMaxInstances() int32 {
	if m != nil {
		return m.MaxInstances
	}
	return 0
}

// A service with manual scaling runs continuously, allowing you to perform
// complex initialization and rely on the state of its memory over time.
type ManualScaling struct {
	// Number of instances to assign to the service at the start. This number
	// can later be altered by using the
	// [Modules API](https://cloud.google.com/appengine/docs/python/modules/functions)
	// `set_num_instances()` function.
	Instances int32 `protobuf:"varint,1,opt,name=instances,proto3" json:"instances,omitempty"`
}

func (m *ManualScaling) Reset()                    { *m = ManualScaling{} }
func (m *ManualScaling) String() string            { return proto.CompactTextString(m) }
func (*ManualScaling) ProtoMessage()               {}
func (*ManualScaling) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{3} }

func (m *ManualScaling) GetInstances() int32 {
	if m != nil {
		return m.Instances
	}
	return 0
}

// Target scaling by CPU usage.
type CpuUtilization struct {
	// Period of time over which CPU utilization is calculated.
	AggregationWindowLength *google_protobuf1.Duration `protobuf:"bytes,1,opt,name=aggregation_window_length,json=aggregationWindowLength" json:"aggregation_window_length,omitempty"`
	// Target CPU utilization ratio to maintain when scaling. Must be between 0
	// and 1.
	TargetUtilization float64 `protobuf:"fixed64,2,opt,name=target_utilization,json=targetUtilization,proto3" json:"target_utilization,omitempty"`
}

func (m *CpuUtilization) Reset()                    { *m = CpuUtilization{} }
func (m *CpuUtilization) String() string            { return proto.CompactTextString(m) }
func (*CpuUtilization) ProtoMessage()               {}
func (*CpuUtilization) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{4} }

func (m *CpuUtilization) GetAggregationWindowLength() *google_protobuf1.Duration {
	if m != nil {
		return m.AggregationWindowLength
	}
	return nil
}

func (m *CpuUtilization) GetTargetUtilization() float64 {
	if m != nil {
		return m.TargetUtilization
	}
	return 0
}

// Target scaling by request utilization. Only applicable for VM runtimes.
type RequestUtilization struct {
	// Target requests per second.
	TargetRequestCountPerSecond int32 `protobuf:"varint,1,opt,name=target_request_count_per_second,json=targetRequestCountPerSecond,proto3" json:"target_request_count_per_second,omitempty"`
	// Target number of concurrent requests.
	TargetConcurrentRequests int32 `protobuf:"varint,2,opt,name=target_concurrent_requests,json=targetConcurrentRequests,proto3" json:"target_concurrent_requests,omitempty"`
}

func (m *RequestUtilization) Reset()                    { *m = RequestUtilization{} }
func (m *RequestUtilization) String() string            { return proto.CompactTextString(m) }
func (*RequestUtilization) ProtoMessage()               {}
func (*RequestUtilization) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{5} }

func (m *RequestUtilization) GetTargetRequestCountPerSecond() int32 {
	if m != nil {
		return m.TargetRequestCountPerSecond
	}
	return 0
}

func (m *RequestUtilization) GetTargetConcurrentRequests() int32 {
	if m != nil {
		return m.TargetConcurrentRequests
	}
	return 0
}

// Target scaling by disk usage. Only applicable for VM runtimes.
type DiskUtilization struct {
	// Target bytes written per second.
	TargetWriteBytesPerSecond int32 `protobuf:"varint,14,opt,name=target_write_bytes_per_second,json=targetWriteBytesPerSecond,proto3" json:"target_write_bytes_per_second,omitempty"`
	// Target ops written per second.
	TargetWriteOpsPerSecond int32 `protobuf:"varint,15,opt,name=target_write_ops_per_second,json=targetWriteOpsPerSecond,proto3" json:"target_write_ops_per_second,omitempty"`
	// Target bytes read per second.
	TargetReadBytesPerSecond int32 `protobuf:"varint,16,opt,name=target_read_bytes_per_second,json=targetReadBytesPerSecond,proto3" json:"target_read_bytes_per_second,omitempty"`
	// Target ops read per seconds.
	TargetReadOpsPerSecond int32 `protobuf:"varint,17,opt,name=target_read_ops_per_second,json=targetReadOpsPerSecond,proto3" json:"target_read_ops_per_second,omitempty"`
}

func (m *DiskUtilization) Reset()                    { *m = DiskUtilization{} }
func (m *DiskUtilization) String() string            { return proto.CompactTextString(m) }
func (*DiskUtilization) ProtoMessage()               {}
func (*DiskUtilization) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{6} }

func (m *DiskUtilization) GetTargetWriteBytesPerSecond() int32 {
	if m != nil {
		return m.TargetWriteBytesPerSecond
	}
	return 0
}

func (m *DiskUtilization) GetTargetWriteOpsPerSecond() int32 {
	if m != nil {
		return m.TargetWriteOpsPerSecond
	}
	return 0
}

func (m *DiskUtilization) GetTargetReadBytesPerSecond() int32 {
	if m != nil {
		return m.TargetReadBytesPerSecond
	}
	return 0
}

func (m *DiskUtilization) GetTargetReadOpsPerSecond() int32 {
	if m != nil {
		return m.TargetReadOpsPerSecond
	}
	return 0
}

// Target scaling by network usage. Only applicable for VM runtimes.
type NetworkUtilization struct {
	// Target bytes sent per second.
	TargetSentBytesPerSecond int32 `protobuf:"varint,1,opt,name=target_sent_bytes_per_second,json=targetSentBytesPerSecond,proto3" json:"target_sent_bytes_per_second,omitempty"`
	// Target packets sent per second.
	TargetSentPacketsPerSecond int32 `protobuf:"varint,11,opt,name=target_sent_packets_per_second,json=targetSentPacketsPerSecond,proto3" json:"target_sent_packets_per_second,omitempty"`
	// Target bytes received per second.
	TargetReceivedBytesPerSecond int32 `protobuf:"varint,12,opt,name=target_received_bytes_per_second,json=targetReceivedBytesPerSecond,proto3" json:"target_received_bytes_per_second,omitempty"`
	// Target packets received per second.
	TargetReceivedPacketsPerSecond int32 `protobuf:"varint,13,opt,name=target_received_packets_per_second,json=targetReceivedPacketsPerSecond,proto3" json:"target_received_packets_per_second,omitempty"`
}

func (m *NetworkUtilization) Reset()                    { *m = NetworkUtilization{} }
func (m *NetworkUtilization) String() string            { return proto.CompactTextString(m) }
func (*NetworkUtilization) ProtoMessage()               {}
func (*NetworkUtilization) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{7} }

func (m *NetworkUtilization) GetTargetSentBytesPerSecond() int32 {
	if m != nil {
		return m.TargetSentBytesPerSecond
	}
	return 0
}

func (m *NetworkUtilization) GetTargetSentPacketsPerSecond() int32 {
	if m != nil {
		return m.TargetSentPacketsPerSecond
	}
	return 0
}

func (m *NetworkUtilization) GetTargetReceivedBytesPerSecond() int32 {
	if m != nil {
		return m.TargetReceivedBytesPerSecond
	}
	return 0
}

func (m *NetworkUtilization) GetTargetReceivedPacketsPerSecond() int32 {
	if m != nil {
		return m.TargetReceivedPacketsPerSecond
	}
	return 0
}

// Extra network settings. Only applicable for VM runtimes.
type Network struct {
	// List of ports, or port pairs, to forward from the virtual machine to the
	// application container.
	ForwardedPorts []string `protobuf:"bytes,1,rep,name=forwarded_ports,json=forwardedPorts" json:"forwarded_ports,omitempty"`
	// Tag to apply to the VM instance during creation.
	InstanceTag string `protobuf:"bytes,2,opt,name=instance_tag,json=instanceTag,proto3" json:"instance_tag,omitempty"`
	// Google Cloud Platform network where the virtual machines are created.
	// Specify the short name, not the resource path.
	//
	// Defaults to `default`.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{8} }

func (m *Network) GetForwardedPorts() []string {
	if m != nil {
		return m.ForwardedPorts
	}
	return nil
}

func (m *Network) GetInstanceTag() string {
	if m != nil {
		return m.InstanceTag
	}
	return ""
}

func (m *Network) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Machine resources for a version.
type Resources struct {
	// Number of CPU cores needed.
	Cpu float64 `protobuf:"fixed64,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// Disk size (GB) needed.
	DiskGb float64 `protobuf:"fixed64,2,opt,name=disk_gb,json=diskGb,proto3" json:"disk_gb,omitempty"`
	// Memory (GB) needed.
	MemoryGb float64 `protobuf:"fixed64,3,opt,name=memory_gb,json=memoryGb,proto3" json:"memory_gb,omitempty"`
}

func (m *Resources) Reset()                    { *m = Resources{} }
func (m *Resources) String() string            { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()               {}
func (*Resources) Descriptor() ([]byte, []int) { return fileDescriptorVersion, []int{9} }

func (m *Resources) GetCpu() float64 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *Resources) GetDiskGb() float64 {
	if m != nil {
		return m.DiskGb
	}
	return 0
}

func (m *Resources) GetMemoryGb() float64 {
	if m != nil {
		return m.MemoryGb
	}
	return 0
}

func init() {
	proto.RegisterType((*Version)(nil), "google.appengine.v1.Version")
	proto.RegisterType((*AutomaticScaling)(nil), "google.appengine.v1.AutomaticScaling")
	proto.RegisterType((*BasicScaling)(nil), "google.appengine.v1.BasicScaling")
	proto.RegisterType((*ManualScaling)(nil), "google.appengine.v1.ManualScaling")
	proto.RegisterType((*CpuUtilization)(nil), "google.appengine.v1.CpuUtilization")
	proto.RegisterType((*RequestUtilization)(nil), "google.appengine.v1.RequestUtilization")
	proto.RegisterType((*DiskUtilization)(nil), "google.appengine.v1.DiskUtilization")
	proto.RegisterType((*NetworkUtilization)(nil), "google.appengine.v1.NetworkUtilization")
	proto.RegisterType((*Network)(nil), "google.appengine.v1.Network")
	proto.RegisterType((*Resources)(nil), "google.appengine.v1.Resources")
	proto.RegisterEnum("google.appengine.v1.InboundServiceType", InboundServiceType_name, InboundServiceType_value)
	proto.RegisterEnum("google.appengine.v1.ServingStatus", ServingStatus_name, ServingStatus_value)
}
func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Scaling != nil {
		nn1, err := m.Scaling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if len(m.InboundServices) > 0 {
		dAtA3 := make([]byte, len(m.InboundServices)*10)
		var j2 int
		for _, num := range m.InboundServices {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintVersion(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.InstanceClass) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.InstanceClass)))
		i += copy(dAtA[i:], m.InstanceClass)
	}
	if m.Network != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.Network.Size()))
		n4, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Resources != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.Resources.Size()))
		n5, err := m.Resources.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Runtime) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.Runtime)))
		i += copy(dAtA[i:], m.Runtime)
	}
	if m.Threadsafe {
		dAtA[i] = 0x58
		i++
		if m.Threadsafe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Vm {
		dAtA[i] = 0x60
		i++
		if m.Vm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.BetaSettings) > 0 {
		for k, _ := range m.BetaSettings {
			dAtA[i] = 0x6a
			i++
			v := m.BetaSettings[k]
			mapSize := 1 + len(k) + sovVersion(uint64(len(k))) + 1 + len(v) + sovVersion(uint64(len(v)))
			i = encodeVarintVersion(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintVersion(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintVersion(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if m.ServingStatus != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.ServingStatus))
	}
	if len(m.CreatedBy) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.CreatedBy)))
		i += copy(dAtA[i:], m.CreatedBy)
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.CreateTime.Size()))
		n6, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.DiskUsageBytes != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.DiskUsageBytes))
	}
	if len(m.Handlers) > 0 {
		for _, msg := range m.Handlers {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintVersion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ErrorHandlers) > 0 {
		for _, msg := range m.ErrorHandlers {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintVersion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Libraries) > 0 {
		for _, msg := range m.Libraries {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x6
			i++
			i = encodeVarintVersion(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ApiConfig != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.ApiConfig.Size()))
		n7, err := m.ApiConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.EnvVariables) > 0 {
		for k, _ := range m.EnvVariables {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x6
			i++
			v := m.EnvVariables[k]
			mapSize := 1 + len(k) + sovVersion(uint64(len(k))) + 1 + len(v) + sovVersion(uint64(len(v)))
			i = encodeVarintVersion(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintVersion(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintVersion(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.DefaultExpiration != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.DefaultExpiration.Size()))
		n8, err := m.DefaultExpiration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.HealthCheck != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.HealthCheck.Size()))
		n9, err := m.HealthCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.NobuildFilesRegex) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.NobuildFilesRegex)))
		i += copy(dAtA[i:], m.NobuildFilesRegex)
	}
	if m.Deployment != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.Deployment.Size()))
		n10, err := m.Deployment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.VersionUrl) > 0 {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.VersionUrl)))
		i += copy(dAtA[i:], m.VersionUrl)
	}
	return i, nil
}

func (m *Version_AutomaticScaling) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AutomaticScaling != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.AutomaticScaling.Size()))
		n11, err := m.AutomaticScaling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Version_BasicScaling) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BasicScaling != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.BasicScaling.Size()))
		n12, err := m.BasicScaling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Version_ManualScaling) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ManualScaling != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.ManualScaling.Size()))
		n13, err := m.ManualScaling.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *AutomaticScaling) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutomaticScaling) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CoolDownPeriod != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.CoolDownPeriod.Size()))
		n14, err := m.CoolDownPeriod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.CpuUtilization != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.CpuUtilization.Size()))
		n15, err := m.CpuUtilization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.MaxConcurrentRequests != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.MaxConcurrentRequests))
	}
	if m.MaxIdleInstances != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.MaxIdleInstances))
	}
	if m.MaxTotalInstances != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.MaxTotalInstances))
	}
	if m.MaxPendingLatency != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.MaxPendingLatency.Size()))
		n16, err := m.MaxPendingLatency.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.MinIdleInstances != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.MinIdleInstances))
	}
	if m.MinTotalInstances != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.MinTotalInstances))
	}
	if m.MinPendingLatency != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.MinPendingLatency.Size()))
		n17, err := m.MinPendingLatency.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.RequestUtilization != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.RequestUtilization.Size()))
		n18, err := m.RequestUtilization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.DiskUtilization != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.DiskUtilization.Size()))
		n19, err := m.DiskUtilization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.NetworkUtilization != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.NetworkUtilization.Size()))
		n20, err := m.NetworkUtilization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *BasicScaling) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicScaling) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdleTimeout != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.IdleTimeout.Size()))
		n21, err := m.IdleTimeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.MaxInstances != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.MaxInstances))
	}
	return i, nil
}

func (m *ManualScaling) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualScaling) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Instances != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.Instances))
	}
	return i, nil
}

func (m *CpuUtilization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuUtilization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AggregationWindowLength != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.AggregationWindowLength.Size()))
		n22, err := m.AggregationWindowLength.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.TargetUtilization != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Version(dAtA, i, uint64(math.Float64bits(float64(m.TargetUtilization))))
	}
	return i, nil
}

func (m *RequestUtilization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestUtilization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetRequestCountPerSecond != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetRequestCountPerSecond))
	}
	if m.TargetConcurrentRequests != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetConcurrentRequests))
	}
	return i, nil
}

func (m *DiskUtilization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskUtilization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetWriteBytesPerSecond != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetWriteBytesPerSecond))
	}
	if m.TargetWriteOpsPerSecond != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetWriteOpsPerSecond))
	}
	if m.TargetReadBytesPerSecond != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetReadBytesPerSecond))
	}
	if m.TargetReadOpsPerSecond != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetReadOpsPerSecond))
	}
	return i, nil
}

func (m *NetworkUtilization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkUtilization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TargetSentBytesPerSecond != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetSentBytesPerSecond))
	}
	if m.TargetSentPacketsPerSecond != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetSentPacketsPerSecond))
	}
	if m.TargetReceivedBytesPerSecond != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetReceivedBytesPerSecond))
	}
	if m.TargetReceivedPacketsPerSecond != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVersion(dAtA, i, uint64(m.TargetReceivedPacketsPerSecond))
	}
	return i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ForwardedPorts) > 0 {
		for _, s := range m.ForwardedPorts {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.InstanceTag) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.InstanceTag)))
		i += copy(dAtA[i:], m.InstanceTag)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVersion(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Resources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resources) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cpu != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Version(dAtA, i, uint64(math.Float64bits(float64(m.Cpu))))
	}
	if m.DiskGb != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Version(dAtA, i, uint64(math.Float64bits(float64(m.DiskGb))))
	}
	if m.MemoryGb != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Version(dAtA, i, uint64(math.Float64bits(float64(m.MemoryGb))))
	}
	return i, nil
}

func encodeFixed64Version(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Version(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintVersion(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Version) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVersion(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.Scaling != nil {
		n += m.Scaling.Size()
	}
	if len(m.InboundServices) > 0 {
		l = 0
		for _, e := range m.InboundServices {
			l += sovVersion(uint64(e))
		}
		n += 1 + sovVersion(uint64(l)) + l
	}
	l = len(m.InstanceClass)
	if l > 0 {
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	l = len(m.Runtime)
	if l > 0 {
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.Threadsafe {
		n += 2
	}
	if m.Vm {
		n += 2
	}
	if len(m.BetaSettings) > 0 {
		for k, v := range m.BetaSettings {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovVersion(uint64(len(k))) + 1 + len(v) + sovVersion(uint64(len(v)))
			n += mapEntrySize + 1 + sovVersion(uint64(mapEntrySize))
		}
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.ServingStatus != 0 {
		n += 1 + sovVersion(uint64(m.ServingStatus))
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 2 + l + sovVersion(uint64(l))
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 2 + l + sovVersion(uint64(l))
	}
	if m.DiskUsageBytes != 0 {
		n += 2 + sovVersion(uint64(m.DiskUsageBytes))
	}
	if len(m.Handlers) > 0 {
		for _, e := range m.Handlers {
			l = e.Size()
			n += 2 + l + sovVersion(uint64(l))
		}
	}
	if len(m.ErrorHandlers) > 0 {
		for _, e := range m.ErrorHandlers {
			l = e.Size()
			n += 2 + l + sovVersion(uint64(l))
		}
	}
	if len(m.Libraries) > 0 {
		for _, e := range m.Libraries {
			l = e.Size()
			n += 2 + l + sovVersion(uint64(l))
		}
	}
	if m.ApiConfig != nil {
		l = m.ApiConfig.Size()
		n += 2 + l + sovVersion(uint64(l))
	}
	if len(m.EnvVariables) > 0 {
		for k, v := range m.EnvVariables {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovVersion(uint64(len(k))) + 1 + len(v) + sovVersion(uint64(len(v)))
			n += mapEntrySize + 2 + sovVersion(uint64(mapEntrySize))
		}
	}
	if m.DefaultExpiration != nil {
		l = m.DefaultExpiration.Size()
		n += 2 + l + sovVersion(uint64(l))
	}
	if m.HealthCheck != nil {
		l = m.HealthCheck.Size()
		n += 2 + l + sovVersion(uint64(l))
	}
	l = len(m.NobuildFilesRegex)
	if l > 0 {
		n += 2 + l + sovVersion(uint64(l))
	}
	if m.Deployment != nil {
		l = m.Deployment.Size()
		n += 2 + l + sovVersion(uint64(l))
	}
	l = len(m.VersionUrl)
	if l > 0 {
		n += 2 + l + sovVersion(uint64(l))
	}
	return n
}

func (m *Version_AutomaticScaling) Size() (n int) {
	var l int
	_ = l
	if m.AutomaticScaling != nil {
		l = m.AutomaticScaling.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	return n
}
func (m *Version_BasicScaling) Size() (n int) {
	var l int
	_ = l
	if m.BasicScaling != nil {
		l = m.BasicScaling.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	return n
}
func (m *Version_ManualScaling) Size() (n int) {
	var l int
	_ = l
	if m.ManualScaling != nil {
		l = m.ManualScaling.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	return n
}
func (m *AutomaticScaling) Size() (n int) {
	var l int
	_ = l
	if m.CoolDownPeriod != nil {
		l = m.CoolDownPeriod.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.CpuUtilization != nil {
		l = m.CpuUtilization.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.MaxConcurrentRequests != 0 {
		n += 1 + sovVersion(uint64(m.MaxConcurrentRequests))
	}
	if m.MaxIdleInstances != 0 {
		n += 1 + sovVersion(uint64(m.MaxIdleInstances))
	}
	if m.MaxTotalInstances != 0 {
		n += 1 + sovVersion(uint64(m.MaxTotalInstances))
	}
	if m.MaxPendingLatency != nil {
		l = m.MaxPendingLatency.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.MinIdleInstances != 0 {
		n += 1 + sovVersion(uint64(m.MinIdleInstances))
	}
	if m.MinTotalInstances != 0 {
		n += 1 + sovVersion(uint64(m.MinTotalInstances))
	}
	if m.MinPendingLatency != nil {
		l = m.MinPendingLatency.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.RequestUtilization != nil {
		l = m.RequestUtilization.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.DiskUtilization != nil {
		l = m.DiskUtilization.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.NetworkUtilization != nil {
		l = m.NetworkUtilization.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	return n
}

func (m *BasicScaling) Size() (n int) {
	var l int
	_ = l
	if m.IdleTimeout != nil {
		l = m.IdleTimeout.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.MaxInstances != 0 {
		n += 1 + sovVersion(uint64(m.MaxInstances))
	}
	return n
}

func (m *ManualScaling) Size() (n int) {
	var l int
	_ = l
	if m.Instances != 0 {
		n += 1 + sovVersion(uint64(m.Instances))
	}
	return n
}

func (m *CpuUtilization) Size() (n int) {
	var l int
	_ = l
	if m.AggregationWindowLength != nil {
		l = m.AggregationWindowLength.Size()
		n += 1 + l + sovVersion(uint64(l))
	}
	if m.TargetUtilization != 0 {
		n += 9
	}
	return n
}

func (m *RequestUtilization) Size() (n int) {
	var l int
	_ = l
	if m.TargetRequestCountPerSecond != 0 {
		n += 1 + sovVersion(uint64(m.TargetRequestCountPerSecond))
	}
	if m.TargetConcurrentRequests != 0 {
		n += 1 + sovVersion(uint64(m.TargetConcurrentRequests))
	}
	return n
}

func (m *DiskUtilization) Size() (n int) {
	var l int
	_ = l
	if m.TargetWriteBytesPerSecond != 0 {
		n += 1 + sovVersion(uint64(m.TargetWriteBytesPerSecond))
	}
	if m.TargetWriteOpsPerSecond != 0 {
		n += 1 + sovVersion(uint64(m.TargetWriteOpsPerSecond))
	}
	if m.TargetReadBytesPerSecond != 0 {
		n += 2 + sovVersion(uint64(m.TargetReadBytesPerSecond))
	}
	if m.TargetReadOpsPerSecond != 0 {
		n += 2 + sovVersion(uint64(m.TargetReadOpsPerSecond))
	}
	return n
}

func (m *NetworkUtilization) Size() (n int) {
	var l int
	_ = l
	if m.TargetSentBytesPerSecond != 0 {
		n += 1 + sovVersion(uint64(m.TargetSentBytesPerSecond))
	}
	if m.TargetSentPacketsPerSecond != 0 {
		n += 1 + sovVersion(uint64(m.TargetSentPacketsPerSecond))
	}
	if m.TargetReceivedBytesPerSecond != 0 {
		n += 1 + sovVersion(uint64(m.TargetReceivedBytesPerSecond))
	}
	if m.TargetReceivedPacketsPerSecond != 0 {
		n += 1 + sovVersion(uint64(m.TargetReceivedPacketsPerSecond))
	}
	return n
}

func (m *Network) Size() (n int) {
	var l int
	_ = l
	if len(m.ForwardedPorts) > 0 {
		for _, s := range m.ForwardedPorts {
			l = len(s)
			n += 1 + l + sovVersion(uint64(l))
		}
	}
	l = len(m.InstanceTag)
	if l > 0 {
		n += 1 + l + sovVersion(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVersion(uint64(l))
	}
	return n
}

func (m *Resources) Size() (n int) {
	var l int
	_ = l
	if m.Cpu != 0 {
		n += 9
	}
	if m.DiskGb != 0 {
		n += 9
	}
	if m.MemoryGb != 0 {
		n += 9
	}
	return n
}

func sovVersion(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVersion(x uint64) (n int) {
	return sovVersion(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticScaling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AutomaticScaling{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Scaling = &Version_AutomaticScaling{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicScaling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BasicScaling{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Scaling = &Version_BasicScaling{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualScaling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ManualScaling{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Scaling = &Version_ManualScaling{v}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v InboundServiceType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVersion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (InboundServiceType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InboundServices = append(m.InboundServices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVersion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVersion
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v InboundServiceType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVersion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (InboundServiceType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InboundServices = append(m.InboundServices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InboundServices", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &Resources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threadsafe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Threadsafe = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Vm = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetaSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BetaSettings == nil {
				m.BetaSettings = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVersion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVersion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVersion
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVersion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthVersion
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVersion(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVersion
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BetaSettings[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServingStatus", wireType)
			}
			m.ServingStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServingStatus |= (ServingStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf2.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUsageBytes", wireType)
			}
			m.DiskUsageBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskUsageBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handlers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handlers = append(m.Handlers, &UrlMap{})
			if err := m.Handlers[len(m.Handlers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorHandlers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorHandlers = append(m.ErrorHandlers, &ErrorHandler{})
			if err := m.ErrorHandlers[len(m.ErrorHandlers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Libraries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Libraries = append(m.Libraries, &Library{})
			if err := m.Libraries[len(m.Libraries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ApiConfig == nil {
				m.ApiConfig = &ApiConfigHandler{}
			}
			if err := m.ApiConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvVariables == nil {
				m.EnvVariables = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVersion
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVersion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVersion
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVersion
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthVersion
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVersion(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVersion
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvVariables[mapkey] = mapvalue
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultExpiration == nil {
				m.DefaultExpiration = &google_protobuf1.Duration{}
			}
			if err := m.DefaultExpiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthCheck == nil {
				m.HealthCheck = &HealthCheck{}
			}
			if err := m.HealthCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NobuildFilesRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NobuildFilesRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deployment == nil {
				m.Deployment = &Deployment{}
			}
			if err := m.Deployment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 109:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutomaticScaling) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutomaticScaling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutomaticScaling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoolDownPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoolDownPeriod == nil {
				m.CoolDownPeriod = &google_protobuf1.Duration{}
			}
			if err := m.CoolDownPeriod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUtilization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CpuUtilization == nil {
				m.CpuUtilization = &CpuUtilization{}
			}
			if err := m.CpuUtilization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConcurrentRequests", wireType)
			}
			m.MaxConcurrentRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConcurrentRequests |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxIdleInstances", wireType)
			}
			m.MaxIdleInstances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxIdleInstances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTotalInstances", wireType)
			}
			m.MaxTotalInstances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTotalInstances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPendingLatency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxPendingLatency == nil {
				m.MaxPendingLatency = &google_protobuf1.Duration{}
			}
			if err := m.MaxPendingLatency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinIdleInstances", wireType)
			}
			m.MinIdleInstances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinIdleInstances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTotalInstances", wireType)
			}
			m.MinTotalInstances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTotalInstances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPendingLatency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinPendingLatency == nil {
				m.MinPendingLatency = &google_protobuf1.Duration{}
			}
			if err := m.MinPendingLatency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestUtilization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestUtilization == nil {
				m.RequestUtilization = &RequestUtilization{}
			}
			if err := m.RequestUtilization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUtilization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiskUtilization == nil {
				m.DiskUtilization = &DiskUtilization{}
			}
			if err := m.DiskUtilization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkUtilization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkUtilization == nil {
				m.NetworkUtilization = &NetworkUtilization{}
			}
			if err := m.NetworkUtilization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicScaling) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicScaling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicScaling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdleTimeout == nil {
				m.IdleTimeout = &google_protobuf1.Duration{}
			}
			if err := m.IdleTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInstances", wireType)
			}
			m.MaxInstances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInstances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualScaling) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualScaling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualScaling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			m.Instances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Instances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuUtilization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuUtilization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuUtilization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationWindowLength", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AggregationWindowLength == nil {
				m.AggregationWindowLength = &google_protobuf1.Duration{}
			}
			if err := m.AggregationWindowLength.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.TargetUtilization = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestUtilization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestUtilization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestUtilization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetRequestCountPerSecond", wireType)
			}
			m.TargetRequestCountPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetRequestCountPerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetConcurrentRequests", wireType)
			}
			m.TargetConcurrentRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetConcurrentRequests |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskUtilization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskUtilization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskUtilization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetWriteBytesPerSecond", wireType)
			}
			m.TargetWriteBytesPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetWriteBytesPerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetWriteOpsPerSecond", wireType)
			}
			m.TargetWriteOpsPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetWriteOpsPerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReadBytesPerSecond", wireType)
			}
			m.TargetReadBytesPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetReadBytesPerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReadOpsPerSecond", wireType)
			}
			m.TargetReadOpsPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetReadOpsPerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkUtilization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkUtilization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkUtilization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSentBytesPerSecond", wireType)
			}
			m.TargetSentBytesPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetSentBytesPerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSentPacketsPerSecond", wireType)
			}
			m.TargetSentPacketsPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetSentPacketsPerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReceivedBytesPerSecond", wireType)
			}
			m.TargetReceivedBytesPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetReceivedBytesPerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReceivedPacketsPerSecond", wireType)
			}
			m.TargetReceivedPacketsPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetReceivedPacketsPerSecond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardedPorts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardedPorts = append(m.ForwardedPorts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVersion
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Cpu = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskGb", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.DiskGb = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGb", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MemoryGb = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipVersion(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVersion
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVersion(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVersion
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVersion
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthVersion
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVersion
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVersion(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVersion = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVersion   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/appengine/v1/version.proto", fileDescriptorVersion) }

var fileDescriptorVersion = []byte{
	// 1787 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0xdd, 0x72, 0xdb, 0xc6,
	0x15, 0x0e, 0x28, 0x4b, 0x14, 0x0f, 0x7f, 0x44, 0xad, 0xd3, 0x08, 0x96, 0x64, 0x8a, 0x66, 0x92,
	0xb1, 0x26, 0xd3, 0x50, 0x13, 0x77, 0x26, 0xed, 0x38, 0x9e, 0xa6, 0x22, 0x45, 0x5b, 0x6c, 0xf5,
	0xc3, 0x01, 0x49, 0x3b, 0xd3, 0x1b, 0xcc, 0x12, 0x58, 0x41, 0x5b, 0x01, 0x0b, 0x64, 0xb1, 0xa0,
	0xc4, 0xbe, 0x43, 0x2f, 0xdb, 0xe9, 0x43, 0xf4, 0xb2, 0x77, 0x7d, 0x81, 0x5e, 0xf6, 0x11, 0x3a,
	0x7e, 0x92, 0xce, 0x2e, 0x00, 0x12, 0x24, 0x11, 0xbb, 0xb9, 0xe3, 0x9e, 0xfd, 0xbe, 0x6f, 0x3f,
	0x9c, 0x3d, 0x7b, 0x16, 0x20, 0x3c, 0x73, 0x7c, 0xdf, 0x71, 0xc9, 0x09, 0x0e, 0x02, 0xc2, 0x1c,
	0xca, 0xc8, 0xc9, 0xf4, 0x9b, 0x93, 0x29, 0xe1, 0x21, 0xf5, 0x59, 0x3b, 0xe0, 0xbe, 0xf0, 0xd1,
	0xe3, 0x18, 0xd2, 0x9e, 0x43, 0xda, 0xd3, 0x6f, 0xf6, 0x0f, 0xe7, 0x3c, 0x7a, 0x82, 0x19, 0xf3,
	0x05, 0x16, 0xd4, 0x67, 0x61, 0x4c, 0xd9, 0x6f, 0xe5, 0xa9, 0xe2, 0x20, 0x30, 0x67, 0xd8, 0x73,
	0x13, 0x4c, 0x33, 0x0f, 0x63, 0x93, 0xc0, 0xf5, 0x67, 0x09, 0xa2, 0x91, 0x20, 0xd4, 0x68, 0x12,
	0xdd, 0x9c, 0xd8, 0x11, 0x57, 0xcb, 0x24, 0xf3, 0x47, 0xab, 0xf3, 0x82, 0x7a, 0x24, 0x14, 0xd8,
	0x0b, 0x62, 0x40, 0xeb, 0xaf, 0x55, 0x28, 0xbe, 0x8d, 0x9f, 0x05, 0x21, 0x78, 0xc4, 0xb0, 0x47,
	0x74, 0xad, 0xa9, 0x1d, 0x97, 0x0c, 0xf5, 0x1b, 0xd5, 0xa0, 0x40, 0x6d, 0xbd, 0xa0, 0x22, 0x05,
	0x6a, 0xa3, 0x11, 0xec, 0xe2, 0x48, 0xf8, 0x1e, 0x16, 0xd4, 0x32, 0x43, 0x0b, 0xbb, 0x94, 0x39,
	0xfa, 0x46, 0x53, 0x3b, 0x2e, 0xbf, 0xf8, 0xb2, 0x9d, 0x93, 0x85, 0xf6, 0x69, 0x8a, 0x1e, 0xc6,
	0xe0, 0xf3, 0x4f, 0x8c, 0x3a, 0x5e, 0x89, 0xa1, 0x73, 0xa8, 0x4e, 0x70, 0x98, 0x51, 0x7c, 0xa4,
	0x14, 0x9f, 0xe5, 0x2a, 0x76, 0x24, 0x72, 0xa1, 0x56, 0x99, 0x64, 0xc6, 0xe8, 0x0f, 0x50, 0xf3,
	0x30, 0x8b, 0xb0, 0x3b, 0x97, 0xda, 0x54, 0x52, 0xad, 0x5c, 0xa9, 0x4b, 0x05, 0x5d, 0x68, 0x55,
	0xbd, 0x6c, 0x00, 0x19, 0x50, 0xa7, 0x6c, 0xe2, 0x47, 0xcc, 0x36, 0x43, 0xc2, 0xa7, 0xd4, 0x22,
	0xa1, 0xbe, 0xd5, 0xdc, 0x38, 0xae, 0xbd, 0x78, 0x9e, 0x2b, 0xd7, 0x8f, 0xc1, 0xc3, 0x18, 0x3b,
	0x9a, 0x05, 0xc4, 0xd8, 0xa1, 0x4b, 0xb1, 0x10, 0x7d, 0x09, 0x35, 0xca, 0x42, 0x81, 0x99, 0x45,
	0x4c, 0xcb, 0xc5, 0x61, 0xa8, 0x17, 0x55, 0x72, 0xab, 0x69, 0xb4, 0x2b, 0x83, 0xe8, 0x5b, 0x28,
	0x32, 0x22, 0xee, 0x7d, 0x7e, 0xa7, 0x6f, 0xab, 0x07, 0x38, 0xcc, 0x5d, 0xf1, 0x2a, 0xc6, 0x18,
	0x29, 0x18, 0xbd, 0x82, 0x12, 0x27, 0xa1, 0x1f, 0x71, 0xe9, 0xb5, 0xa4, 0x98, 0x8d, 0x5c, 0xa6,
	0x91, 0xa2, 0x8c, 0x05, 0x01, 0xe9, 0x50, 0xe4, 0x11, 0x93, 0x35, 0xa2, 0x83, 0x72, 0x95, 0x0e,
	0x51, 0x03, 0x40, 0xdc, 0x72, 0x82, 0xed, 0x10, 0xdf, 0x10, 0xbd, 0xdc, 0xd4, 0x8e, 0xb7, 0x8d,
	0x4c, 0x44, 0xd6, 0xc9, 0xd4, 0xd3, 0x2b, 0x2a, 0x5e, 0x98, 0x7a, 0x68, 0x08, 0xd5, 0x09, 0x11,
	0xd8, 0x0c, 0x89, 0x10, 0x94, 0x39, 0xa1, 0x5e, 0x6d, 0x6e, 0x1c, 0x97, 0x5f, 0xb4, 0x73, 0xbd,
	0x24, 0x05, 0xd8, 0xee, 0x10, 0x81, 0x87, 0x09, 0xa1, 0xc7, 0x04, 0x9f, 0x19, 0x95, 0x49, 0x26,
	0x84, 0xea, 0xb0, 0x41, 0xd8, 0x54, 0xaf, 0x29, 0x6b, 0xf2, 0x27, 0xea, 0x43, 0x4d, 0xed, 0x0c,
	0x73, 0xcc, 0x50, 0x60, 0x11, 0x85, 0xfa, 0x4e, 0x53, 0x3b, 0xae, 0xfd, 0xc4, 0x76, 0x0f, 0x63,
	0xe8, 0x50, 0x21, 0x8d, 0x6a, 0x98, 0x1d, 0xa2, 0xa7, 0x00, 0x16, 0x27, 0x58, 0x10, 0xdb, 0x9c,
	0xcc, 0xf4, 0xba, 0x5a, 0xa3, 0x94, 0x44, 0x3a, 0x33, 0xf4, 0x1d, 0x94, 0xe3, 0x81, 0xa9, 0xd2,
	0xb3, 0xab, 0x52, 0xbb, 0x9f, 0x2e, 0x93, 0x9e, 0xaf, 0xf6, 0x28, 0x3d, 0x5f, 0x46, 0xa2, 0x26,
	0x03, 0xe8, 0x18, 0xea, 0x36, 0x0d, 0xef, 0xcc, 0x28, 0xc4, 0x0e, 0x31, 0x27, 0x33, 0x41, 0x42,
	0x1d, 0x35, 0xb5, 0xe3, 0x0d, 0xa3, 0x26, 0xe3, 0x63, 0x19, 0xee, 0xc8, 0x28, 0xfa, 0x35, 0x6c,
	0xdf, 0x62, 0x66, 0xbb, 0x84, 0x87, 0xba, 0xad, 0x52, 0x76, 0x90, 0xfb, 0x28, 0x63, 0xee, 0x5e,
	0xe2, 0xc0, 0x98, 0x83, 0xd1, 0x39, 0xd4, 0x08, 0xe7, 0x3e, 0x37, 0xe7, 0x74, 0xa2, 0xe8, 0xf9,
	0x67, 0xa8, 0x27, 0xa1, 0xe7, 0x31, 0xd2, 0xa8, 0x92, 0xcc, 0x28, 0x44, 0x2f, 0xa1, 0xe4, 0xd2,
	0x09, 0xc7, 0x9c, 0x92, 0x50, 0xbf, 0x51, 0x22, 0xf9, 0xc5, 0x77, 0xa1, 0x50, 0x33, 0x63, 0x01,
	0x47, 0x67, 0x00, 0x38, 0xa0, 0xa6, 0xe5, 0xb3, 0x1b, 0xea, 0xe8, 0xce, 0x87, 0xfa, 0x42, 0x40,
	0xbb, 0x0a, 0x95, 0xba, 0x28, 0xe1, 0x34, 0x22, 0x8b, 0x87, 0xb0, 0xa9, 0x39, 0xc5, 0x9c, 0xe2,
	0x89, 0x4b, 0x42, 0xfd, 0xf6, 0xff, 0x28, 0x9e, 0x1e, 0x9b, 0xbe, 0x4d, 0x09, 0x49, 0xf1, 0x90,
	0x4c, 0x08, 0x9d, 0x03, 0xb2, 0xc9, 0x0d, 0x8e, 0x5c, 0x61, 0x92, 0x87, 0x80, 0xc6, 0x6d, 0x52,
	0xa7, 0xca, 0xe2, 0x93, 0xb5, 0x7d, 0x3c, 0x4b, 0xfa, 0xa8, 0xb1, 0x9b, 0x90, 0x7a, 0x73, 0x0e,
	0xea, 0x42, 0xe5, 0x96, 0x60, 0x57, 0xdc, 0x9a, 0xd6, 0x2d, 0xb1, 0xee, 0xf4, 0x3f, 0x29, 0x8d,
	0x66, 0xae, 0xbb, 0x73, 0x05, 0xec, 0x4a, 0x9c, 0x51, 0xbe, 0x5d, 0x0c, 0x50, 0x1b, 0x1e, 0x33,
	0x7f, 0x12, 0x51, 0xd7, 0x36, 0x6f, 0xa8, 0x4b, 0x42, 0x93, 0x13, 0x87, 0x3c, 0xe8, 0x77, 0xaa,
	0xee, 0x76, 0x93, 0xa9, 0xd7, 0x72, 0xc6, 0x90, 0x13, 0xe8, 0x7b, 0x80, 0xb8, 0xf3, 0x7b, 0x84,
	0x09, 0xdd, 0x55, 0x4b, 0x1e, 0xe5, 0x2e, 0x79, 0x36, 0x87, 0x19, 0x19, 0x0a, 0x3a, 0x82, 0x72,
	0x72, 0x69, 0x99, 0x11, 0x77, 0x75, 0x4f, 0x2d, 0x04, 0x49, 0x68, 0xcc, 0xdd, 0xfd, 0xef, 0x61,
	0x77, 0xed, 0x00, 0xca, 0x23, 0x77, 0x47, 0x66, 0xc9, 0x95, 0x20, 0x7f, 0xa2, 0x4f, 0x61, 0x73,
	0x8a, 0xdd, 0x88, 0x24, 0x97, 0x42, 0x3c, 0x78, 0x59, 0xf8, 0x8d, 0x26, 0x05, 0xd6, 0x36, 0xe1,
	0xe7, 0x08, 0x74, 0x4a, 0x50, 0x4c, 0xba, 0x76, 0xeb, 0x9f, 0x5b, 0x50, 0x5f, 0xbd, 0x3a, 0x50,
	0x17, 0xea, 0x96, 0xef, 0xbb, 0xa6, 0xed, 0xdf, 0x33, 0x33, 0x20, 0x9c, 0xfa, 0xb6, 0x12, 0xfe,
	0xe0, 0x06, 0xd6, 0x24, 0xe5, 0xcc, 0xbf, 0x67, 0x03, 0x45, 0x40, 0x17, 0xb0, 0x63, 0x05, 0x91,
	0x19, 0x09, 0xea, 0xd2, 0x3f, 0xc7, 0x45, 0x50, 0x50, 0x1a, 0x9f, 0xe7, 0x66, 0xb3, 0x1b, 0x44,
	0xe3, 0x05, 0xd4, 0xa8, 0x59, 0x4b, 0x63, 0xf4, 0x2d, 0xec, 0x79, 0xf8, 0x41, 0x16, 0xbc, 0x15,
	0x71, 0x4e, 0x98, 0x30, 0x39, 0xf9, 0x31, 0x22, 0xa1, 0x08, 0xd5, 0xad, 0xb8, 0x69, 0xfc, 0xc2,
	0xc3, 0x0f, 0xdd, 0xf9, 0xac, 0x91, 0x4c, 0xa2, 0x5f, 0x02, 0x92, 0x3c, 0x6a, 0xbb, 0xc4, 0x4c,
	0x3b, 0x7f, 0xa8, 0xae, 0xbd, 0x4d, 0xa3, 0xee, 0xe1, 0x87, 0xbe, 0xed, 0x92, 0x7e, 0x1a, 0x97,
	0xc5, 0x22, 0xd1, 0xc2, 0x17, 0xd8, 0xcd, 0xc0, 0x37, 0x15, 0x7c, 0xd7, 0xc3, 0x0f, 0x23, 0x39,
	0xb3, 0xc0, 0xf7, 0x63, 0x7c, 0x40, 0x98, 0x2d, 0x5b, 0xa3, 0x8b, 0x05, 0x61, 0xd6, 0x4c, 0xdf,
	0xfa, 0x68, 0xb1, 0x7b, 0xf8, 0x61, 0x10, 0x93, 0x2e, 0x62, 0x8e, 0x32, 0x4a, 0xd9, 0xaa, 0xd1,
	0x62, 0x62, 0x94, 0xb2, 0x75, 0xa3, 0x94, 0xad, 0x19, 0xdd, 0x4e, 0x8c, 0x52, 0x96, 0x63, 0x94,
	0xb2, 0x35, 0xa3, 0xa5, 0x8f, 0x1b, 0xa5, 0x6c, 0xc5, 0xe8, 0x0f, 0xf0, 0x38, 0x49, 0xfd, 0xd2,
	0xde, 0x82, 0x92, 0x7a, 0xfe, 0x13, 0x77, 0xa0, 0xc2, 0x67, 0xf7, 0x17, 0xf1, 0xb5, 0x18, 0xba,
	0x4e, 0xbb, 0x77, 0x46, 0xb6, 0xac, 0x64, 0xbf, 0xc8, 0x3f, 0x80, 0xb2, 0xa5, 0x67, 0x34, 0x77,
	0xec, 0xe5, 0x80, 0xb4, 0x9a, 0xdc, 0xd7, 0x4b, 0x9a, 0x95, 0x0f, 0x58, 0x4d, 0x2e, 0xfa, 0x25,
	0xab, 0x6c, 0x2d, 0xd6, 0xfa, 0x11, 0x2a, 0xd9, 0xd7, 0x23, 0xf4, 0x0a, 0x2a, 0x6a, 0xe7, 0xe4,
	0x9d, 0xe5, 0x47, 0xe2, 0xe3, 0xa7, 0xa5, 0x2c, 0xe1, 0xa3, 0x18, 0x8d, 0x3e, 0x87, 0xaa, 0x2a,
	0xd2, 0xf9, 0x3e, 0x16, 0xd4, 0x3e, 0x56, 0x64, 0x7d, 0xa6, 0xb1, 0xd6, 0xd7, 0x50, 0x5d, 0x7a,
	0x8d, 0x42, 0x87, 0x50, 0x5a, 0x30, 0x34, 0xc5, 0x58, 0x04, 0x5a, 0x7f, 0xd3, 0xa0, 0xb6, 0x7c,
	0xa6, 0xd0, 0x18, 0x9e, 0x60, 0xc7, 0xe1, 0xc4, 0x51, 0x43, 0xf3, 0x9e, 0x32, 0xdb, 0xbf, 0x37,
	0x5d, 0xc2, 0x1c, 0x71, 0xfb, 0x71, 0xc7, 0x7b, 0x19, 0xee, 0x3b, 0x45, 0xbd, 0x50, 0x4c, 0xf4,
	0x35, 0x20, 0x81, 0xb9, 0x43, 0xc4, 0xda, 0x59, 0xd7, 0x8c, 0xdd, 0x78, 0x26, 0x9b, 0xba, 0xbf,
	0x6b, 0x80, 0xd6, 0x0b, 0x02, 0x9d, 0xc1, 0x51, 0xa2, 0x92, 0x56, 0x97, 0xe5, 0x47, 0x4c, 0xc8,
	0xf6, 0x63, 0x86, 0xc4, 0xf2, 0x99, 0x9d, 0x3c, 0xe3, 0x41, 0x0c, 0x4b, 0x24, 0xba, 0x12, 0x34,
	0x20, 0x7c, 0xa8, 0x20, 0xe8, 0x15, 0xec, 0x27, 0x2a, 0x79, 0x9d, 0x22, 0x4e, 0xab, 0x1e, 0x23,
	0xd6, 0x9b, 0x45, 0xeb, 0x2f, 0x05, 0xd8, 0x59, 0x29, 0x2a, 0xf4, 0x3b, 0x78, 0x9a, 0x28, 0xde,
	0x73, 0x2a, 0x92, 0x97, 0x8a, 0xac, 0xab, 0x9a, 0x12, 0x7d, 0x12, 0x83, 0xde, 0x49, 0x8c, 0x7a,
	0xc3, 0xc8, 0x7a, 0x3a, 0x58, 0x52, 0xf0, 0x83, 0x25, 0xfe, 0x8e, 0xe2, 0xef, 0x65, 0xf8, 0xd7,
	0x41, 0x86, 0xfd, 0x5b, 0x38, 0x9c, 0xe7, 0x05, 0xdb, 0xeb, 0xcb, 0xd7, 0xb3, 0xcf, 0x64, 0x10,
	0x6c, 0xaf, 0xac, 0xfe, 0x72, 0x9e, 0x11, 0xc5, 0x5f, 0x59, 0x7c, 0x57, 0xb1, 0x3f, 0x5b, 0xb0,
	0xb3, 0x6b, 0xb7, 0xfe, 0x51, 0x00, 0xb4, 0x7e, 0x20, 0x32, 0x96, 0x42, 0x99, 0xde, 0x35, 0x4b,
	0x5a, 0xd6, 0xd2, 0x90, 0x30, 0xb1, 0x62, 0xa9, 0x03, 0x8d, 0x2c, 0x3f, 0xc0, 0xd6, 0x1d, 0x11,
	0x4b, 0x0a, 0x65, 0xa5, 0xb0, 0xbf, 0x50, 0x18, 0xc4, 0x98, 0x85, 0xc6, 0x6b, 0x68, 0xce, 0x1f,
	0xcb, 0x22, 0x74, 0x4a, 0x72, 0x52, 0x53, 0x51, 0x2a, 0x87, 0xe9, 0xc3, 0xc5, 0xb0, 0x15, 0x2f,
	0xbf, 0x87, 0xd6, 0xaa, 0x4e, 0x8e, 0x9f, 0xaa, 0x52, 0x6a, 0x2c, 0x2b, 0xad, 0x7a, 0x6a, 0x51,
	0x28, 0x26, 0xd9, 0x42, 0xcf, 0x61, 0xe7, 0xc6, 0xe7, 0xf7, 0x98, 0xdb, 0x52, 0xd0, 0xe7, 0x42,
	0x9e, 0xd0, 0x8d, 0xe3, 0x92, 0x51, 0x9b, 0x87, 0x07, 0x32, 0x8a, 0x9e, 0x41, 0x65, 0xfe, 0x99,
	0x22, 0xb0, 0x93, 0xdc, 0xd5, 0xe5, 0x34, 0x36, 0xc2, 0xce, 0xfc, 0x73, 0x71, 0x63, 0xf1, 0xb9,
	0xd8, 0x1a, 0x42, 0x69, 0xfe, 0x61, 0x21, 0xaf, 0x7e, 0x2b, 0x88, 0x54, 0xda, 0x35, 0x43, 0xfe,
	0x44, 0x7b, 0x50, 0x54, 0x9d, 0xd4, 0x99, 0x24, 0xe7, 0x70, 0x4b, 0x0e, 0xdf, 0x4c, 0xd0, 0x01,
	0x94, 0x3c, 0xe2, 0xf9, 0x7c, 0x26, 0xa7, 0x36, 0xd4, 0xd4, 0x76, 0x1c, 0x78, 0x33, 0xf9, 0xea,
	0x5f, 0x05, 0x40, 0xeb, 0x9f, 0x56, 0xe8, 0x08, 0x0e, 0xfa, 0x57, 0x9d, 0xeb, 0xf1, 0xd5, 0x99,
	0x39, 0xec, 0x19, 0x6f, 0xfb, 0xdd, 0x9e, 0x39, 0xbe, 0x1a, 0x0e, 0x7a, 0xdd, 0xfe, 0xeb, 0x7e,
	0xef, 0xac, 0xfe, 0x09, 0xd2, 0xe1, 0xd3, 0x55, 0xc0, 0xe5, 0x69, 0xff, 0xa2, 0xae, 0xe5, 0x51,
	0xe5, 0x8c, 0x29, 0x43, 0xdd, 0x5e, 0xbd, 0x80, 0x1a, 0xb0, 0xbf, 0x0a, 0xf8, 0xe1, 0x72, 0x30,
	0x30, 0x7b, 0x86, 0x71, 0x6d, 0xd4, 0x37, 0x50, 0x13, 0x0e, 0x73, 0xe7, 0x2f, 0x7b, 0xc3, 0xe1,
	0xe9, 0x9b, 0x5e, 0xfd, 0x11, 0x6a, 0x41, 0x23, 0x17, 0x31, 0x1c, 0x77, 0x86, 0x5d, 0xa3, 0xdf,
	0xe9, 0xd5, 0x37, 0xd1, 0x33, 0x78, 0x9a, 0x8b, 0x19, 0x18, 0xbd, 0x61, 0x4f, 0x1a, 0xd9, 0x42,
	0x5f, 0x40, 0x73, 0x15, 0xd2, 0x3d, 0x3f, 0xbd, 0xba, 0xea, 0x5d, 0x2c, 0x50, 0x45, 0xb4, 0x0f,
	0x9f, 0xad, 0xa2, 0xde, 0x9d, 0x1a, 0x97, 0xe3, 0x41, 0xbd, 0xf4, 0x55, 0x1f, 0xaa, 0x4b, 0xdf,
	0x3d, 0xf2, 0xd9, 0x14, 0xe8, 0xea, 0x8d, 0x39, 0x1c, 0x9d, 0x8e, 0xc6, 0xc3, 0x95, 0xb4, 0x95,
	0xa1, 0x98, 0xcc, 0xd7, 0x35, 0x35, 0x18, 0x5d, 0x0f, 0x06, 0xbd, 0xb3, 0x7a, 0xa1, 0x13, 0xfe,
	0xfb, 0x7d, 0x43, 0xfb, 0xcf, 0xfb, 0x86, 0xf6, 0xdf, 0xf7, 0x0d, 0x0d, 0xf6, 0x2c, 0xdf, 0xcb,
	0xbb, 0xab, 0x3a, 0x95, 0xe4, 0x95, 0x7c, 0x20, 0x7b, 0xf5, 0x40, 0xfb, 0xe3, 0xab, 0x04, 0xe4,
	0xf8, 0x2e, 0x66, 0x4e, 0xdb, 0xe7, 0xce, 0x89, 0x43, 0x98, 0xea, 0xe4, 0x27, 0xf1, 0x14, 0x0e,
	0x68, 0xb8, 0xf4, 0x2f, 0xc7, 0x77, 0xf3, 0xc1, 0x64, 0x4b, 0x01, 0x7f, 0xf5, 0xbf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xa8, 0xaf, 0x81, 0xd0, 0x87, 0x11, 0x00, 0x00,
}
