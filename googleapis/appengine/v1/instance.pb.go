// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/appengine/v1/instance.proto

package appengine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf2 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Availability of the instance.
type Instance_Availability int32

const (
	Instance_UNSPECIFIED Instance_Availability = 0
	Instance_RESIDENT    Instance_Availability = 1
	Instance_DYNAMIC     Instance_Availability = 2
)

var Instance_Availability_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "RESIDENT",
	2: "DYNAMIC",
}
var Instance_Availability_value = map[string]int32{
	"UNSPECIFIED": 0,
	"RESIDENT":    1,
	"DYNAMIC":     2,
}

func (x Instance_Availability) String() string {
	return proto.EnumName(Instance_Availability_name, int32(x))
}
func (Instance_Availability) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorInstance, []int{0, 0}
}

// An Instance resource is the computing unit that App Engine uses to
// automatically scale an application.
type Instance struct {
	// Full path to the Instance resource in the API.
	// Example: `apps/myapp/services/default/versions/v1/instances/instance-1`.
	//
	// @OutputOnly
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Relative name of the instance within the version.
	// Example: `instance-1`.
	//
	// @OutputOnly
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// App Engine release this instance is running on.
	//
	// @OutputOnly
	AppEngineRelease string `protobuf:"bytes,3,opt,name=app_engine_release,json=appEngineRelease,proto3" json:"app_engine_release,omitempty"`
	// Availability of the instance.
	//
	// @OutputOnly
	Availability Instance_Availability `protobuf:"varint,4,opt,name=availability,proto3,enum=google.appengine.v1.Instance_Availability" json:"availability,omitempty"`
	// Name of the virtual machine where this instance lives. Only applicable
	// for instances in App Engine flexible environment.
	//
	// @OutputOnly
	VmName string `protobuf:"bytes,5,opt,name=vm_name,json=vmName,proto3" json:"vm_name,omitempty"`
	// Zone where the virtual machine is located. Only applicable for instances
	// in App Engine flexible environment.
	//
	// @OutputOnly
	VmZoneName string `protobuf:"bytes,6,opt,name=vm_zone_name,json=vmZoneName,proto3" json:"vm_zone_name,omitempty"`
	// Virtual machine ID of this instance. Only applicable for instances in
	// App Engine flexible environment.
	//
	// @OutputOnly
	VmId string `protobuf:"bytes,7,opt,name=vm_id,json=vmId,proto3" json:"vm_id,omitempty"`
	// Time that this instance was started.
	//
	// @OutputOnly
	StartTime *google_protobuf2.Timestamp `protobuf:"bytes,8,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Number of requests since this instance was started.
	//
	// @OutputOnly
	Requests int32 `protobuf:"varint,9,opt,name=requests,proto3" json:"requests,omitempty"`
	// Number of errors since this instance was started.
	//
	// @OutputOnly
	Errors int32 `protobuf:"varint,10,opt,name=errors,proto3" json:"errors,omitempty"`
	// Average queries per second (QPS) over the last minute.
	//
	// @OutputOnly
	Qps float32 `protobuf:"fixed32,11,opt,name=qps,proto3" json:"qps,omitempty"`
	// Average latency (ms) over the last minute.
	//
	// @OutputOnly
	AverageLatency int32 `protobuf:"varint,12,opt,name=average_latency,json=averageLatency,proto3" json:"average_latency,omitempty"`
	// Total memory in use (bytes).
	//
	// @OutputOnly
	MemoryUsage int64 `protobuf:"varint,13,opt,name=memory_usage,json=memoryUsage,proto3" json:"memory_usage,omitempty"`
	// Status of the virtual machine where this instance lives. Only applicable
	// for instances in App Engine flexible environment.
	//
	// @OutputOnly
	VmStatus string `protobuf:"bytes,14,opt,name=vm_status,json=vmStatus,proto3" json:"vm_status,omitempty"`
	// Whether this instance is in debug mode. Only applicable for instances in
	// App Engine flexible environment.
	//
	// @OutputOnly
	VmDebugEnabled bool `protobuf:"varint,15,opt,name=vm_debug_enabled,json=vmDebugEnabled,proto3" json:"vm_debug_enabled,omitempty"`
}

func (m *Instance) Reset()                    { *m = Instance{} }
func (m *Instance) String() string            { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()               {}
func (*Instance) Descriptor() ([]byte, []int) { return fileDescriptorInstance, []int{0} }

func (m *Instance) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Instance) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Instance) GetAppEngineRelease() string {
	if m != nil {
		return m.AppEngineRelease
	}
	return ""
}

func (m *Instance) GetAvailability() Instance_Availability {
	if m != nil {
		return m.Availability
	}
	return Instance_UNSPECIFIED
}

func (m *Instance) GetVmName() string {
	if m != nil {
		return m.VmName
	}
	return ""
}

func (m *Instance) GetVmZoneName() string {
	if m != nil {
		return m.VmZoneName
	}
	return ""
}

func (m *Instance) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *Instance) GetStartTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Instance) GetRequests() int32 {
	if m != nil {
		return m.Requests
	}
	return 0
}

func (m *Instance) GetErrors() int32 {
	if m != nil {
		return m.Errors
	}
	return 0
}

func (m *Instance) GetQps() float32 {
	if m != nil {
		return m.Qps
	}
	return 0
}

func (m *Instance) GetAverageLatency() int32 {
	if m != nil {
		return m.AverageLatency
	}
	return 0
}

func (m *Instance) GetMemoryUsage() int64 {
	if m != nil {
		return m.MemoryUsage
	}
	return 0
}

func (m *Instance) GetVmStatus() string {
	if m != nil {
		return m.VmStatus
	}
	return ""
}

func (m *Instance) GetVmDebugEnabled() bool {
	if m != nil {
		return m.VmDebugEnabled
	}
	return false
}

func init() {
	proto.RegisterType((*Instance)(nil), "google.appengine.v1.Instance")
	proto.RegisterEnum("google.appengine.v1.Instance_Availability", Instance_Availability_name, Instance_Availability_value)
}
func (m *Instance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInstance(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInstance(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.AppEngineRelease) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInstance(dAtA, i, uint64(len(m.AppEngineRelease)))
		i += copy(dAtA[i:], m.AppEngineRelease)
	}
	if m.Availability != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintInstance(dAtA, i, uint64(m.Availability))
	}
	if len(m.VmName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInstance(dAtA, i, uint64(len(m.VmName)))
		i += copy(dAtA[i:], m.VmName)
	}
	if len(m.VmZoneName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInstance(dAtA, i, uint64(len(m.VmZoneName)))
		i += copy(dAtA[i:], m.VmZoneName)
	}
	if len(m.VmId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintInstance(dAtA, i, uint64(len(m.VmId)))
		i += copy(dAtA[i:], m.VmId)
	}
	if m.StartTime != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintInstance(dAtA, i, uint64(m.StartTime.Size()))
		n1, err := m.StartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Requests != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintInstance(dAtA, i, uint64(m.Requests))
	}
	if m.Errors != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintInstance(dAtA, i, uint64(m.Errors))
	}
	if m.Qps != 0 {
		dAtA[i] = 0x5d
		i++
		i = encodeFixed32Instance(dAtA, i, uint32(math.Float32bits(float32(m.Qps))))
	}
	if m.AverageLatency != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintInstance(dAtA, i, uint64(m.AverageLatency))
	}
	if m.MemoryUsage != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintInstance(dAtA, i, uint64(m.MemoryUsage))
	}
	if len(m.VmStatus) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintInstance(dAtA, i, uint64(len(m.VmStatus)))
		i += copy(dAtA[i:], m.VmStatus)
	}
	if m.VmDebugEnabled {
		dAtA[i] = 0x78
		i++
		if m.VmDebugEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64Instance(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Instance(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintInstance(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Instance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	l = len(m.AppEngineRelease)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	if m.Availability != 0 {
		n += 1 + sovInstance(uint64(m.Availability))
	}
	l = len(m.VmName)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	l = len(m.VmZoneName)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovInstance(uint64(l))
	}
	if m.Requests != 0 {
		n += 1 + sovInstance(uint64(m.Requests))
	}
	if m.Errors != 0 {
		n += 1 + sovInstance(uint64(m.Errors))
	}
	if m.Qps != 0 {
		n += 5
	}
	if m.AverageLatency != 0 {
		n += 1 + sovInstance(uint64(m.AverageLatency))
	}
	if m.MemoryUsage != 0 {
		n += 1 + sovInstance(uint64(m.MemoryUsage))
	}
	l = len(m.VmStatus)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	if m.VmDebugEnabled {
		n += 2
	}
	return n
}

func sovInstance(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInstance(x uint64) (n int) {
	return sovInstance(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Instance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppEngineRelease", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppEngineRelease = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Availability", wireType)
			}
			m.Availability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Availability |= (Instance_Availability(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmZoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmZoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &google_protobuf2.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			m.Requests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Requests |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			m.Errors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errors |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Qps = float32(math.Float32frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageLatency", wireType)
			}
			m.AverageLatency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AverageLatency |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsage", wireType)
			}
			m.MemoryUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmDebugEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VmDebugEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInstance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInstance(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInstance
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInstance
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInstance
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInstance(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInstance = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInstance   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/appengine/v1/instance.proto", fileDescriptorInstance) }

var fileDescriptorInstance = []byte{
	// 538 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0x4d, 0x6b, 0xdb, 0x3e,
	0x18, 0xff, 0x2b, 0x6d, 0xd3, 0xe4, 0x89, 0x9b, 0x1a, 0x15, 0xfe, 0x15, 0xd9, 0xe8, 0xbc, 0x5e,
	0x66, 0xc6, 0xb0, 0x69, 0x77, 0xda, 0xcb, 0xa5, 0x6d, 0x3c, 0x30, 0x6c, 0xa1, 0xb8, 0xed, 0x61,
	0xbd, 0x18, 0xa5, 0xd6, 0x8c, 0xc0, 0x92, 0x5c, 0x4b, 0x11, 0x74, 0x9f, 0x70, 0x87, 0x1d, 0xf6,
	0x11, 0x46, 0x3e, 0xc9, 0xb0, 0x9c, 0x84, 0x16, 0x7a, 0xf3, 0xef, 0x0d, 0xfd, 0x9e, 0xe7, 0xc1,
	0x70, 0x5c, 0x2a, 0x55, 0x56, 0x2c, 0xa6, 0x75, 0xcd, 0x64, 0xc9, 0x25, 0x8b, 0xed, 0x49, 0xcc,
	0xa5, 0x36, 0x54, 0xde, 0xb1, 0xa8, 0x6e, 0x94, 0x51, 0xf8, 0xa0, 0xf3, 0x44, 0x1b, 0x4f, 0x64,
	0x4f, 0x26, 0x2f, 0x37, 0x41, 0x1e, 0x53, 0x29, 0x95, 0xa1, 0x86, 0x2b, 0xa9, 0xbb, 0xc8, 0xe4,
	0xd5, 0x4a, 0x75, 0x68, 0xbe, 0xf8, 0x11, 0x1b, 0x2e, 0x98, 0x36, 0x54, 0xd4, 0x9d, 0xe1, 0xf8,
	0xf7, 0x36, 0x0c, 0xd2, 0xd5, 0x33, 0x18, 0xc3, 0xb6, 0xa4, 0x82, 0x11, 0x14, 0xa0, 0x70, 0x98,
	0xb9, 0x6f, 0x3c, 0x86, 0x1e, 0x2f, 0x48, 0xcf, 0x31, 0x3d, 0x5e, 0xe0, 0x77, 0x80, 0x69, 0x5d,
	0xe7, 0x5d, 0x81, 0xbc, 0x61, 0x15, 0xa3, 0x9a, 0x91, 0x2d, 0xa7, 0xfb, 0xb4, 0xae, 0x13, 0x27,
	0x64, 0x1d, 0x8f, 0x67, 0xe0, 0x51, 0x4b, 0x79, 0x45, 0xe7, 0xbc, 0xe2, 0xe6, 0x81, 0x6c, 0x07,
	0x28, 0x1c, 0x9f, 0xbe, 0x8d, 0x9e, 0x99, 0x24, 0x5a, 0xd7, 0x88, 0xce, 0x1e, 0x25, 0xb2, 0x27,
	0x79, 0x7c, 0x08, 0xbb, 0x56, 0xe4, 0xae, 0xe4, 0x8e, 0x7b, 0xb2, 0x6f, 0xc5, 0xac, 0xad, 0x19,
	0x80, 0x67, 0x45, 0xfe, 0x53, 0x49, 0xd6, 0xa9, 0x7d, 0xa7, 0x82, 0x15, 0xb7, 0x4a, 0x32, 0xe7,
	0x38, 0x80, 0x1d, 0x2b, 0x72, 0x5e, 0x90, 0xdd, 0x6e, 0x3a, 0x2b, 0xd2, 0x02, 0x7f, 0x00, 0xd0,
	0x86, 0x36, 0x26, 0x6f, 0xf7, 0x42, 0x06, 0x01, 0x0a, 0x47, 0xa7, 0x93, 0x75, 0xbb, 0xf5, 0xd2,
	0xa2, 0xeb, 0xf5, 0xd2, 0xb2, 0xa1, 0x73, 0xb7, 0x18, 0x4f, 0x60, 0xd0, 0xb0, 0xfb, 0x05, 0xd3,
	0x46, 0x93, 0x61, 0x80, 0xc2, 0x9d, 0x6c, 0x83, 0xf1, 0xff, 0xd0, 0x67, 0x4d, 0xa3, 0x1a, 0x4d,
	0xc0, 0x29, 0x2b, 0x84, 0x7d, 0xd8, 0xba, 0xaf, 0x35, 0x19, 0x05, 0x28, 0xec, 0x65, 0xed, 0x27,
	0x7e, 0x03, 0xfb, 0xd4, 0xb2, 0x86, 0x96, 0x2c, 0xaf, 0xa8, 0x61, 0xf2, 0xee, 0x81, 0x78, 0x2e,
	0x32, 0x5e, 0xd1, 0x5f, 0x3b, 0x16, 0xbf, 0x06, 0x4f, 0x30, 0xa1, 0x9a, 0x87, 0x7c, 0xa1, 0x69,
	0xc9, 0xc8, 0x5e, 0x80, 0xc2, 0xad, 0x6c, 0xd4, 0x71, 0x37, 0x2d, 0x85, 0x5f, 0xc0, 0xd0, 0x8a,
	0x5c, 0x1b, 0x6a, 0x16, 0x9a, 0x8c, 0xdd, 0x94, 0x03, 0x2b, 0xae, 0x1c, 0xc6, 0x21, 0xf8, 0x56,
	0xe4, 0x05, 0x9b, 0x2f, 0xca, 0x9c, 0x49, 0x3a, 0xaf, 0x58, 0x41, 0xf6, 0x03, 0x14, 0x0e, 0xb2,
	0xb1, 0x15, 0xd3, 0x96, 0x4e, 0x3a, 0xf6, 0xf8, 0x23, 0x78, 0x8f, 0x2f, 0x80, 0xf7, 0x61, 0x74,
	0x33, 0xbb, 0xba, 0x4c, 0x2e, 0xd2, 0x2f, 0x69, 0x32, 0xf5, 0xff, 0xc3, 0x1e, 0x0c, 0xb2, 0xe4,
	0x2a, 0x9d, 0x26, 0xb3, 0x6b, 0x1f, 0xe1, 0x11, 0xec, 0x4e, 0xbf, 0xcf, 0xce, 0xbe, 0xa5, 0x17,
	0x7e, 0xef, 0xdc, 0xfc, 0x5a, 0x1e, 0xa1, 0x3f, 0xcb, 0x23, 0xf4, 0x77, 0x79, 0x84, 0xe0, 0xf0,
	0x4e, 0x89, 0xe7, 0x4e, 0x7d, 0xbe, 0xb7, 0xbe, 0xf5, 0x65, 0xbb, 0xe2, 0x4b, 0x74, 0xfb, 0x79,
	0xe5, 0x2a, 0x55, 0x45, 0x65, 0x19, 0xa9, 0xa6, 0x8c, 0x4b, 0x26, 0xdd, 0x01, 0xe2, 0x4e, 0xa2,
	0x35, 0xd7, 0x4f, 0xfe, 0x8e, 0x4f, 0x1b, 0x30, 0xef, 0x3b, 0xe3, 0xfb, 0x7f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xc7, 0x6e, 0x9f, 0x32, 0x45, 0x03, 0x00, 0x00,
}
