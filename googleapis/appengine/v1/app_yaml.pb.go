// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/appengine/v1/app_yaml.proto

/*
	Package appengine is a generated protocol buffer package.

	It is generated from these files:
		google/appengine/v1/app_yaml.proto
		google/appengine/v1/appengine.proto
		google/appengine/v1/application.proto
		google/appengine/v1/audit_data.proto
		google/appengine/v1/deploy.proto
		google/appengine/v1/instance.proto
		google/appengine/v1/location.proto
		google/appengine/v1/operation.proto
		google/appengine/v1/service.proto
		google/appengine/v1/version.proto

	It has these top-level messages:
		ApiConfigHandler
		ErrorHandler
		UrlMap
		StaticFilesHandler
		ScriptHandler
		ApiEndpointHandler
		HealthCheck
		Library
		GetApplicationRequest
		RepairApplicationRequest
		ListServicesRequest
		ListServicesResponse
		GetServiceRequest
		UpdateServiceRequest
		DeleteServiceRequest
		ListVersionsRequest
		ListVersionsResponse
		GetVersionRequest
		CreateVersionRequest
		UpdateVersionRequest
		DeleteVersionRequest
		ListInstancesRequest
		ListInstancesResponse
		GetInstanceRequest
		DeleteInstanceRequest
		DebugInstanceRequest
		Application
		UrlDispatchRule
		AuditData
		UpdateServiceMethod
		CreateVersionMethod
		Deployment
		FileInfo
		ContainerInfo
		ZipInfo
		Instance
		LocationMetadata
		OperationMetadataV1
		Service
		TrafficSplit
		Version
		AutomaticScaling
		BasicScaling
		ManualScaling
		CpuUtilization
		RequestUtilization
		DiskUtilization
		NetworkUtilization
		Network
		Resources
*/
package appengine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Actions to take when the user is not logged in.
type AuthFailAction int32

const (
	// Not specified. `AUTH_FAIL_ACTION_REDIRECT` is assumed.
	AuthFailAction_AUTH_FAIL_ACTION_UNSPECIFIED AuthFailAction = 0
	// Redirects user to "accounts.google.com". The user is redirected back to the
	// application URL after signing in or creating an account.
	AuthFailAction_AUTH_FAIL_ACTION_REDIRECT AuthFailAction = 1
	// Rejects request with a `401` HTTP status code and an error
	// message.
	AuthFailAction_AUTH_FAIL_ACTION_UNAUTHORIZED AuthFailAction = 2
)

var AuthFailAction_name = map[int32]string{
	0: "AUTH_FAIL_ACTION_UNSPECIFIED",
	1: "AUTH_FAIL_ACTION_REDIRECT",
	2: "AUTH_FAIL_ACTION_UNAUTHORIZED",
}
var AuthFailAction_value = map[string]int32{
	"AUTH_FAIL_ACTION_UNSPECIFIED":  0,
	"AUTH_FAIL_ACTION_REDIRECT":     1,
	"AUTH_FAIL_ACTION_UNAUTHORIZED": 2,
}

func (x AuthFailAction) String() string {
	return proto.EnumName(AuthFailAction_name, int32(x))
}
func (AuthFailAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{0} }

// Methods to restrict access to a URL based on login status.
type LoginRequirement int32

const (
	// Not specified. `LOGIN_OPTIONAL` is assumed.
	LoginRequirement_LOGIN_UNSPECIFIED LoginRequirement = 0
	// Does not require that the user is signed in.
	LoginRequirement_LOGIN_OPTIONAL LoginRequirement = 1
	// If the user is not signed in, the `auth_fail_action` is taken.
	// In addition, if the user is not an administrator for the
	// application, they are given an error message regardless of
	// `auth_fail_action`. If the user is an administrator, the handler
	// proceeds.
	LoginRequirement_LOGIN_ADMIN LoginRequirement = 2
	// If the user has signed in, the handler proceeds normally. Otherwise, the
	// auth_fail_action is taken.
	LoginRequirement_LOGIN_REQUIRED LoginRequirement = 3
)

var LoginRequirement_name = map[int32]string{
	0: "LOGIN_UNSPECIFIED",
	1: "LOGIN_OPTIONAL",
	2: "LOGIN_ADMIN",
	3: "LOGIN_REQUIRED",
}
var LoginRequirement_value = map[string]int32{
	"LOGIN_UNSPECIFIED": 0,
	"LOGIN_OPTIONAL":    1,
	"LOGIN_ADMIN":       2,
	"LOGIN_REQUIRED":    3,
}

func (x LoginRequirement) String() string {
	return proto.EnumName(LoginRequirement_name, int32(x))
}
func (LoginRequirement) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{1} }

// Methods to enforce security (HTTPS) on a URL.
type SecurityLevel int32

const (
	// Not specified.
	SecurityLevel_SECURE_UNSPECIFIED SecurityLevel = 0
	// Both HTTP and HTTPS requests with URLs that match the handler succeed
	// without redirects. The application can examine the request to determine
	// which protocol was used, and respond accordingly.
	SecurityLevel_SECURE_DEFAULT SecurityLevel = 0
	// Requests for a URL that match this handler that use HTTPS are automatically
	// redirected to the HTTP equivalent URL.
	SecurityLevel_SECURE_NEVER SecurityLevel = 1
	// Both HTTP and HTTPS requests with URLs that match the handler succeed
	// without redirects. The application can examine the request to determine
	// which protocol was used and respond accordingly.
	SecurityLevel_SECURE_OPTIONAL SecurityLevel = 2
	// Requests for a URL that match this handler that do not use HTTPS are
	// automatically redirected to the HTTPS URL with the same path. Query
	// parameters are reserved for the redirect.
	SecurityLevel_SECURE_ALWAYS SecurityLevel = 3
)

var SecurityLevel_name = map[int32]string{
	0: "SECURE_UNSPECIFIED",
	// Duplicate value: 0: "SECURE_DEFAULT",
	1: "SECURE_NEVER",
	2: "SECURE_OPTIONAL",
	3: "SECURE_ALWAYS",
}
var SecurityLevel_value = map[string]int32{
	"SECURE_UNSPECIFIED": 0,
	"SECURE_DEFAULT":     0,
	"SECURE_NEVER":       1,
	"SECURE_OPTIONAL":    2,
	"SECURE_ALWAYS":      3,
}

func (x SecurityLevel) String() string {
	return proto.EnumName(SecurityLevel_name, int32(x))
}
func (SecurityLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{2} }

// Error codes.
type ErrorHandler_ErrorCode int32

const (
	// Not specified. ERROR_CODE_DEFAULT is assumed.
	ErrorHandler_ERROR_CODE_UNSPECIFIED ErrorHandler_ErrorCode = 0
	// All other error types.
	ErrorHandler_ERROR_CODE_DEFAULT ErrorHandler_ErrorCode = 0
	// Application has exceeded a resource quota.
	ErrorHandler_ERROR_CODE_OVER_QUOTA ErrorHandler_ErrorCode = 1
	// Client blocked by the application's Denial of Service protection
	// configuration.
	ErrorHandler_ERROR_CODE_DOS_API_DENIAL ErrorHandler_ErrorCode = 2
	// Deadline reached before the application responds.
	ErrorHandler_ERROR_CODE_TIMEOUT ErrorHandler_ErrorCode = 3
)

var ErrorHandler_ErrorCode_name = map[int32]string{
	0: "ERROR_CODE_UNSPECIFIED",
	// Duplicate value: 0: "ERROR_CODE_DEFAULT",
	1: "ERROR_CODE_OVER_QUOTA",
	2: "ERROR_CODE_DOS_API_DENIAL",
	3: "ERROR_CODE_TIMEOUT",
}
var ErrorHandler_ErrorCode_value = map[string]int32{
	"ERROR_CODE_UNSPECIFIED":    0,
	"ERROR_CODE_DEFAULT":        0,
	"ERROR_CODE_OVER_QUOTA":     1,
	"ERROR_CODE_DOS_API_DENIAL": 2,
	"ERROR_CODE_TIMEOUT":        3,
}

func (x ErrorHandler_ErrorCode) String() string {
	return proto.EnumName(ErrorHandler_ErrorCode_name, int32(x))
}
func (ErrorHandler_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppYaml, []int{1, 0}
}

// Redirect codes.
type UrlMap_RedirectHttpResponseCode int32

const (
	// Not specified. `302` is assumed.
	UrlMap_REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED UrlMap_RedirectHttpResponseCode = 0
	// `301 Moved Permanently` code.
	UrlMap_REDIRECT_HTTP_RESPONSE_CODE_301 UrlMap_RedirectHttpResponseCode = 1
	// `302 Moved Temporarily` code.
	UrlMap_REDIRECT_HTTP_RESPONSE_CODE_302 UrlMap_RedirectHttpResponseCode = 2
	// `303 See Other` code.
	UrlMap_REDIRECT_HTTP_RESPONSE_CODE_303 UrlMap_RedirectHttpResponseCode = 3
	// `307 Temporary Redirect` code.
	UrlMap_REDIRECT_HTTP_RESPONSE_CODE_307 UrlMap_RedirectHttpResponseCode = 4
)

var UrlMap_RedirectHttpResponseCode_name = map[int32]string{
	0: "REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED",
	1: "REDIRECT_HTTP_RESPONSE_CODE_301",
	2: "REDIRECT_HTTP_RESPONSE_CODE_302",
	3: "REDIRECT_HTTP_RESPONSE_CODE_303",
	4: "REDIRECT_HTTP_RESPONSE_CODE_307",
}
var UrlMap_RedirectHttpResponseCode_value = map[string]int32{
	"REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED": 0,
	"REDIRECT_HTTP_RESPONSE_CODE_301":         1,
	"REDIRECT_HTTP_RESPONSE_CODE_302":         2,
	"REDIRECT_HTTP_RESPONSE_CODE_303":         3,
	"REDIRECT_HTTP_RESPONSE_CODE_307":         4,
}

func (x UrlMap_RedirectHttpResponseCode) String() string {
	return proto.EnumName(UrlMap_RedirectHttpResponseCode_name, int32(x))
}
func (UrlMap_RedirectHttpResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAppYaml, []int{2, 0}
}

// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/)
// configuration for API handlers.
type ApiConfigHandler struct {
	// Action to take when users access resources that require
	// authentication. Defaults to `redirect`.
	AuthFailAction AuthFailAction `protobuf:"varint,1,opt,name=auth_fail_action,json=authFailAction,proto3,enum=google.appengine.v1.AuthFailAction" json:"auth_fail_action,omitempty"`
	// Level of login required to access this resource. Defaults to
	// `optional`.
	Login LoginRequirement `protobuf:"varint,2,opt,name=login,proto3,enum=google.appengine.v1.LoginRequirement" json:"login,omitempty"`
	// Path to the script from the application root directory.
	Script string `protobuf:"bytes,3,opt,name=script,proto3" json:"script,omitempty"`
	// Security (HTTPS) enforcement for this URL.
	SecurityLevel SecurityLevel `protobuf:"varint,4,opt,name=security_level,json=securityLevel,proto3,enum=google.appengine.v1.SecurityLevel" json:"security_level,omitempty"`
	// URL to serve the endpoint at.
	Url string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *ApiConfigHandler) Reset()                    { *m = ApiConfigHandler{} }
func (m *ApiConfigHandler) String() string            { return proto.CompactTextString(m) }
func (*ApiConfigHandler) ProtoMessage()               {}
func (*ApiConfigHandler) Descriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{0} }

func (m *ApiConfigHandler) GetAuthFailAction() AuthFailAction {
	if m != nil {
		return m.AuthFailAction
	}
	return AuthFailAction_AUTH_FAIL_ACTION_UNSPECIFIED
}

func (m *ApiConfigHandler) GetLogin() LoginRequirement {
	if m != nil {
		return m.Login
	}
	return LoginRequirement_LOGIN_UNSPECIFIED
}

func (m *ApiConfigHandler) GetScript() string {
	if m != nil {
		return m.Script
	}
	return ""
}

func (m *ApiConfigHandler) GetSecurityLevel() SecurityLevel {
	if m != nil {
		return m.SecurityLevel
	}
	return SecurityLevel_SECURE_UNSPECIFIED
}

func (m *ApiConfigHandler) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// Custom static error page to be served when an error occurs.
type ErrorHandler struct {
	// Error condition this handler applies to.
	ErrorCode ErrorHandler_ErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=google.appengine.v1.ErrorHandler_ErrorCode" json:"error_code,omitempty"`
	// Static file content to be served for this error.
	StaticFile string `protobuf:"bytes,2,opt,name=static_file,json=staticFile,proto3" json:"static_file,omitempty"`
	// MIME type of file. Defaults to `text/html`.
	MimeType string `protobuf:"bytes,3,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
}

func (m *ErrorHandler) Reset()                    { *m = ErrorHandler{} }
func (m *ErrorHandler) String() string            { return proto.CompactTextString(m) }
func (*ErrorHandler) ProtoMessage()               {}
func (*ErrorHandler) Descriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{1} }

func (m *ErrorHandler) GetErrorCode() ErrorHandler_ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ErrorHandler_ERROR_CODE_UNSPECIFIED
}

func (m *ErrorHandler) GetStaticFile() string {
	if m != nil {
		return m.StaticFile
	}
	return ""
}

func (m *ErrorHandler) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

// URL pattern and description of how the URL should be handled. App Engine can
// handle URLs by executing application code or by serving static files
// uploaded with the version, such as images, CSS, or JavaScript.
type UrlMap struct {
	// URL prefix. Uses regular expression syntax, which means regexp
	// special characters must be escaped, but should not contain groupings.
	// All URLs that begin with this prefix are handled by this handler, using the
	// portion of the URL after the prefix as part of the file path.
	UrlRegex string `protobuf:"bytes,1,opt,name=url_regex,json=urlRegex,proto3" json:"url_regex,omitempty"`
	// Type of handler for this URL pattern.
	//
	// Types that are valid to be assigned to HandlerType:
	//	*UrlMap_StaticFiles
	//	*UrlMap_Script
	//	*UrlMap_ApiEndpoint
	HandlerType isUrlMap_HandlerType `protobuf_oneof:"handler_type"`
	// Security (HTTPS) enforcement for this URL.
	SecurityLevel SecurityLevel `protobuf:"varint,5,opt,name=security_level,json=securityLevel,proto3,enum=google.appengine.v1.SecurityLevel" json:"security_level,omitempty"`
	// Level of login required to access this resource.
	Login LoginRequirement `protobuf:"varint,6,opt,name=login,proto3,enum=google.appengine.v1.LoginRequirement" json:"login,omitempty"`
	// Action to take when users access resources that require
	// authentication. Defaults to `redirect`.
	AuthFailAction AuthFailAction `protobuf:"varint,7,opt,name=auth_fail_action,json=authFailAction,proto3,enum=google.appengine.v1.AuthFailAction" json:"auth_fail_action,omitempty"`
	// `30x` code to use when performing redirects for the `secure` field.
	// Defaults to `302`.
	RedirectHttpResponseCode UrlMap_RedirectHttpResponseCode `protobuf:"varint,8,opt,name=redirect_http_response_code,json=redirectHttpResponseCode,proto3,enum=google.appengine.v1.UrlMap_RedirectHttpResponseCode" json:"redirect_http_response_code,omitempty"`
}

func (m *UrlMap) Reset()                    { *m = UrlMap{} }
func (m *UrlMap) String() string            { return proto.CompactTextString(m) }
func (*UrlMap) ProtoMessage()               {}
func (*UrlMap) Descriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{2} }

type isUrlMap_HandlerType interface {
	isUrlMap_HandlerType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UrlMap_StaticFiles struct {
	StaticFiles *StaticFilesHandler `protobuf:"bytes,2,opt,name=static_files,json=staticFiles,oneof"`
}
type UrlMap_Script struct {
	Script *ScriptHandler `protobuf:"bytes,3,opt,name=script,oneof"`
}
type UrlMap_ApiEndpoint struct {
	ApiEndpoint *ApiEndpointHandler `protobuf:"bytes,4,opt,name=api_endpoint,json=apiEndpoint,oneof"`
}

func (*UrlMap_StaticFiles) isUrlMap_HandlerType() {}
func (*UrlMap_Script) isUrlMap_HandlerType()      {}
func (*UrlMap_ApiEndpoint) isUrlMap_HandlerType() {}

func (m *UrlMap) GetHandlerType() isUrlMap_HandlerType {
	if m != nil {
		return m.HandlerType
	}
	return nil
}

func (m *UrlMap) GetUrlRegex() string {
	if m != nil {
		return m.UrlRegex
	}
	return ""
}

func (m *UrlMap) GetStaticFiles() *StaticFilesHandler {
	if x, ok := m.GetHandlerType().(*UrlMap_StaticFiles); ok {
		return x.StaticFiles
	}
	return nil
}

func (m *UrlMap) GetScript() *ScriptHandler {
	if x, ok := m.GetHandlerType().(*UrlMap_Script); ok {
		return x.Script
	}
	return nil
}

func (m *UrlMap) GetApiEndpoint() *ApiEndpointHandler {
	if x, ok := m.GetHandlerType().(*UrlMap_ApiEndpoint); ok {
		return x.ApiEndpoint
	}
	return nil
}

func (m *UrlMap) GetSecurityLevel() SecurityLevel {
	if m != nil {
		return m.SecurityLevel
	}
	return SecurityLevel_SECURE_UNSPECIFIED
}

func (m *UrlMap) GetLogin() LoginRequirement {
	if m != nil {
		return m.Login
	}
	return LoginRequirement_LOGIN_UNSPECIFIED
}

func (m *UrlMap) GetAuthFailAction() AuthFailAction {
	if m != nil {
		return m.AuthFailAction
	}
	return AuthFailAction_AUTH_FAIL_ACTION_UNSPECIFIED
}

func (m *UrlMap) GetRedirectHttpResponseCode() UrlMap_RedirectHttpResponseCode {
	if m != nil {
		return m.RedirectHttpResponseCode
	}
	return UrlMap_REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UrlMap) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UrlMap_OneofMarshaler, _UrlMap_OneofUnmarshaler, _UrlMap_OneofSizer, []interface{}{
		(*UrlMap_StaticFiles)(nil),
		(*UrlMap_Script)(nil),
		(*UrlMap_ApiEndpoint)(nil),
	}
}

func _UrlMap_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UrlMap)
	// handler_type
	switch x := m.HandlerType.(type) {
	case *UrlMap_StaticFiles:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StaticFiles); err != nil {
			return err
		}
	case *UrlMap_Script:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Script); err != nil {
			return err
		}
	case *UrlMap_ApiEndpoint:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApiEndpoint); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("UrlMap.HandlerType has unexpected type %T", x)
	}
	return nil
}

func _UrlMap_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UrlMap)
	switch tag {
	case 2: // handler_type.static_files
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StaticFilesHandler)
		err := b.DecodeMessage(msg)
		m.HandlerType = &UrlMap_StaticFiles{msg}
		return true, err
	case 3: // handler_type.script
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ScriptHandler)
		err := b.DecodeMessage(msg)
		m.HandlerType = &UrlMap_Script{msg}
		return true, err
	case 4: // handler_type.api_endpoint
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ApiEndpointHandler)
		err := b.DecodeMessage(msg)
		m.HandlerType = &UrlMap_ApiEndpoint{msg}
		return true, err
	default:
		return false, nil
	}
}

func _UrlMap_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UrlMap)
	// handler_type
	switch x := m.HandlerType.(type) {
	case *UrlMap_StaticFiles:
		s := proto.Size(x.StaticFiles)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UrlMap_Script:
		s := proto.Size(x.Script)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UrlMap_ApiEndpoint:
		s := proto.Size(x.ApiEndpoint)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Files served directly to the user for a given URL, such as images, CSS
// stylesheets, or JavaScript source files. Static file handlers describe which
// files in the application directory are static files, and which URLs serve
// them.
type StaticFilesHandler struct {
	// Path to the static files matched by the URL pattern, from the
	// application root directory. The path can refer to text matched in groupings
	// in the URL pattern.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Regular expression that matches the file paths for all files that should be
	// referenced by this handler.
	UploadPathRegex string `protobuf:"bytes,2,opt,name=upload_path_regex,json=uploadPathRegex,proto3" json:"upload_path_regex,omitempty"`
	// HTTP headers to use for all responses from these URLs.
	HttpHeaders map[string]string `protobuf:"bytes,3,rep,name=http_headers,json=httpHeaders" json:"http_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// MIME type used to serve all files served by this handler.
	//
	// Defaults to file-specific MIME types, which are derived from each file's
	// filename extension.
	MimeType string `protobuf:"bytes,4,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	// Time a static file served by this handler should be cached
	// by web proxies and browsers.
	Expiration *google_protobuf1.Duration `protobuf:"bytes,5,opt,name=expiration" json:"expiration,omitempty"`
	// Whether this handler should match the request if the file
	// referenced by the handler does not exist.
	RequireMatchingFile bool `protobuf:"varint,6,opt,name=require_matching_file,json=requireMatchingFile,proto3" json:"require_matching_file,omitempty"`
	// Whether files should also be uploaded as code data. By default, files
	// declared in static file handlers are uploaded as static
	// data and are only served to end users; they cannot be read by the
	// application. If enabled, uploads are charged against both your code and
	// static data storage resource quotas.
	ApplicationReadable bool `protobuf:"varint,7,opt,name=application_readable,json=applicationReadable,proto3" json:"application_readable,omitempty"`
}

func (m *StaticFilesHandler) Reset()                    { *m = StaticFilesHandler{} }
func (m *StaticFilesHandler) String() string            { return proto.CompactTextString(m) }
func (*StaticFilesHandler) ProtoMessage()               {}
func (*StaticFilesHandler) Descriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{3} }

func (m *StaticFilesHandler) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *StaticFilesHandler) GetUploadPathRegex() string {
	if m != nil {
		return m.UploadPathRegex
	}
	return ""
}

func (m *StaticFilesHandler) GetHttpHeaders() map[string]string {
	if m != nil {
		return m.HttpHeaders
	}
	return nil
}

func (m *StaticFilesHandler) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *StaticFilesHandler) GetExpiration() *google_protobuf1.Duration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *StaticFilesHandler) GetRequireMatchingFile() bool {
	if m != nil {
		return m.RequireMatchingFile
	}
	return false
}

func (m *StaticFilesHandler) GetApplicationReadable() bool {
	if m != nil {
		return m.ApplicationReadable
	}
	return false
}

// Executes a script to handle the request that matches the URL pattern.
type ScriptHandler struct {
	// Path to the script from the application root directory.
	ScriptPath string `protobuf:"bytes,1,opt,name=script_path,json=scriptPath,proto3" json:"script_path,omitempty"`
}

func (m *ScriptHandler) Reset()                    { *m = ScriptHandler{} }
func (m *ScriptHandler) String() string            { return proto.CompactTextString(m) }
func (*ScriptHandler) ProtoMessage()               {}
func (*ScriptHandler) Descriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{4} }

func (m *ScriptHandler) GetScriptPath() string {
	if m != nil {
		return m.ScriptPath
	}
	return ""
}

// Uses Google Cloud Endpoints to handle requests.
type ApiEndpointHandler struct {
	// Path to the script from the application root directory.
	ScriptPath string `protobuf:"bytes,1,opt,name=script_path,json=scriptPath,proto3" json:"script_path,omitempty"`
}

func (m *ApiEndpointHandler) Reset()                    { *m = ApiEndpointHandler{} }
func (m *ApiEndpointHandler) String() string            { return proto.CompactTextString(m) }
func (*ApiEndpointHandler) ProtoMessage()               {}
func (*ApiEndpointHandler) Descriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{5} }

func (m *ApiEndpointHandler) GetScriptPath() string {
	if m != nil {
		return m.ScriptPath
	}
	return ""
}

// Health checking configuration for VM instances. Unhealthy instances
// are killed and replaced with new instances. Only applicable for
// instances in App Engine flexible environment.
type HealthCheck struct {
	// Whether to explicitly disable health checks for this instance.
	DisableHealthCheck bool `protobuf:"varint,1,opt,name=disable_health_check,json=disableHealthCheck,proto3" json:"disable_health_check,omitempty"`
	// Host header to send when performing an HTTP health check.
	// Example: "myapp.appspot.com"
	Host string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	// Number of consecutive successful health checks required before receiving
	// traffic.
	HealthyThreshold uint32 `protobuf:"varint,3,opt,name=healthy_threshold,json=healthyThreshold,proto3" json:"healthy_threshold,omitempty"`
	// Number of consecutive failed health checks required before removing
	// traffic.
	UnhealthyThreshold uint32 `protobuf:"varint,4,opt,name=unhealthy_threshold,json=unhealthyThreshold,proto3" json:"unhealthy_threshold,omitempty"`
	// Number of consecutive failed health checks required before an instance is
	// restarted.
	RestartThreshold uint32 `protobuf:"varint,5,opt,name=restart_threshold,json=restartThreshold,proto3" json:"restart_threshold,omitempty"`
	// Interval between health checks.
	CheckInterval *google_protobuf1.Duration `protobuf:"bytes,6,opt,name=check_interval,json=checkInterval" json:"check_interval,omitempty"`
	// Time before the health check is considered failed.
	Timeout *google_protobuf1.Duration `protobuf:"bytes,7,opt,name=timeout" json:"timeout,omitempty"`
}

func (m *HealthCheck) Reset()                    { *m = HealthCheck{} }
func (m *HealthCheck) String() string            { return proto.CompactTextString(m) }
func (*HealthCheck) ProtoMessage()               {}
func (*HealthCheck) Descriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{6} }

func (m *HealthCheck) GetDisableHealthCheck() bool {
	if m != nil {
		return m.DisableHealthCheck
	}
	return false
}

func (m *HealthCheck) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *HealthCheck) GetHealthyThreshold() uint32 {
	if m != nil {
		return m.HealthyThreshold
	}
	return 0
}

func (m *HealthCheck) GetUnhealthyThreshold() uint32 {
	if m != nil {
		return m.UnhealthyThreshold
	}
	return 0
}

func (m *HealthCheck) GetRestartThreshold() uint32 {
	if m != nil {
		return m.RestartThreshold
	}
	return 0
}

func (m *HealthCheck) GetCheckInterval() *google_protobuf1.Duration {
	if m != nil {
		return m.CheckInterval
	}
	return nil
}

func (m *HealthCheck) GetTimeout() *google_protobuf1.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

// Third-party Python runtime library that is required by the application.
type Library struct {
	// Name of the library. Example: "django".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Version of the library to select, or "latest".
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *Library) Reset()                    { *m = Library{} }
func (m *Library) String() string            { return proto.CompactTextString(m) }
func (*Library) ProtoMessage()               {}
func (*Library) Descriptor() ([]byte, []int) { return fileDescriptorAppYaml, []int{7} }

func (m *Library) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Library) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterType((*ApiConfigHandler)(nil), "google.appengine.v1.ApiConfigHandler")
	proto.RegisterType((*ErrorHandler)(nil), "google.appengine.v1.ErrorHandler")
	proto.RegisterType((*UrlMap)(nil), "google.appengine.v1.UrlMap")
	proto.RegisterType((*StaticFilesHandler)(nil), "google.appengine.v1.StaticFilesHandler")
	proto.RegisterType((*ScriptHandler)(nil), "google.appengine.v1.ScriptHandler")
	proto.RegisterType((*ApiEndpointHandler)(nil), "google.appengine.v1.ApiEndpointHandler")
	proto.RegisterType((*HealthCheck)(nil), "google.appengine.v1.HealthCheck")
	proto.RegisterType((*Library)(nil), "google.appengine.v1.Library")
	proto.RegisterEnum("google.appengine.v1.AuthFailAction", AuthFailAction_name, AuthFailAction_value)
	proto.RegisterEnum("google.appengine.v1.LoginRequirement", LoginRequirement_name, LoginRequirement_value)
	proto.RegisterEnum("google.appengine.v1.SecurityLevel", SecurityLevel_name, SecurityLevel_value)
	proto.RegisterEnum("google.appengine.v1.ErrorHandler_ErrorCode", ErrorHandler_ErrorCode_name, ErrorHandler_ErrorCode_value)
	proto.RegisterEnum("google.appengine.v1.UrlMap_RedirectHttpResponseCode", UrlMap_RedirectHttpResponseCode_name, UrlMap_RedirectHttpResponseCode_value)
}
func (m *ApiConfigHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiConfigHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthFailAction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.AuthFailAction))
	}
	if m.Login != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.Login))
	}
	if len(m.Script) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.Script)))
		i += copy(dAtA[i:], m.Script)
	}
	if m.SecurityLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.SecurityLevel))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *ErrorHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.StaticFile) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.StaticFile)))
		i += copy(dAtA[i:], m.StaticFile)
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	return i, nil
}

func (m *UrlMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrlMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UrlRegex) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.UrlRegex)))
		i += copy(dAtA[i:], m.UrlRegex)
	}
	if m.HandlerType != nil {
		nn1, err := m.HandlerType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.SecurityLevel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.SecurityLevel))
	}
	if m.Login != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.Login))
	}
	if m.AuthFailAction != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.AuthFailAction))
	}
	if m.RedirectHttpResponseCode != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.RedirectHttpResponseCode))
	}
	return i, nil
}

func (m *UrlMap_StaticFiles) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StaticFiles != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.StaticFiles.Size()))
		n2, err := m.StaticFiles.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *UrlMap_Script) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Script != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.Script.Size()))
		n3, err := m.Script.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *UrlMap_ApiEndpoint) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ApiEndpoint != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.ApiEndpoint.Size()))
		n4, err := m.ApiEndpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *StaticFilesHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticFilesHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.UploadPathRegex) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.UploadPathRegex)))
		i += copy(dAtA[i:], m.UploadPathRegex)
	}
	if len(m.HttpHeaders) > 0 {
		for k, _ := range m.HttpHeaders {
			dAtA[i] = 0x1a
			i++
			v := m.HttpHeaders[k]
			mapSize := 1 + len(k) + sovAppYaml(uint64(len(k))) + 1 + len(v) + sovAppYaml(uint64(len(v)))
			i = encodeVarintAppYaml(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAppYaml(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAppYaml(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.Expiration != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.Expiration.Size()))
		n5, err := m.Expiration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.RequireMatchingFile {
		dAtA[i] = 0x30
		i++
		if m.RequireMatchingFile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ApplicationReadable {
		dAtA[i] = 0x38
		i++
		if m.ApplicationReadable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ScriptHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScriptHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ScriptPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.ScriptPath)))
		i += copy(dAtA[i:], m.ScriptPath)
	}
	return i, nil
}

func (m *ApiEndpointHandler) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApiEndpointHandler) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ScriptPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.ScriptPath)))
		i += copy(dAtA[i:], m.ScriptPath)
	}
	return i, nil
}

func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DisableHealthCheck {
		dAtA[i] = 0x8
		i++
		if m.DisableHealthCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if m.HealthyThreshold != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.HealthyThreshold))
	}
	if m.UnhealthyThreshold != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.UnhealthyThreshold))
	}
	if m.RestartThreshold != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.RestartThreshold))
	}
	if m.CheckInterval != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.CheckInterval.Size()))
		n6, err := m.CheckInterval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Timeout != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(m.Timeout.Size()))
		n7, err := m.Timeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *Library) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Library) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAppYaml(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func encodeFixed64AppYaml(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32AppYaml(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAppYaml(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ApiConfigHandler) Size() (n int) {
	var l int
	_ = l
	if m.AuthFailAction != 0 {
		n += 1 + sovAppYaml(uint64(m.AuthFailAction))
	}
	if m.Login != 0 {
		n += 1 + sovAppYaml(uint64(m.Login))
	}
	l = len(m.Script)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	if m.SecurityLevel != 0 {
		n += 1 + sovAppYaml(uint64(m.SecurityLevel))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	return n
}

func (m *ErrorHandler) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovAppYaml(uint64(m.ErrorCode))
	}
	l = len(m.StaticFile)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	return n
}

func (m *UrlMap) Size() (n int) {
	var l int
	_ = l
	l = len(m.UrlRegex)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	if m.HandlerType != nil {
		n += m.HandlerType.Size()
	}
	if m.SecurityLevel != 0 {
		n += 1 + sovAppYaml(uint64(m.SecurityLevel))
	}
	if m.Login != 0 {
		n += 1 + sovAppYaml(uint64(m.Login))
	}
	if m.AuthFailAction != 0 {
		n += 1 + sovAppYaml(uint64(m.AuthFailAction))
	}
	if m.RedirectHttpResponseCode != 0 {
		n += 1 + sovAppYaml(uint64(m.RedirectHttpResponseCode))
	}
	return n
}

func (m *UrlMap_StaticFiles) Size() (n int) {
	var l int
	_ = l
	if m.StaticFiles != nil {
		l = m.StaticFiles.Size()
		n += 1 + l + sovAppYaml(uint64(l))
	}
	return n
}
func (m *UrlMap_Script) Size() (n int) {
	var l int
	_ = l
	if m.Script != nil {
		l = m.Script.Size()
		n += 1 + l + sovAppYaml(uint64(l))
	}
	return n
}
func (m *UrlMap_ApiEndpoint) Size() (n int) {
	var l int
	_ = l
	if m.ApiEndpoint != nil {
		l = m.ApiEndpoint.Size()
		n += 1 + l + sovAppYaml(uint64(l))
	}
	return n
}
func (m *StaticFilesHandler) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	l = len(m.UploadPathRegex)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	if len(m.HttpHeaders) > 0 {
		for k, v := range m.HttpHeaders {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAppYaml(uint64(len(k))) + 1 + len(v) + sovAppYaml(uint64(len(v)))
			n += mapEntrySize + 1 + sovAppYaml(uint64(mapEntrySize))
		}
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovAppYaml(uint64(l))
	}
	if m.RequireMatchingFile {
		n += 2
	}
	if m.ApplicationReadable {
		n += 2
	}
	return n
}

func (m *ScriptHandler) Size() (n int) {
	var l int
	_ = l
	l = len(m.ScriptPath)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	return n
}

func (m *ApiEndpointHandler) Size() (n int) {
	var l int
	_ = l
	l = len(m.ScriptPath)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	return n
}

func (m *HealthCheck) Size() (n int) {
	var l int
	_ = l
	if m.DisableHealthCheck {
		n += 2
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	if m.HealthyThreshold != 0 {
		n += 1 + sovAppYaml(uint64(m.HealthyThreshold))
	}
	if m.UnhealthyThreshold != 0 {
		n += 1 + sovAppYaml(uint64(m.UnhealthyThreshold))
	}
	if m.RestartThreshold != 0 {
		n += 1 + sovAppYaml(uint64(m.RestartThreshold))
	}
	if m.CheckInterval != nil {
		l = m.CheckInterval.Size()
		n += 1 + l + sovAppYaml(uint64(l))
	}
	if m.Timeout != nil {
		l = m.Timeout.Size()
		n += 1 + l + sovAppYaml(uint64(l))
	}
	return n
}

func (m *Library) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAppYaml(uint64(l))
	}
	return n
}

func sovAppYaml(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAppYaml(x uint64) (n int) {
	return sovAppYaml(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ApiConfigHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppYaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiConfigHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiConfigHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthFailAction", wireType)
			}
			m.AuthFailAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthFailAction |= (AuthFailAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			m.Login = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Login |= (LoginRequirement(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Script = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityLevel", wireType)
			}
			m.SecurityLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityLevel |= (SecurityLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppYaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppYaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppYaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ErrorHandler_ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppYaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppYaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrlMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppYaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UrlMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UrlMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticFilesHandler{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HandlerType = &UrlMap_StaticFiles{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScriptHandler{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HandlerType = &UrlMap_Script{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiEndpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ApiEndpointHandler{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HandlerType = &UrlMap_ApiEndpoint{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityLevel", wireType)
			}
			m.SecurityLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecurityLevel |= (SecurityLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			m.Login = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Login |= (LoginRequirement(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthFailAction", wireType)
			}
			m.AuthFailAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthFailAction |= (AuthFailAction(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectHttpResponseCode", wireType)
			}
			m.RedirectHttpResponseCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedirectHttpResponseCode |= (UrlMap_RedirectHttpResponseCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppYaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppYaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticFilesHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppYaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticFilesHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticFilesHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadPathRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadPathRegex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpHeaders == nil {
				m.HttpHeaders = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppYaml
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppYaml
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAppYaml
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppYaml
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAppYaml
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAppYaml(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAppYaml
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HttpHeaders[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &google_protobuf1.Duration{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireMatchingFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireMatchingFile = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationReadable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApplicationReadable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAppYaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppYaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScriptHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppYaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScriptHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScriptHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppYaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppYaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApiEndpointHandler) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppYaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApiEndpointHandler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApiEndpointHandler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppYaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppYaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppYaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableHealthCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableHealthCheck = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthyThreshold", wireType)
			}
			m.HealthyThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthyThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnhealthyThreshold", wireType)
			}
			m.UnhealthyThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnhealthyThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartThreshold", wireType)
			}
			m.RestartThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartThreshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckInterval == nil {
				m.CheckInterval = &google_protobuf1.Duration{}
			}
			if err := m.CheckInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = &google_protobuf1.Duration{}
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppYaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppYaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Library) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppYaml
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Library: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Library: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppYaml
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppYaml(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAppYaml
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppYaml(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppYaml
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppYaml
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAppYaml
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAppYaml
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAppYaml(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAppYaml = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppYaml   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/appengine/v1/app_yaml.proto", fileDescriptorAppYaml) }

var fileDescriptorAppYaml = []byte{
	// 1250 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x6e, 0x13, 0x47,
	0x14, 0x66, 0xed, 0xfc, 0x1e, 0x3b, 0x66, 0x33, 0x01, 0xea, 0x04, 0x08, 0xa9, 0x51, 0x05, 0x4a,
	0x24, 0x9b, 0x24, 0xad, 0xa0, 0x05, 0x55, 0x5d, 0xec, 0x4d, 0xbd, 0x95, 0x13, 0x9b, 0xb1, 0x4d,
	0x05, 0xbd, 0x18, 0x4d, 0xec, 0x89, 0x77, 0xc5, 0x7a, 0x77, 0x3b, 0x3b, 0x8e, 0xf0, 0x73, 0x54,
	0x7d, 0x0f, 0x6e, 0xfb, 0x06, 0xbd, 0xec, 0x4d, 0xaf, 0x7a, 0x53, 0xf1, 0x24, 0xd5, 0xcc, 0x8e,
	0xff, 0x12, 0x87, 0x54, 0xdc, 0xcd, 0x39, 0xe7, 0xfb, 0xce, 0xce, 0xf9, 0x9d, 0x85, 0x42, 0x2f,
	0x0c, 0x7b, 0x3e, 0x2b, 0xd1, 0x28, 0x62, 0x41, 0xcf, 0x0b, 0x58, 0xe9, 0x7c, 0x5f, 0x0a, 0x64,
	0x48, 0xfb, 0x7e, 0x31, 0xe2, 0xa1, 0x08, 0xd1, 0x46, 0x82, 0x29, 0x8e, 0x31, 0xc5, 0xf3, 0xfd,
	0xad, 0x7b, 0x63, 0xa2, 0x57, 0xa2, 0x41, 0x10, 0x0a, 0x2a, 0xbc, 0x30, 0x88, 0x13, 0xca, 0xd6,
	0xb6, 0xb6, 0x2a, 0xe9, 0x74, 0x70, 0x56, 0xea, 0x0e, 0xb8, 0x02, 0x24, 0xf6, 0xc2, 0x6f, 0x29,
	0x30, 0xad, 0xc8, 0x2b, 0x87, 0xc1, 0x99, 0xd7, 0xab, 0xd2, 0xa0, 0xeb, 0x33, 0x8e, 0x8e, 0xc1,
	0xa4, 0x03, 0xe1, 0x92, 0x33, 0xea, 0xf9, 0x84, 0x76, 0x24, 0x3c, 0x6f, 0xec, 0x18, 0x8f, 0x73,
	0x07, 0x0f, 0x8b, 0x73, 0xae, 0x50, 0xb4, 0x06, 0xc2, 0x3d, 0xa2, 0x9e, 0x6f, 0x29, 0x28, 0xce,
	0xd1, 0x19, 0x19, 0x3d, 0x87, 0x45, 0x3f, 0xec, 0x79, 0x41, 0x3e, 0xa5, 0x7c, 0x7c, 0x35, 0xd7,
	0x47, 0x4d, 0x22, 0x30, 0xfb, 0x75, 0xe0, 0x71, 0xd6, 0x67, 0x81, 0xc0, 0x09, 0x07, 0xdd, 0x81,
	0xa5, 0xb8, 0xc3, 0xbd, 0x48, 0xe4, 0xd3, 0x3b, 0xc6, 0xe3, 0x55, 0xac, 0x25, 0xe4, 0x40, 0x2e,
	0x66, 0x9d, 0x01, 0xf7, 0xc4, 0x90, 0xf8, 0xec, 0x9c, 0xf9, 0xf9, 0x05, 0xe5, 0xbd, 0x30, 0xd7,
	0x7b, 0x53, 0x43, 0x6b, 0x12, 0x89, 0xd7, 0xe2, 0x69, 0x11, 0x99, 0x90, 0x1e, 0x70, 0x3f, 0xbf,
	0xa8, 0xfc, 0xcb, 0x63, 0xe1, 0x43, 0x0a, 0xb2, 0x36, 0xe7, 0x21, 0x1f, 0x65, 0xe4, 0x27, 0x00,
	0x26, 0x65, 0xd2, 0x09, 0xbb, 0x4c, 0xe7, 0x62, 0x6f, 0xee, 0x97, 0xa6, 0x69, 0x89, 0x50, 0x0e,
	0xbb, 0x0c, 0xaf, 0xb2, 0xd1, 0x11, 0x3d, 0x80, 0x4c, 0x2c, 0x8b, 0xd4, 0x21, 0x67, 0x9e, 0xcf,
	0x54, 0x52, 0x56, 0x31, 0x24, 0xaa, 0x23, 0xcf, 0x67, 0xe8, 0x2e, 0xac, 0xf6, 0xbd, 0x3e, 0x23,
	0x62, 0x18, 0x31, 0x1d, 0xf5, 0x8a, 0x54, 0xb4, 0x86, 0x11, 0x2b, 0xfc, 0x6e, 0xc0, 0xea, 0xd8,
	0x2d, 0xda, 0x82, 0x3b, 0x36, 0xc6, 0x75, 0x4c, 0xca, 0xf5, 0x8a, 0x4d, 0xda, 0x27, 0xcd, 0x86,
	0x5d, 0x76, 0x8e, 0x1c, 0xbb, 0x62, 0xde, 0x40, 0x77, 0x00, 0x4d, 0xd9, 0x2a, 0xf6, 0x91, 0xd5,
	0xae, 0xb5, 0xcc, 0x1b, 0x68, 0x13, 0x6e, 0x4f, 0xe9, 0xeb, 0xaf, 0x6d, 0x4c, 0x5e, 0xb5, 0xeb,
	0x2d, 0xcb, 0x34, 0xd0, 0x7d, 0xd8, 0x9c, 0xa6, 0xd4, 0x9b, 0xc4, 0x6a, 0x38, 0xa4, 0x62, 0x9f,
	0x38, 0x56, 0xcd, 0x4c, 0x5d, 0xf0, 0xd8, 0x72, 0x8e, 0xed, 0x7a, 0xbb, 0x65, 0xa6, 0xb7, 0x52,
	0xa6, 0x51, 0xf8, 0x63, 0x09, 0x96, 0xda, 0xdc, 0x3f, 0xa6, 0x91, 0xbc, 0xff, 0x80, 0xfb, 0x84,
	0xb3, 0x1e, 0x7b, 0xaf, 0x72, 0xb5, 0x8a, 0x57, 0x06, 0xdc, 0xc7, 0x52, 0x46, 0x35, 0xc8, 0x4e,
	0x45, 0x1f, 0xab, 0xf0, 0x33, 0x07, 0x8f, 0xe6, 0x57, 0x6d, 0x9c, 0x93, 0x58, 0x67, 0xb4, 0x7a,
	0x03, 0x67, 0x26, 0x99, 0x8a, 0xd1, 0x8b, 0x99, 0xee, 0xc8, 0x5c, 0x55, 0x7d, 0x05, 0x99, 0xb8,
	0x18, 0xf5, 0x50, 0x0d, 0xb2, 0x34, 0xf2, 0x08, 0x0b, 0xba, 0x51, 0xe8, 0x05, 0x42, 0x75, 0xd0,
	0x55, 0x77, 0xb1, 0x22, 0xcf, 0xd6, 0xb8, 0xa9, 0xbb, 0xd0, 0x89, 0x76, 0x4e, 0x47, 0x2e, 0x7e,
	0x6e, 0x47, 0x8e, 0x27, 0x66, 0xe9, 0x33, 0x26, 0x66, 0xde, 0xf4, 0x2e, 0x7f, 0xfe, 0xf4, 0xc6,
	0x70, 0x97, 0xb3, 0xae, 0xc7, 0x59, 0x47, 0x10, 0x57, 0x88, 0x88, 0x70, 0x16, 0x47, 0x61, 0x10,
	0xb3, 0x64, 0x16, 0x56, 0x94, 0xe7, 0xaf, 0xe7, 0x7a, 0x4e, 0xfa, 0xa1, 0x88, 0x35, 0xbd, 0x2a,
	0x44, 0x84, 0x35, 0x59, 0x0d, 0x45, 0x9e, 0x5f, 0x61, 0x29, 0xfc, 0x63, 0x40, 0xfe, 0x2a, 0x1a,
	0xda, 0x83, 0x47, 0xd8, 0xae, 0x38, 0xd8, 0x2e, 0xb7, 0x48, 0xb5, 0xd5, 0x6a, 0x10, 0x6c, 0x37,
	0x1b, 0xf5, 0x93, 0xa6, 0x3d, 0x6f, 0x0a, 0x1e, 0xc2, 0x83, 0x4f, 0x81, 0x0f, 0x9f, 0xec, 0x9b,
	0xc6, 0xf5, 0xa0, 0x03, 0x33, 0x75, 0x3d, 0xe8, 0xd0, 0x4c, 0x5f, 0x0f, 0x7a, 0x6a, 0x2e, 0xbc,
	0xcc, 0x41, 0xd6, 0x4d, 0x7a, 0x48, 0xcd, 0x78, 0xe1, 0x43, 0x1a, 0xd0, 0xe5, 0x5e, 0x47, 0x08,
	0x16, 0x22, 0x2a, 0x5c, 0x3d, 0x42, 0xea, 0x8c, 0x76, 0x61, 0x7d, 0x10, 0xf9, 0x21, 0xed, 0x12,
	0x29, 0xea, 0x19, 0x4b, 0x56, 0xc8, 0xcd, 0xc4, 0xd0, 0xa0, 0xc2, 0x4d, 0x46, 0xed, 0x17, 0xc8,
	0xaa, 0x82, 0xb9, 0x8c, 0x76, 0x19, 0x8f, 0xf3, 0xe9, 0x9d, 0xf4, 0xe3, 0xcc, 0xc1, 0xb3, 0xff,
	0x39, 0x6a, 0x45, 0x99, 0xf7, 0x6a, 0x42, 0xb5, 0x03, 0xc1, 0x87, 0x38, 0xe3, 0x4e, 0x34, 0xb3,
	0x4b, 0x6a, 0x61, 0x76, 0x49, 0xa1, 0x6f, 0x01, 0xd8, 0xfb, 0xc8, 0x4b, 0x5e, 0x1a, 0x35, 0x06,
	0x99, 0x83, 0xcd, 0xd1, 0x77, 0x47, 0x4f, 0x51, 0xb1, 0xa2, 0x9f, 0x22, 0x3c, 0x05, 0x46, 0x07,
	0x70, 0x9b, 0x27, 0x3d, 0x4d, 0xfa, 0x54, 0x74, 0x5c, 0x2f, 0xe8, 0x25, 0x7b, 0x52, 0x8e, 0xc2,
	0x0a, 0xde, 0xd0, 0xc6, 0x63, 0x6d, 0x53, 0x0b, 0x73, 0x1f, 0x6e, 0xd1, 0x28, 0xf2, 0xbd, 0x8e,
	0x72, 0x41, 0x38, 0xa3, 0x5d, 0x7a, 0xea, 0x33, 0xd5, 0xf5, 0x2b, 0x78, 0x63, 0xca, 0x86, 0xb5,
	0x69, 0xeb, 0x7b, 0x30, 0x2f, 0xc6, 0x27, 0xdf, 0x81, 0x77, 0x6c, 0xa8, 0xd3, 0x2d, 0x8f, 0xe8,
	0x16, 0x2c, 0x9e, 0x53, 0x7f, 0x30, 0x5a, 0xd2, 0x89, 0xf0, 0x5d, 0xea, 0x99, 0x51, 0x78, 0x02,
	0x6b, 0x33, 0x5b, 0x45, 0x6d, 0x75, 0xa5, 0x20, 0x53, 0x35, 0x83, 0x44, 0x25, 0x4b, 0x52, 0xf8,
	0x06, 0xd0, 0xe5, 0x1d, 0x72, 0x3d, 0xed, 0xef, 0x14, 0x64, 0xaa, 0x8c, 0xfa, 0xc2, 0x2d, 0xbb,
	0xac, 0xf3, 0x0e, 0x3d, 0x81, 0x5b, 0x5d, 0x2f, 0x96, 0x31, 0xc8, 0xba, 0xfa, 0xc2, 0x25, 0x1d,
	0xa9, 0x57, 0xcc, 0x15, 0x8c, 0xb4, 0x6d, 0x9a, 0x81, 0x60, 0xc1, 0x0d, 0x63, 0xa1, 0x63, 0x50,
	0x67, 0xb4, 0x07, 0xeb, 0x09, 0x7b, 0x48, 0x84, 0xcb, 0x59, 0xec, 0x86, 0x7e, 0x57, 0xad, 0xd0,
	0x35, 0x6c, 0x6a, 0x43, 0x6b, 0xa4, 0x47, 0x25, 0xd8, 0x18, 0x04, 0x97, 0xe1, 0x0b, 0x0a, 0x8e,
	0xc6, 0xa6, 0x09, 0x61, 0x0f, 0xd6, 0x39, 0x8b, 0x05, 0xe5, 0x62, 0x0a, 0xbe, 0x98, 0x78, 0xd7,
	0x86, 0x09, 0xf8, 0x07, 0xc8, 0xa9, 0x08, 0x88, 0x17, 0x08, 0xc6, 0xcf, 0xa9, 0xaf, 0x2a, 0xfd,
	0xc9, 0x7e, 0x59, 0x53, 0x04, 0x47, 0xe3, 0xd1, 0x21, 0x2c, 0x0b, 0xaf, 0xcf, 0xc2, 0x81, 0x50,
	0x15, 0xff, 0x24, 0x75, 0x84, 0x2c, 0x3c, 0x85, 0xe5, 0x9a, 0x77, 0xca, 0x29, 0x1f, 0xca, 0x04,
	0x05, 0xb4, 0xcf, 0x46, 0x73, 0x26, 0xcf, 0x28, 0x0f, 0xcb, 0xe7, 0x8c, 0xc7, 0xb2, 0x7d, 0x93,
	0xbc, 0x8d, 0xc4, 0x5d, 0x01, 0xb9, 0xd9, 0x8d, 0x89, 0x76, 0xe0, 0x9e, 0xd5, 0x6e, 0x55, 0xc9,
	0x91, 0xe5, 0xd4, 0x88, 0x55, 0x6e, 0x39, 0xf5, 0x93, 0x0b, 0x4b, 0xe8, 0x3e, 0x6c, 0x5e, 0x42,
	0x8c, 0xd6, 0x84, 0x69, 0xa0, 0x2f, 0xe1, 0xfe, 0x1c, 0x07, 0x52, 0x55, 0xc7, 0xce, 0x5b, 0xbb,
	0x62, 0xa6, 0x76, 0x4f, 0xc1, 0xbc, 0xb8, 0xef, 0xd1, 0x6d, 0x58, 0xaf, 0xd5, 0x7f, 0x74, 0x2e,
	0x7e, 0x0c, 0x41, 0x2e, 0x51, 0xd7, 0x1b, 0xd2, 0x93, 0x55, 0x33, 0x0d, 0x74, 0x13, 0x32, 0x89,
	0xce, 0xaa, 0x1c, 0x3b, 0x27, 0x66, 0x6a, 0x02, 0xc2, 0xf6, 0xab, 0xb6, 0x83, 0xed, 0x8a, 0x99,
	0xde, 0x1d, 0xc2, 0xda, 0xcc, 0xab, 0x24, 0xdf, 0xfb, 0xa6, 0x5d, 0x6e, 0x63, 0xfb, 0xf2, 0x17,
	0xb4, 0x7e, 0xf2, 0x57, 0x61, 0x42, 0x56, 0xeb, 0x4e, 0xec, 0xd7, 0x36, 0x36, 0x0d, 0xb4, 0x01,
	0x37, 0xb5, 0x66, 0x7c, 0x91, 0x14, 0x5a, 0x87, 0x35, 0xad, 0xb4, 0x6a, 0x3f, 0x5b, 0x6f, 0x9a,
	0xc9, 0xdf, 0xc3, 0xcb, 0xf8, 0xcf, 0x8f, 0xdb, 0xc6, 0x5f, 0x1f, 0xb7, 0x8d, 0x7f, 0x3f, 0x6e,
	0x1b, 0xf0, 0x45, 0x27, 0xec, 0xcf, 0xdb, 0x52, 0x2f, 0xb3, 0x56, 0x14, 0xbd, 0xa1, 0x7d, 0xbf,
	0x21, 0xeb, 0xda, 0x30, 0xde, 0xbe, 0xd0, 0xa0, 0x5e, 0xe8, 0xd3, 0xa0, 0x57, 0x0c, 0x79, 0xaf,
	0xd4, 0x63, 0x81, 0xaa, 0x7a, 0x29, 0x31, 0xd1, 0xc8, 0x8b, 0x67, 0xfe, 0xa9, 0x9f, 0x8f, 0x85,
	0xd3, 0x25, 0x05, 0x3c, 0xfc, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x8f, 0x0c, 0xe7, 0x7b, 0x0b,
	0x00, 0x00,
}
