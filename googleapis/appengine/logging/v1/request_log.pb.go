// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/appengine/logging/v1/request_log.proto

/*
	Package logging is a generated protocol buffer package.

	It is generated from these files:
		google/appengine/logging/v1/request_log.proto

	It has these top-level messages:
		LogLine
		SourceLocation
		SourceReference
		RequestLog
*/
package logging

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_logging_type "google.golang.org/genproto/googleapis/logging/type"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Application log line emitted while processing a request.
type LogLine struct {
	// Approximate time when this log entry was made.
	Time *google_protobuf2.Timestamp `protobuf:"bytes,1,opt,name=time" json:"time,omitempty"`
	// Severity of this log entry.
	Severity google_logging_type.LogSeverity `protobuf:"varint,2,opt,name=severity,proto3,enum=google.logging.type.LogSeverity" json:"severity,omitempty"`
	// App-provided log message.
	LogMessage string `protobuf:"bytes,3,opt,name=log_message,json=logMessage,proto3" json:"log_message,omitempty"`
	// Where in the source code this log message was written.
	SourceLocation *SourceLocation `protobuf:"bytes,4,opt,name=source_location,json=sourceLocation" json:"source_location,omitempty"`
}

func (m *LogLine) Reset()                    { *m = LogLine{} }
func (m *LogLine) String() string            { return proto.CompactTextString(m) }
func (*LogLine) ProtoMessage()               {}
func (*LogLine) Descriptor() ([]byte, []int) { return fileDescriptorRequestLog, []int{0} }

func (m *LogLine) GetTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *LogLine) GetSeverity() google_logging_type.LogSeverity {
	if m != nil {
		return m.Severity
	}
	return google_logging_type.LogSeverity_DEFAULT
}

func (m *LogLine) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

func (m *LogLine) GetSourceLocation() *SourceLocation {
	if m != nil {
		return m.SourceLocation
	}
	return nil
}

// Specifies a location in a source code file.
type SourceLocation struct {
	// Source file name. Depending on the runtime environment, this might be a
	// simple name or a fully-qualified name.
	File string `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	// Line within the source file.
	Line int64 `protobuf:"varint,2,opt,name=line,proto3" json:"line,omitempty"`
	// Human-readable name of the function or method being invoked, with optional
	// context such as the class or package name. This information is used in
	// contexts such as the logs viewer, where a file and line number are less
	// meaningful. The format can vary by language. For example:
	// `qual.if.ied.Class.method` (Java), `dir/package.func` (Go), `function`
	// (Python).
	FunctionName string `protobuf:"bytes,3,opt,name=function_name,json=functionName,proto3" json:"function_name,omitempty"`
}

func (m *SourceLocation) Reset()                    { *m = SourceLocation{} }
func (m *SourceLocation) String() string            { return proto.CompactTextString(m) }
func (*SourceLocation) ProtoMessage()               {}
func (*SourceLocation) Descriptor() ([]byte, []int) { return fileDescriptorRequestLog, []int{1} }

func (m *SourceLocation) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

func (m *SourceLocation) GetLine() int64 {
	if m != nil {
		return m.Line
	}
	return 0
}

func (m *SourceLocation) GetFunctionName() string {
	if m != nil {
		return m.FunctionName
	}
	return ""
}

// A reference to a particular snapshot of the source tree used to build and
// deploy an application.
type SourceReference struct {
	// Optional. A URI string identifying the repository.
	// Example: "https://github.com/GoogleCloudPlatform/kubernetes.git"
	Repository string `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// The canonical and persistent identifier of the deployed revision.
	// Example (git): "0035781c50ec7aa23385dc841529ce8a4b70db1b"
	RevisionId string `protobuf:"bytes,2,opt,name=revision_id,json=revisionId,proto3" json:"revision_id,omitempty"`
}

func (m *SourceReference) Reset()                    { *m = SourceReference{} }
func (m *SourceReference) String() string            { return proto.CompactTextString(m) }
func (*SourceReference) ProtoMessage()               {}
func (*SourceReference) Descriptor() ([]byte, []int) { return fileDescriptorRequestLog, []int{2} }

func (m *SourceReference) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *SourceReference) GetRevisionId() string {
	if m != nil {
		return m.RevisionId
	}
	return ""
}

// Complete log information about a single HTTP request to an App Engine
// application.
type RequestLog struct {
	// Application that handled this request.
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// Module of the application that handled this request.
	ModuleId string `protobuf:"bytes,37,opt,name=module_id,json=moduleId,proto3" json:"module_id,omitempty"`
	// Version of the application that handled this request.
	VersionId string `protobuf:"bytes,2,opt,name=version_id,json=versionId,proto3" json:"version_id,omitempty"`
	// Globally unique identifier for a request, which is based on the request
	// start time.  Request IDs for requests which started later will compare
	// greater as strings than those for requests which started earlier.
	RequestId string `protobuf:"bytes,3,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Origin IP address.
	Ip string `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	// Time when the request started.
	StartTime *google_protobuf2.Timestamp `protobuf:"bytes,6,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Time when the request finished.
	EndTime *google_protobuf2.Timestamp `protobuf:"bytes,7,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// Latency of the request.
	Latency *google_protobuf1.Duration `protobuf:"bytes,8,opt,name=latency" json:"latency,omitempty"`
	// Number of CPU megacycles used to process request.
	MegaCycles int64 `protobuf:"varint,9,opt,name=mega_cycles,json=megaCycles,proto3" json:"mega_cycles,omitempty"`
	// Request method. Example: `"GET"`, `"HEAD"`, `"PUT"`, `"POST"`, `"DELETE"`.
	Method string `protobuf:"bytes,10,opt,name=method,proto3" json:"method,omitempty"`
	// Contains the path and query portion of the URL that was requested. For
	// example, if the URL was "http://example.com/app?name=val", the resource
	// would be "/app?name=val".  The fragment identifier, which is identified by
	// the `#` character, is not included.
	Resource string `protobuf:"bytes,11,opt,name=resource,proto3" json:"resource,omitempty"`
	// HTTP version of request. Example: `"HTTP/1.1"`.
	HttpVersion string `protobuf:"bytes,12,opt,name=http_version,json=httpVersion,proto3" json:"http_version,omitempty"`
	// HTTP response status code. Example: 200, 404.
	Status int32 `protobuf:"varint,13,opt,name=status,proto3" json:"status,omitempty"`
	// Size in bytes sent back to client by request.
	ResponseSize int64 `protobuf:"varint,14,opt,name=response_size,json=responseSize,proto3" json:"response_size,omitempty"`
	// Referrer URL of request.
	Referrer string `protobuf:"bytes,15,opt,name=referrer,proto3" json:"referrer,omitempty"`
	// User agent that made the request.
	UserAgent string `protobuf:"bytes,16,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
	// The logged-in user who made the request.
	//
	// Most likely, this is the part of the user's email before the `@` sign.  The
	// field value is the same for different requests from the same user, but
	// different users can have similar names.  This information is also
	// available to the application via the App Engine Users API.
	//
	// This field will be populated starting with App Engine 1.9.21.
	Nickname string `protobuf:"bytes,40,opt,name=nickname,proto3" json:"nickname,omitempty"`
	// File or class that handled the request.
	UrlMapEntry string `protobuf:"bytes,17,opt,name=url_map_entry,json=urlMapEntry,proto3" json:"url_map_entry,omitempty"`
	// Internet host and port number of the resource being requested.
	Host string `protobuf:"bytes,20,opt,name=host,proto3" json:"host,omitempty"`
	// An indication of the relative cost of serving this request.
	Cost float64 `protobuf:"fixed64,21,opt,name=cost,proto3" json:"cost,omitempty"`
	// Queue name of the request, in the case of an offline request.
	TaskQueueName string `protobuf:"bytes,22,opt,name=task_queue_name,json=taskQueueName,proto3" json:"task_queue_name,omitempty"`
	// Task name of the request, in the case of an offline request.
	TaskName string `protobuf:"bytes,23,opt,name=task_name,json=taskName,proto3" json:"task_name,omitempty"`
	// Whether this was a loading request for the instance.
	WasLoadingRequest bool `protobuf:"varint,24,opt,name=was_loading_request,json=wasLoadingRequest,proto3" json:"was_loading_request,omitempty"`
	// Time this request spent in the pending request queue.
	PendingTime *google_protobuf1.Duration `protobuf:"bytes,25,opt,name=pending_time,json=pendingTime" json:"pending_time,omitempty"`
	// If the instance processing this request belongs to a manually scaled
	// module, then this is the 0-based index of the instance. Otherwise, this
	// value is -1.
	InstanceIndex int32 `protobuf:"varint,26,opt,name=instance_index,json=instanceIndex,proto3" json:"instance_index,omitempty"`
	// Whether this request is finished or active.
	Finished bool `protobuf:"varint,27,opt,name=finished,proto3" json:"finished,omitempty"`
	// Whether this is the first `RequestLog` entry for this request.  If an
	// active request has several `RequestLog` entries written to Stackdriver
	// Logging, then this field will be set for one of them.
	First bool `protobuf:"varint,42,opt,name=first,proto3" json:"first,omitempty"`
	// An identifier for the instance that handled the request.
	InstanceId string `protobuf:"bytes,28,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	// A list of log lines emitted by the application while serving this request.
	Line []*LogLine `protobuf:"bytes,29,rep,name=line" json:"line,omitempty"`
	// App Engine release version.
	AppEngineRelease string `protobuf:"bytes,38,opt,name=app_engine_release,json=appEngineRelease,proto3" json:"app_engine_release,omitempty"`
	// Stackdriver Trace identifier for this request.
	TraceId string `protobuf:"bytes,39,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	// Source code for the application that handled this request. There can be
	// more than one source reference per deployed application if source code is
	// distributed among multiple repositories.
	SourceReference []*SourceReference `protobuf:"bytes,41,rep,name=source_reference,json=sourceReference" json:"source_reference,omitempty"`
}

func (m *RequestLog) Reset()                    { *m = RequestLog{} }
func (m *RequestLog) String() string            { return proto.CompactTextString(m) }
func (*RequestLog) ProtoMessage()               {}
func (*RequestLog) Descriptor() ([]byte, []int) { return fileDescriptorRequestLog, []int{3} }

func (m *RequestLog) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *RequestLog) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *RequestLog) GetVersionId() string {
	if m != nil {
		return m.VersionId
	}
	return ""
}

func (m *RequestLog) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *RequestLog) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *RequestLog) GetStartTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *RequestLog) GetEndTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *RequestLog) GetLatency() *google_protobuf1.Duration {
	if m != nil {
		return m.Latency
	}
	return nil
}

func (m *RequestLog) GetMegaCycles() int64 {
	if m != nil {
		return m.MegaCycles
	}
	return 0
}

func (m *RequestLog) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *RequestLog) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *RequestLog) GetHttpVersion() string {
	if m != nil {
		return m.HttpVersion
	}
	return ""
}

func (m *RequestLog) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *RequestLog) GetResponseSize() int64 {
	if m != nil {
		return m.ResponseSize
	}
	return 0
}

func (m *RequestLog) GetReferrer() string {
	if m != nil {
		return m.Referrer
	}
	return ""
}

func (m *RequestLog) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *RequestLog) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *RequestLog) GetUrlMapEntry() string {
	if m != nil {
		return m.UrlMapEntry
	}
	return ""
}

func (m *RequestLog) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *RequestLog) GetCost() float64 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *RequestLog) GetTaskQueueName() string {
	if m != nil {
		return m.TaskQueueName
	}
	return ""
}

func (m *RequestLog) GetTaskName() string {
	if m != nil {
		return m.TaskName
	}
	return ""
}

func (m *RequestLog) GetWasLoadingRequest() bool {
	if m != nil {
		return m.WasLoadingRequest
	}
	return false
}

func (m *RequestLog) GetPendingTime() *google_protobuf1.Duration {
	if m != nil {
		return m.PendingTime
	}
	return nil
}

func (m *RequestLog) GetInstanceIndex() int32 {
	if m != nil {
		return m.InstanceIndex
	}
	return 0
}

func (m *RequestLog) GetFinished() bool {
	if m != nil {
		return m.Finished
	}
	return false
}

func (m *RequestLog) GetFirst() bool {
	if m != nil {
		return m.First
	}
	return false
}

func (m *RequestLog) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

func (m *RequestLog) GetLine() []*LogLine {
	if m != nil {
		return m.Line
	}
	return nil
}

func (m *RequestLog) GetAppEngineRelease() string {
	if m != nil {
		return m.AppEngineRelease
	}
	return ""
}

func (m *RequestLog) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	return ""
}

func (m *RequestLog) GetSourceReference() []*SourceReference {
	if m != nil {
		return m.SourceReference
	}
	return nil
}

func init() {
	proto.RegisterType((*LogLine)(nil), "google.appengine.logging.v1.LogLine")
	proto.RegisterType((*SourceLocation)(nil), "google.appengine.logging.v1.SourceLocation")
	proto.RegisterType((*SourceReference)(nil), "google.appengine.logging.v1.SourceReference")
	proto.RegisterType((*RequestLog)(nil), "google.appengine.logging.v1.RequestLog")
}
func (m *LogLine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogLine) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.Time.Size()))
		n1, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Severity != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.Severity))
	}
	if len(m.LogMessage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.LogMessage)))
		i += copy(dAtA[i:], m.LogMessage)
	}
	if m.SourceLocation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.SourceLocation.Size()))
		n2, err := m.SourceLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *SourceLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceLocation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.File) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.File)))
		i += copy(dAtA[i:], m.File)
	}
	if m.Line != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.Line))
	}
	if len(m.FunctionName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.FunctionName)))
		i += copy(dAtA[i:], m.FunctionName)
	}
	return i, nil
}

func (m *SourceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceReference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repository) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.Repository)))
		i += copy(dAtA[i:], m.Repository)
	}
	if len(m.RevisionId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.RevisionId)))
		i += copy(dAtA[i:], m.RevisionId)
	}
	return i, nil
}

func (m *RequestLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.AppId)))
		i += copy(dAtA[i:], m.AppId)
	}
	if len(m.VersionId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.VersionId)))
		i += copy(dAtA[i:], m.VersionId)
	}
	if len(m.RequestId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.RequestId)))
		i += copy(dAtA[i:], m.RequestId)
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if m.StartTime != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.StartTime.Size()))
		n3, err := m.StartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.EndTime != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.EndTime.Size()))
		n4, err := m.EndTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Latency != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.Latency.Size()))
		n5, err := m.Latency.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.MegaCycles != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.MegaCycles))
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.Resource) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.Resource)))
		i += copy(dAtA[i:], m.Resource)
	}
	if len(m.HttpVersion) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.HttpVersion)))
		i += copy(dAtA[i:], m.HttpVersion)
	}
	if m.Status != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.Status))
	}
	if m.ResponseSize != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.ResponseSize))
	}
	if len(m.Referrer) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.Referrer)))
		i += copy(dAtA[i:], m.Referrer)
	}
	if len(m.UserAgent) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.UserAgent)))
		i += copy(dAtA[i:], m.UserAgent)
	}
	if len(m.UrlMapEntry) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.UrlMapEntry)))
		i += copy(dAtA[i:], m.UrlMapEntry)
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if m.Cost != 0 {
		dAtA[i] = 0xa9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64RequestLog(dAtA, i, uint64(math.Float64bits(float64(m.Cost))))
	}
	if len(m.TaskQueueName) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.TaskQueueName)))
		i += copy(dAtA[i:], m.TaskQueueName)
	}
	if len(m.TaskName) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.TaskName)))
		i += copy(dAtA[i:], m.TaskName)
	}
	if m.WasLoadingRequest {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.WasLoadingRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PendingTime != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.PendingTime.Size()))
		n6, err := m.PendingTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.InstanceIndex != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(m.InstanceIndex))
	}
	if m.Finished {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.Finished {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.InstanceId) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.InstanceId)))
		i += copy(dAtA[i:], m.InstanceId)
	}
	if len(m.Line) > 0 {
		for _, msg := range m.Line {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintRequestLog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ModuleId) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.ModuleId)))
		i += copy(dAtA[i:], m.ModuleId)
	}
	if len(m.AppEngineRelease) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.AppEngineRelease)))
		i += copy(dAtA[i:], m.AppEngineRelease)
	}
	if len(m.TraceId) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.TraceId)))
		i += copy(dAtA[i:], m.TraceId)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRequestLog(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.SourceReference) > 0 {
		for _, msg := range m.SourceReference {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintRequestLog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.First {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		if m.First {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64RequestLog(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32RequestLog(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRequestLog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LogLine) Size() (n int) {
	var l int
	_ = l
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovRequestLog(uint64(l))
	}
	if m.Severity != 0 {
		n += 1 + sovRequestLog(uint64(m.Severity))
	}
	l = len(m.LogMessage)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	if m.SourceLocation != nil {
		l = m.SourceLocation.Size()
		n += 1 + l + sovRequestLog(uint64(l))
	}
	return n
}

func (m *SourceLocation) Size() (n int) {
	var l int
	_ = l
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	if m.Line != 0 {
		n += 1 + sovRequestLog(uint64(m.Line))
	}
	l = len(m.FunctionName)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	return n
}

func (m *SourceReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.Repository)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	l = len(m.RevisionId)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	return n
}

func (m *RequestLog) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	l = len(m.VersionId)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovRequestLog(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovRequestLog(uint64(l))
	}
	if m.Latency != nil {
		l = m.Latency.Size()
		n += 1 + l + sovRequestLog(uint64(l))
	}
	if m.MegaCycles != 0 {
		n += 1 + sovRequestLog(uint64(m.MegaCycles))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	l = len(m.HttpVersion)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovRequestLog(uint64(m.Status))
	}
	if m.ResponseSize != 0 {
		n += 1 + sovRequestLog(uint64(m.ResponseSize))
	}
	l = len(m.Referrer)
	if l > 0 {
		n += 1 + l + sovRequestLog(uint64(l))
	}
	l = len(m.UserAgent)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	l = len(m.UrlMapEntry)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	if m.Cost != 0 {
		n += 10
	}
	l = len(m.TaskQueueName)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	l = len(m.TaskName)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	if m.WasLoadingRequest {
		n += 3
	}
	if m.PendingTime != nil {
		l = m.PendingTime.Size()
		n += 2 + l + sovRequestLog(uint64(l))
	}
	if m.InstanceIndex != 0 {
		n += 2 + sovRequestLog(uint64(m.InstanceIndex))
	}
	if m.Finished {
		n += 3
	}
	l = len(m.InstanceId)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	if len(m.Line) > 0 {
		for _, e := range m.Line {
			l = e.Size()
			n += 2 + l + sovRequestLog(uint64(l))
		}
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	l = len(m.AppEngineRelease)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	l = len(m.TraceId)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 2 + l + sovRequestLog(uint64(l))
	}
	if len(m.SourceReference) > 0 {
		for _, e := range m.SourceReference {
			l = e.Size()
			n += 2 + l + sovRequestLog(uint64(l))
		}
	}
	if m.First {
		n += 3
	}
	return n
}

func sovRequestLog(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRequestLog(x uint64) (n int) {
	return sovRequestLog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LogLine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogLine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogLine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &google_protobuf2.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= (google_logging_type.LogSeverity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceLocation == nil {
				m.SourceLocation = &SourceLocation{}
			}
			if err := m.SourceLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRequestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FunctionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRequestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repository", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repository = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRequestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRequestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRequestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &google_protobuf2.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &google_protobuf2.Timestamp{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Latency == nil {
				m.Latency = &google_protobuf1.Duration{}
			}
			if err := m.Latency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MegaCycles", wireType)
			}
			m.MegaCycles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MegaCycles |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseSize", wireType)
			}
			m.ResponseSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Referrer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Referrer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlMapEntry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlMapEntry = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Cost = float64(math.Float64frombits(v))
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskQueueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskQueueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WasLoadingRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WasLoadingRequest = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PendingTime == nil {
				m.PendingTime = &google_protobuf1.Duration{}
			}
			if err := m.PendingTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceIndex", wireType)
			}
			m.InstanceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finished = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Line = append(m.Line, &LogLine{})
			if err := m.Line[len(m.Line)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppEngineRelease", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppEngineRelease = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRequestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceReference = append(m.SourceReference, &SourceReference{})
			if err := m.SourceReference[len(m.SourceReference)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.First = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRequestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRequestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRequestLog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRequestLog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRequestLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRequestLog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRequestLog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRequestLog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRequestLog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRequestLog   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("google/appengine/logging/v1/request_log.proto", fileDescriptorRequestLog)
}

var fileDescriptorRequestLog = []byte{
	// 942 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xef, 0x6e, 0x1c, 0x35,
	0x10, 0xd7, 0xe6, 0xef, 0x9d, 0x2f, 0xb9, 0xa4, 0xa6, 0x2d, 0x4e, 0x42, 0x93, 0x23, 0xd0, 0x70,
	0x40, 0xd9, 0x53, 0x53, 0x21, 0x81, 0xe8, 0x17, 0x02, 0xfd, 0x70, 0xd2, 0x15, 0x95, 0x4d, 0x05,
	0x12, 0x12, 0x5a, 0xb9, 0xbb, 0x73, 0x1b, 0xab, 0x7b, 0xb6, 0x6b, 0x7b, 0x53, 0xae, 0x9f, 0x79,
	0x06, 0x9e, 0x89, 0x8f, 0x3c, 0x02, 0xca, 0x03, 0xf0, 0x0c, 0xc8, 0x63, 0xef, 0x85, 0x00, 0x4a,
	0xfa, 0xcd, 0xf3, 0x9b, 0xdf, 0x8c, 0x67, 0xc6, 0xbf, 0x9d, 0x25, 0x9f, 0x55, 0x4a, 0x55, 0x35,
	0x8c, 0xb8, 0xd6, 0x20, 0x2b, 0x21, 0x61, 0x54, 0xab, 0xaa, 0x12, 0xb2, 0x1a, 0x9d, 0x3f, 0x1c,
	0x19, 0x78, 0xd5, 0x80, 0x75, 0x79, 0xad, 0xaa, 0x54, 0x1b, 0xe5, 0x14, 0xdd, 0x0b, 0xf4, 0x74,
	0x41, 0x4f, 0x23, 0x3d, 0x3d, 0x7f, 0xb8, 0x7b, 0x14, 0x73, 0xb5, 0x19, 0xdc, 0x5c, 0xa3, 0x91,
	0x5b, 0x38, 0x07, 0x23, 0xdc, 0x3c, 0x24, 0xd9, 0xdd, 0x8f, 0x3c, 0xb4, 0x5e, 0x34, 0xd3, 0x51,
	0xd9, 0x18, 0xee, 0x84, 0x92, 0xd1, 0x7f, 0xf0, 0x6f, 0xbf, 0x13, 0x33, 0xb0, 0x8e, 0xcf, 0x74,
	0x20, 0x1c, 0xfe, 0x95, 0x90, 0xf5, 0x89, 0xaa, 0x26, 0x42, 0x02, 0x4d, 0xc9, 0x8a, 0x77, 0xb3,
	0x64, 0x90, 0x0c, 0x7b, 0xc7, 0xbb, 0x69, 0x2c, 0xb0, 0x8d, 0x4d, 0x9f, 0xb7, 0xb1, 0x19, 0xf2,
	0xe8, 0x63, 0xd2, 0x69, 0xcb, 0x61, 0x4b, 0x83, 0x64, 0xd8, 0x3f, 0x1e, 0xb4, 0x31, 0x6d, 0x2b,
	0xbe, 0xee, 0x74, 0xa2, 0xaa, 0xd3, 0xc8, 0xcb, 0x16, 0x11, 0xf4, 0x80, 0xf4, 0x7c, 0x43, 0x33,
	0xb0, 0x96, 0x57, 0xc0, 0x96, 0x07, 0xc9, 0xb0, 0x9b, 0x91, 0x5a, 0x55, 0x4f, 0x03, 0x42, 0x9f,
	0x93, 0x2d, 0xab, 0x1a, 0x53, 0x40, 0x5e, 0xab, 0x02, 0x9b, 0x62, 0x2b, 0x58, 0xd9, 0xa7, 0xe9,
	0x35, 0xa3, 0x4b, 0x4f, 0x31, 0x66, 0x12, 0x43, 0xb2, 0xbe, 0xbd, 0x62, 0x1f, 0xfe, 0x4c, 0xfa,
	0x57, 0x19, 0x94, 0x92, 0x95, 0xa9, 0xa8, 0x43, 0xdb, 0xdd, 0x0c, 0xcf, 0x1e, 0xab, 0x85, 0x04,
	0x6c, 0x6b, 0x39, 0xc3, 0x33, 0xfd, 0x80, 0x6c, 0x4e, 0x1b, 0x59, 0xf8, 0x98, 0x5c, 0xf2, 0x59,
	0x5b, 0xf2, 0x46, 0x0b, 0x7e, 0xc7, 0x67, 0x70, 0x98, 0x91, 0xad, 0x90, 0x3e, 0x83, 0x29, 0x18,
	0x90, 0x05, 0xd0, 0x7d, 0x42, 0x0c, 0x68, 0x65, 0x85, 0x53, 0x66, 0x1e, 0x6f, 0xf9, 0x07, 0xe2,
	0x07, 0x61, 0xe0, 0x5c, 0x58, 0x9f, 0x57, 0x94, 0x78, 0x25, 0x12, 0x02, 0x34, 0x2e, 0x0f, 0x7f,
	0xeb, 0x12, 0x92, 0x05, 0xfd, 0x4c, 0x54, 0x45, 0xef, 0x90, 0x35, 0xae, 0xb5, 0xa7, 0x86, 0x5c,
	0xab, 0x5c, 0xeb, 0x71, 0x49, 0xef, 0x11, 0x72, 0x0e, 0xe6, 0x6a, 0x96, 0x6e, 0x44, 0x82, 0xbb,
	0xd5, 0xa0, 0x28, 0x63, 0xe9, 0xdd, 0x88, 0x8c, 0x4b, 0xda, 0x27, 0x4b, 0x42, 0xe3, 0x7c, 0xbb,
	0xd9, 0x92, 0xd0, 0xf4, 0x4b, 0x42, 0xac, 0xe3, 0xc6, 0xe5, 0xa8, 0x88, 0xb5, 0x1b, 0x15, 0xd1,
	0x45, 0xb6, 0xb7, 0xe9, 0xe7, 0xa4, 0x03, 0xb2, 0x0c, 0x81, 0xeb, 0x37, 0x06, 0xae, 0x83, 0x2c,
	0x31, 0xec, 0x11, 0x59, 0xaf, 0xb9, 0x03, 0x59, 0xcc, 0x59, 0x07, 0xa3, 0x76, 0xfe, 0x13, 0xf5,
	0x6d, 0x14, 0x77, 0xd6, 0x32, 0xfd, 0xec, 0x66, 0x50, 0xf1, 0xbc, 0x98, 0x17, 0x35, 0x58, 0xd6,
	0xc5, 0xe7, 0x22, 0x1e, 0xfa, 0x06, 0x11, 0x7a, 0x97, 0xac, 0xcd, 0xc0, 0x9d, 0xa9, 0x92, 0x11,
	0xec, 0x2d, 0x5a, 0x74, 0x97, 0x74, 0x0c, 0x04, 0x69, 0xb0, 0x1e, 0x7a, 0x16, 0x36, 0x7d, 0x9f,
	0x6c, 0x9c, 0x39, 0xa7, 0xf3, 0x38, 0x3c, 0xb6, 0x81, 0xfe, 0x9e, 0xc7, 0x7e, 0x08, 0x90, 0x4f,
	0x6b, 0x1d, 0x77, 0x8d, 0x65, 0x9b, 0x83, 0x64, 0xb8, 0x9a, 0x45, 0xcb, 0x6b, 0xc4, 0x80, 0xd5,
	0x4a, 0x5a, 0xc8, 0xad, 0x78, 0x03, 0xac, 0x8f, 0x15, 0x6d, 0xb4, 0xe0, 0xa9, 0x78, 0x03, 0xe1,
	0xee, 0x29, 0x18, 0x03, 0x86, 0x6d, 0xb5, 0x77, 0x07, 0xdb, 0x3f, 0x53, 0x63, 0xc1, 0xe4, 0xbc,
	0x02, 0xe9, 0xd8, 0x76, 0x78, 0x26, 0x8f, 0x7c, 0xed, 0x01, 0x7a, 0x48, 0x36, 0x1b, 0x53, 0xe7,
	0x33, 0xae, 0x73, 0x90, 0xce, 0xcc, 0xd9, 0xad, 0x50, 0x5b, 0x63, 0xea, 0xa7, 0x5c, 0x3f, 0xf1,
	0x90, 0xd7, 0xee, 0x99, 0xb2, 0x8e, 0xdd, 0x0e, 0x7a, 0xf6, 0x67, 0x8f, 0x15, 0x1e, 0xbb, 0x33,
	0x48, 0x86, 0x49, 0x86, 0x67, 0x7a, 0x44, 0xb6, 0x1c, 0xb7, 0x2f, 0xf3, 0x57, 0x0d, 0x34, 0x10,
	0x14, 0x7d, 0x17, 0x43, 0x36, 0x3d, 0xfc, 0xbd, 0x47, 0xbd, 0xa4, 0xe9, 0x1e, 0xe9, 0x22, 0x0f,
	0x19, 0xef, 0x86, 0x7a, 0x3d, 0x80, 0xce, 0x94, 0xbc, 0xf3, 0x9a, 0xdb, 0xbc, 0x56, 0xbc, 0x14,
	0xb2, 0xca, 0xa3, 0xa0, 0x18, 0x1b, 0x24, 0xc3, 0x4e, 0x76, 0xeb, 0x35, 0xb7, 0x93, 0xe0, 0x89,
	0xfa, 0xa5, 0x8f, 0xc9, 0x86, 0x06, 0x89, 0x5c, 0x14, 0xc8, 0xce, 0x4d, 0x4f, 0xdd, 0x8b, 0x74,
	0xd4, 0xc8, 0x7d, 0xd2, 0x17, 0xd2, 0x3a, 0x2e, 0x0b, 0xc8, 0x85, 0x2c, 0xe1, 0x17, 0xb6, 0x8b,
	0xe3, 0xdf, 0x6c, 0xd1, 0xb1, 0x07, 0xfd, 0x80, 0xa7, 0x42, 0x0a, 0x7b, 0x06, 0x25, 0xdb, 0xc3,
	0x4a, 0x16, 0xb6, 0x57, 0xcc, 0x65, 0x8a, 0x92, 0xbd, 0x17, 0xbe, 0xb6, 0x45, 0x7c, 0x49, 0xbf,
	0x88, 0x9f, 0xfe, 0xbd, 0xc1, 0xf2, 0xb0, 0x77, 0xfc, 0xe1, 0xb5, 0xbb, 0x26, 0x6e, 0xce, 0xb8,
	0x20, 0xf6, 0x48, 0x77, 0xa6, 0xca, 0xa6, 0xc6, 0xc4, 0xf7, 0xc3, 0xa0, 0x02, 0x30, 0x2e, 0xe9,
	0x03, 0x42, 0xfd, 0x57, 0x1b, 0x72, 0xe4, 0x06, 0x6a, 0xe0, 0x16, 0xd8, 0x11, 0xb2, 0xb6, 0xb9,
	0xd6, 0x4f, 0xd0, 0x91, 0x05, 0x9c, 0xee, 0x90, 0x8e, 0x33, 0x3c, 0x94, 0xf8, 0x11, 0x72, 0xd6,
	0xd1, 0x1e, 0xa3, 0x72, 0xa5, 0x28, 0x5e, 0xe2, 0x6b, 0x0c, 0xc3, 0x25, 0xad, 0x4d, 0x7f, 0x24,
	0xdb, 0x71, 0x65, 0x9a, 0x76, 0xfd, 0xb0, 0x8f, 0xb1, 0x8f, 0x07, 0x6f, 0xb1, 0x33, 0x17, 0x2b,
	0x2b, 0x8b, 0x8b, 0xf7, 0x72, 0x87, 0xdd, 0x26, 0xab, 0x53, 0x61, 0xac, 0x63, 0x9f, 0xe0, 0x38,
	0x83, 0x71, 0xf2, 0x6b, 0xf2, 0xfb, 0xc5, 0x7e, 0xf2, 0xc7, 0xc5, 0x7e, 0xf2, 0xe7, 0xc5, 0x7e,
	0x42, 0x0e, 0x0a, 0x35, 0xbb, 0xee, 0x9a, 0x93, 0xad, 0xcb, 0x2d, 0xf6, 0xcc, 0x3f, 0xf4, 0xb3,
	0xe4, 0xa7, 0x93, 0xc8, 0xaf, 0x54, 0xcd, 0x65, 0x95, 0x2a, 0x53, 0x8d, 0x2a, 0x90, 0x28, 0x83,
	0x51, 0x70, 0x71, 0x2d, 0xec, 0xff, 0xfe, 0x53, 0xbf, 0x8a, 0xc7, 0x17, 0x6b, 0x48, 0x7f, 0xf4,
	0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1e, 0x72, 0x83, 0xe7, 0x81, 0x07, 0x00, 0x00,
}
