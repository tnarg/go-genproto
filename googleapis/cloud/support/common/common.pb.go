// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/cloud/support/common.proto

/*
	Package common is a generated protocol buffer package.

	It is generated from these files:
		google/cloud/support/common.proto

	It has these top-level messages:
		SupportAccount
		Case
		CustomerIssue
		SupportRole
		Comment
		IssueTaxonomy
*/
package common

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// The current state of this SupportAccount.
type SupportAccount_State int32

const (
	// Account is in an unknown state.
	SupportAccount_STATE_UNSPECIFIED SupportAccount_State = 0
	// Account is in an active state.
	SupportAccount_ACTIVE SupportAccount_State = 1
	// Account has been created but is being provisioned in support systems.
	SupportAccount_PENDING SupportAccount_State = 2
	// Account deletion has been requested by the user.
	SupportAccount_PENDING_DELETION SupportAccount_State = 3
)

var SupportAccount_State_name = map[int32]string{
	0: "STATE_UNSPECIFIED",
	1: "ACTIVE",
	2: "PENDING",
	3: "PENDING_DELETION",
}
var SupportAccount_State_value = map[string]int32{
	"STATE_UNSPECIFIED": 0,
	"ACTIVE":            1,
	"PENDING":           2,
	"PENDING_DELETION":  3,
}

func (x SupportAccount_State) String() string {
	return proto.EnumName(SupportAccount_State_name, int32(x))
}
func (SupportAccount_State) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0, 0} }

// Pricing model applicable to this support account.
type SupportAccount_PricingModel int32

const (
	// This account is subscribed to an unknown pricing model.
	SupportAccount_PRICING_MODEL_UNKNOWN SupportAccount_PricingModel = 0
	// Package based pricing (Platinum, Gold, Silver, Bronze).
	SupportAccount_PACKAGES SupportAccount_PricingModel = 1
	// Support charges are calculated based on user seats a.k.a,
	// "Pick Your Team" model.
	SupportAccount_USER_ROLES SupportAccount_PricingModel = 2
)

var SupportAccount_PricingModel_name = map[int32]string{
	0: "PRICING_MODEL_UNKNOWN",
	1: "PACKAGES",
	2: "USER_ROLES",
}
var SupportAccount_PricingModel_value = map[string]int32{
	"PRICING_MODEL_UNKNOWN": 0,
	"PACKAGES":              1,
	"USER_ROLES":            2,
}

func (x SupportAccount_PricingModel) String() string {
	return proto.EnumName(SupportAccount_PricingModel_name, int32(x))
}
func (SupportAccount_PricingModel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCommon, []int{0, 1}
}

// The case priority with P0 being the most urgent and P4 the least.
type Case_Priority int32

const (
	// Priority is undefined or has not been set yet.
	Case_PRIORITY_UNSPECIFIED Case_Priority = 0
	// Extreme impact on a production service - Service is hard down.
	Case_P0 Case_Priority = 1
	// Critical impact on a production service - Service is currently unusable.
	Case_P1 Case_Priority = 2
	// Severe impact on a production service - Service is usable but greatly
	// impaired.
	Case_P2 Case_Priority = 3
	// Medium impact on a production service - Service is available, but
	// moderately impaired.
	Case_P3 Case_Priority = 4
	// General questions or minor issues - Production service is fully
	// available.
	Case_P4 Case_Priority = 5
)

var Case_Priority_name = map[int32]string{
	0: "PRIORITY_UNSPECIFIED",
	1: "P0",
	2: "P1",
	3: "P2",
	4: "P3",
	5: "P4",
}
var Case_Priority_value = map[string]int32{
	"PRIORITY_UNSPECIFIED": 0,
	"P0": 1,
	"P1": 2,
	"P2": 3,
	"P3": 4,
	"P4": 5,
}

func (x Case_Priority) String() string {
	return proto.EnumName(Case_Priority_name, int32(x))
}
func (Case_Priority) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1, 0} }

// The state of a case.
type Case_State int32

const (
	// Case is in an unknown state.
	Case_STATE_UNSPECIFIED Case_State = 0
	// Case has been created but no one is assigned to work on it yet.
	Case_NEW Case_State = 1
	// Case has been assigned to a support agent.
	Case_ASSIGNED Case_State = 2
	// A support agent is currently investigating the case.
	Case_IN_PROGRESS_GOOGLE_SUPPORT Case_State = 3
	// Case has been forwarded to product team for further investigation.
	Case_IN_PROGRESS_GOOGLE_ENG Case_State = 4
	// Case is under investigation and relates to a known issue.
	Case_IN_PROGRESS_KNOWN_ISSUE Case_State = 5
	// Case is waiting for a response from the customer.
	Case_WAITING_FOR_CUSTOMER_RESPONSE Case_State = 6
	// A solution has been offered for the case but it isn't closed yet.
	Case_SOLUTION_OFFERED Case_State = 7
	// Cases has been fully resolved and is in a closed state.
	Case_CLOSED Case_State = 8
)

var Case_State_name = map[int32]string{
	0: "STATE_UNSPECIFIED",
	1: "NEW",
	2: "ASSIGNED",
	3: "IN_PROGRESS_GOOGLE_SUPPORT",
	4: "IN_PROGRESS_GOOGLE_ENG",
	5: "IN_PROGRESS_KNOWN_ISSUE",
	6: "WAITING_FOR_CUSTOMER_RESPONSE",
	7: "SOLUTION_OFFERED",
	8: "CLOSED",
}
var Case_State_value = map[string]int32{
	"STATE_UNSPECIFIED":             0,
	"NEW":                           1,
	"ASSIGNED":                      2,
	"IN_PROGRESS_GOOGLE_SUPPORT":    3,
	"IN_PROGRESS_GOOGLE_ENG":        4,
	"IN_PROGRESS_KNOWN_ISSUE":       5,
	"WAITING_FOR_CUSTOMER_RESPONSE": 6,
	"SOLUTION_OFFERED":              7,
	"CLOSED":                        8,
}

func (x Case_State) String() string {
	return proto.EnumName(Case_State_name, int32(x))
}
func (Case_State) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1, 1} }

// The status of a customer issue.
type CustomerIssue_IssueState int32

const (
	// Issue in an unknown state.
	CustomerIssue_ISSUE_STATE_UNSPECIFIED CustomerIssue_IssueState = 0
	// Issue is currently open but the work on it has not been started.
	CustomerIssue_OPEN CustomerIssue_IssueState = 1
	// Issue is currently being worked on.
	CustomerIssue_IN_PROGRESS CustomerIssue_IssueState = 2
	// Issue is fixed.
	CustomerIssue_FIXED CustomerIssue_IssueState = 3
	// Issue has been marked as invalid.
	CustomerIssue_WONT_FIX CustomerIssue_IssueState = 4
	// Issue verified and in production.
	CustomerIssue_VERIFIED CustomerIssue_IssueState = 5
)

var CustomerIssue_IssueState_name = map[int32]string{
	0: "ISSUE_STATE_UNSPECIFIED",
	1: "OPEN",
	2: "IN_PROGRESS",
	3: "FIXED",
	4: "WONT_FIX",
	5: "VERIFIED",
}
var CustomerIssue_IssueState_value = map[string]int32{
	"ISSUE_STATE_UNSPECIFIED": 0,
	"OPEN":        1,
	"IN_PROGRESS": 2,
	"FIXED":       3,
	"WONT_FIX":    4,
	"VERIFIED":    5,
}

func (x CustomerIssue_IssueState) String() string {
	return proto.EnumName(CustomerIssue_IssueState_name, int32(x))
}
func (CustomerIssue_IssueState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCommon, []int{2, 0}
}

// A role which determines the support resources and features a user might
// get access to.
type SupportRole_Role int32

const (
	// An unknown role.
	SupportRole_ROLE_UNSPECIFIED SupportRole_Role = 0
	// The basic support role.
	SupportRole_BASIC SupportRole_Role = 1
	// The developer role.
	SupportRole_DEVELOPER SupportRole_Role = 2
	// The operation role.
	SupportRole_OPERATION SupportRole_Role = 3
	// The site reliability role.
	SupportRole_SITE_RELIABILITY SupportRole_Role = 4
)

var SupportRole_Role_name = map[int32]string{
	0: "ROLE_UNSPECIFIED",
	1: "BASIC",
	2: "DEVELOPER",
	3: "OPERATION",
	4: "SITE_RELIABILITY",
}
var SupportRole_Role_value = map[string]int32{
	"ROLE_UNSPECIFIED": 0,
	"BASIC":            1,
	"DEVELOPER":        2,
	"OPERATION":        3,
	"SITE_RELIABILITY": 4,
}

func (x SupportRole_Role) String() string {
	return proto.EnumName(SupportRole_Role_name, int32(x))
}
func (SupportRole_Role) EnumDescriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3, 0} }

// A Google Cloud Platform account that identifies support eligibility for a
// Cloud resource. Currently the Cloud resource can only be an Organization
// but this might change in future.
type SupportAccount struct {
	// The resource name for a support account in format
	// `supportAccounts/{account_id}`.
	// Output only.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Identifier for this entity that gets persisted in storage system. The
	// resource name is populated using this field in format
	// `supportAccounts/{account_id}`.
	AccountId string `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// The Cloud resource with which this support account is associated.
	CloudResource string `protobuf:"bytes,3,opt,name=cloud_resource,json=cloudResource,proto3" json:"cloud_resource,omitempty"`
	// A user friendly display name assigned to this support account.
	DisplayName string `protobuf:"bytes,4,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Indicates the current state of an account.
	State SupportAccount_State `protobuf:"varint,5,opt,name=state,proto3,enum=google.cloud.support.common.SupportAccount_State" json:"state,omitempty"`
	// Time when this account was created.
	// Output only.
	CreateTime *google_protobuf1.Timestamp `protobuf:"bytes,6,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// The resource name of a billing account associated with this support
	// account. For example, `billingAccounts/ABCDEF-012345-567890`.
	BillingAccountName string `protobuf:"bytes,7,opt,name=billing_account_name,json=billingAccountName,proto3" json:"billing_account_name,omitempty"`
	UnifyAccountId     string `protobuf:"bytes,8,opt,name=unify_account_id,json=unifyAccountId,proto3" json:"unify_account_id,omitempty"`
	// The PricingModel applicable to this support account.
	PricingModel SupportAccount_PricingModel `protobuf:"varint,9,opt,name=pricing_model,json=pricingModel,proto3,enum=google.cloud.support.common.SupportAccount_PricingModel" json:"pricing_model,omitempty"`
}

func (m *SupportAccount) Reset()                    { *m = SupportAccount{} }
func (m *SupportAccount) String() string            { return proto.CompactTextString(m) }
func (*SupportAccount) ProtoMessage()               {}
func (*SupportAccount) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{0} }

func (m *SupportAccount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SupportAccount) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *SupportAccount) GetCloudResource() string {
	if m != nil {
		return m.CloudResource
	}
	return ""
}

func (m *SupportAccount) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *SupportAccount) GetState() SupportAccount_State {
	if m != nil {
		return m.State
	}
	return SupportAccount_STATE_UNSPECIFIED
}

func (m *SupportAccount) GetCreateTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *SupportAccount) GetBillingAccountName() string {
	if m != nil {
		return m.BillingAccountName
	}
	return ""
}

func (m *SupportAccount) GetUnifyAccountId() string {
	if m != nil {
		return m.UnifyAccountId
	}
	return ""
}

func (m *SupportAccount) GetPricingModel() SupportAccount_PricingModel {
	if m != nil {
		return m.PricingModel
	}
	return SupportAccount_PRICING_MODEL_UNKNOWN
}

// A support case created by the user.
type Case struct {
	// The resource name for the Case in format
	// `supportAccounts/{account_id}/cases/{case_id}`
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The short summary of the issue reported in this case.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// The board description of issue provided with initial summary.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The product component for which this Case is reported.
	Component string `protobuf:"bytes,4,opt,name=component,proto3" json:"component,omitempty"`
	// The product subcomponent for which this Case is reported.
	Subcomponent string `protobuf:"bytes,5,opt,name=subcomponent,proto3" json:"subcomponent,omitempty"`
	// Timezone the client sending this request is in.
	// It should be in a format IANA recognizes: https://www.iana.org/time-zone
	// There is no additional validation done by the API.
	ClientTimezone string `protobuf:"bytes,6,opt,name=client_timezone,json=clientTimezone,proto3" json:"client_timezone,omitempty"`
	// The email addresses that can be copied to receive updates on this case.
	// Users can specify a maximum of 10 email addresses.
	CcAddresses []string `protobuf:"bytes,7,rep,name=cc_addresses,json=ccAddresses" json:"cc_addresses,omitempty"`
	// The Google Cloud Platform project ID for which this case is created.
	ProjectId string `protobuf:"bytes,8,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// List of customer issues associated with this case.
	Issues []*CustomerIssue `protobuf:"bytes,10,rep,name=issues" json:"issues,omitempty"`
	// The current priority of this case.
	Priority Case_Priority `protobuf:"varint,11,opt,name=priority,proto3,enum=google.cloud.support.common.Case_Priority" json:"priority,omitempty"`
	// The current state of this case.
	State Case_State `protobuf:"varint,12,opt,name=state,proto3,enum=google.cloud.support.common.Case_State" json:"state,omitempty"`
	// Time when this case was created.
	// Output only.
	CreateTime *google_protobuf1.Timestamp `protobuf:"bytes,13,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Time when this case was last updated.
	// Output only.
	UpdateTime *google_protobuf1.Timestamp `protobuf:"bytes,14,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
	// Email address of user who created this case.
	// Output only. It is inferred from credentials supplied during case creation.
	CreatorEmail string `protobuf:"bytes,15,opt,name=creator_email,json=creatorEmail,proto3" json:"creator_email,omitempty"`
	// The issue category applicable to this case.
	Category string `protobuf:"bytes,16,opt,name=category,proto3" json:"category,omitempty"`
}

func (m *Case) Reset()                    { *m = Case{} }
func (m *Case) String() string            { return proto.CompactTextString(m) }
func (*Case) ProtoMessage()               {}
func (*Case) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{1} }

func (m *Case) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Case) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *Case) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Case) GetComponent() string {
	if m != nil {
		return m.Component
	}
	return ""
}

func (m *Case) GetSubcomponent() string {
	if m != nil {
		return m.Subcomponent
	}
	return ""
}

func (m *Case) GetClientTimezone() string {
	if m != nil {
		return m.ClientTimezone
	}
	return ""
}

func (m *Case) GetCcAddresses() []string {
	if m != nil {
		return m.CcAddresses
	}
	return nil
}

func (m *Case) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *Case) GetIssues() []*CustomerIssue {
	if m != nil {
		return m.Issues
	}
	return nil
}

func (m *Case) GetPriority() Case_Priority {
	if m != nil {
		return m.Priority
	}
	return Case_PRIORITY_UNSPECIFIED
}

func (m *Case) GetState() Case_State {
	if m != nil {
		return m.State
	}
	return Case_STATE_UNSPECIFIED
}

func (m *Case) GetCreateTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Case) GetUpdateTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *Case) GetCreatorEmail() string {
	if m != nil {
		return m.CreatorEmail
	}
	return ""
}

func (m *Case) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

// Reference to a Google internal ticket used for investigating a support case.
// Not every support case will have an internal ticket associated with it.
// A support case can have multiple tickets linked to it.
type CustomerIssue struct {
	// Unique identifier for the internal issue.
	// Output only.
	IssueId string `protobuf:"bytes,1,opt,name=issue_id,json=issueId,proto3" json:"issue_id,omitempty"`
	// Represents current status of the internal ticket.
	// Output only.
	State CustomerIssue_IssueState `protobuf:"varint,2,opt,name=state,proto3,enum=google.cloud.support.common.CustomerIssue_IssueState" json:"state,omitempty"`
	// Time when the internal issue was created.
	// Output only.
	CreateTime *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Time when the internal issue was marked as resolved.
	// Output only.
	ResolveTime *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=resolve_time,json=resolveTime" json:"resolve_time,omitempty"`
	// Time when the internal issue was last updated.
	// Output only.
	UpdateTime *google_protobuf1.Timestamp `protobuf:"bytes,5,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
}

func (m *CustomerIssue) Reset()                    { *m = CustomerIssue{} }
func (m *CustomerIssue) String() string            { return proto.CompactTextString(m) }
func (*CustomerIssue) ProtoMessage()               {}
func (*CustomerIssue) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{2} }

func (m *CustomerIssue) GetIssueId() string {
	if m != nil {
		return m.IssueId
	}
	return ""
}

func (m *CustomerIssue) GetState() CustomerIssue_IssueState {
	if m != nil {
		return m.State
	}
	return CustomerIssue_ISSUE_STATE_UNSPECIFIED
}

func (m *CustomerIssue) GetCreateTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *CustomerIssue) GetResolveTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.ResolveTime
	}
	return nil
}

func (m *CustomerIssue) GetUpdateTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

// A message that contains mapping of a user and their role under a support
// account.
type SupportRole struct {
	// Email address of user being added through this Role.
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	// The type of role assigned to user.
	Role SupportRole_Role `protobuf:"varint,2,opt,name=role,proto3,enum=google.cloud.support.common.SupportRole_Role" json:"role,omitempty"`
}

func (m *SupportRole) Reset()                    { *m = SupportRole{} }
func (m *SupportRole) String() string            { return proto.CompactTextString(m) }
func (*SupportRole) ProtoMessage()               {}
func (*SupportRole) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{3} }

func (m *SupportRole) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *SupportRole) GetRole() SupportRole_Role {
	if m != nil {
		return m.Role
	}
	return SupportRole_ROLE_UNSPECIFIED
}

// The comment text associated with a `Case`.
type Comment struct {
	// Text containing a maximum of 3000 characters.
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// Time when this update was created.
	// Output only.
	CreateTime *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// The email address/name of user who created this comment.
	// Output only.
	Author string `protobuf:"bytes,3,opt,name=author,proto3" json:"author,omitempty"`
	// The resource name for this comment in format
	// `supportAccounts/{account_id}/cases/{case_id}/{comment_id}`.
	// Output only.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Comment) Reset()                    { *m = Comment{} }
func (m *Comment) String() string            { return proto.CompactTextString(m) }
func (*Comment) ProtoMessage()               {}
func (*Comment) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{4} }

func (m *Comment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Comment) GetCreateTime() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Comment) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Comment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Represents the product component taxonomy that is to be used while creating
// or updating a `Case`. A client should obtain the list of issue categories,
// component/subcomponent from this object and specify it in `Case.category`,
// `Case.component` and `Case.subcomponent` fields respectively.
type IssueTaxonomy struct {
	// Map of available categories.
	Categories map[string]*IssueTaxonomy_Category `protobuf:"bytes,1,rep,name=categories" json:"categories,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *IssueTaxonomy) Reset()                    { *m = IssueTaxonomy{} }
func (m *IssueTaxonomy) String() string            { return proto.CompactTextString(m) }
func (*IssueTaxonomy) ProtoMessage()               {}
func (*IssueTaxonomy) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{5} }

func (m *IssueTaxonomy) GetCategories() map[string]*IssueTaxonomy_Category {
	if m != nil {
		return m.Categories
	}
	return nil
}

// The representation of a product component. It is composed of a canonical
// name for the product (e.g., Google App Engine), languages in which a
// support ticket can be created under this component, a template that
// provides hints on important details to be filled out before submitting a
// case. It also contains an embedded list of product subcomponents that have
// similar attributes as top-level components.
// (e.g., Google App Engine > Memcache).
type IssueTaxonomy_Component struct {
	// User friendly name of this component.
	DisplayName string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// List of languages in which a support case can be created under this
	// component. Represented by language codes in ISO_639-1 standard.
	Languages []string `protobuf:"bytes,2,rep,name=languages" json:"languages,omitempty"`
	// Template to be used while filling the description of a support case.
	Template string `protobuf:"bytes,3,opt,name=template,proto3" json:"template,omitempty"`
	// List of subcomponents under this component.
	Subcomponents []*IssueTaxonomy_Component `protobuf:"bytes,4,rep,name=subcomponents" json:"subcomponents,omitempty"`
}

func (m *IssueTaxonomy_Component) Reset()                    { *m = IssueTaxonomy_Component{} }
func (m *IssueTaxonomy_Component) String() string            { return proto.CompactTextString(m) }
func (*IssueTaxonomy_Component) ProtoMessage()               {}
func (*IssueTaxonomy_Component) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{5, 0} }

func (m *IssueTaxonomy_Component) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *IssueTaxonomy_Component) GetLanguages() []string {
	if m != nil {
		return m.Languages
	}
	return nil
}

func (m *IssueTaxonomy_Component) GetTemplate() string {
	if m != nil {
		return m.Template
	}
	return ""
}

func (m *IssueTaxonomy_Component) GetSubcomponents() []*IssueTaxonomy_Component {
	if m != nil {
		return m.Subcomponents
	}
	return nil
}

// Represents the category of issue (Technical or Non-Technical)
// reported through a support case.
type IssueTaxonomy_Category struct {
	// User friendly name of this category.
	DisplayName string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Map of product components under this category.
	Components map[string]*IssueTaxonomy_Component `protobuf:"bytes,2,rep,name=components" json:"components,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *IssueTaxonomy_Category) Reset()                    { *m = IssueTaxonomy_Category{} }
func (m *IssueTaxonomy_Category) String() string            { return proto.CompactTextString(m) }
func (*IssueTaxonomy_Category) ProtoMessage()               {}
func (*IssueTaxonomy_Category) Descriptor() ([]byte, []int) { return fileDescriptorCommon, []int{5, 1} }

func (m *IssueTaxonomy_Category) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *IssueTaxonomy_Category) GetComponents() map[string]*IssueTaxonomy_Component {
	if m != nil {
		return m.Components
	}
	return nil
}

func init() {
	proto.RegisterType((*SupportAccount)(nil), "google.cloud.support.common.SupportAccount")
	proto.RegisterType((*Case)(nil), "google.cloud.support.common.Case")
	proto.RegisterType((*CustomerIssue)(nil), "google.cloud.support.common.CustomerIssue")
	proto.RegisterType((*SupportRole)(nil), "google.cloud.support.common.SupportRole")
	proto.RegisterType((*Comment)(nil), "google.cloud.support.common.Comment")
	proto.RegisterType((*IssueTaxonomy)(nil), "google.cloud.support.common.IssueTaxonomy")
	proto.RegisterType((*IssueTaxonomy_Component)(nil), "google.cloud.support.common.IssueTaxonomy.Component")
	proto.RegisterType((*IssueTaxonomy_Category)(nil), "google.cloud.support.common.IssueTaxonomy.Category")
	proto.RegisterEnum("google.cloud.support.common.SupportAccount_State", SupportAccount_State_name, SupportAccount_State_value)
	proto.RegisterEnum("google.cloud.support.common.SupportAccount_PricingModel", SupportAccount_PricingModel_name, SupportAccount_PricingModel_value)
	proto.RegisterEnum("google.cloud.support.common.Case_Priority", Case_Priority_name, Case_Priority_value)
	proto.RegisterEnum("google.cloud.support.common.Case_State", Case_State_name, Case_State_value)
	proto.RegisterEnum("google.cloud.support.common.CustomerIssue_IssueState", CustomerIssue_IssueState_name, CustomerIssue_IssueState_value)
	proto.RegisterEnum("google.cloud.support.common.SupportRole_Role", SupportRole_Role_name, SupportRole_Role_value)
}
func (m *SupportAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.AccountId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.AccountId)))
		i += copy(dAtA[i:], m.AccountId)
	}
	if len(m.CloudResource) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.CloudResource)))
		i += copy(dAtA[i:], m.CloudResource)
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CreateTime.Size()))
		n1, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.BillingAccountName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.BillingAccountName)))
		i += copy(dAtA[i:], m.BillingAccountName)
	}
	if len(m.UnifyAccountId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.UnifyAccountId)))
		i += copy(dAtA[i:], m.UnifyAccountId)
	}
	if m.PricingModel != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.PricingModel))
	}
	return i, nil
}

func (m *Case) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Case) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Component) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Component)))
		i += copy(dAtA[i:], m.Component)
	}
	if len(m.Subcomponent) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Subcomponent)))
		i += copy(dAtA[i:], m.Subcomponent)
	}
	if len(m.ClientTimezone) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ClientTimezone)))
		i += copy(dAtA[i:], m.ClientTimezone)
	}
	if len(m.CcAddresses) > 0 {
		for _, s := range m.CcAddresses {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if len(m.Issues) > 0 {
		for _, msg := range m.Issues {
			dAtA[i] = 0x52
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Priority != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Priority))
	}
	if m.State != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CreateTime.Size()))
		n2, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.UpdateTime != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UpdateTime.Size()))
		n3, err := m.UpdateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.CreatorEmail) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.CreatorEmail)))
		i += copy(dAtA[i:], m.CreatorEmail)
	}
	if len(m.Category) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Category)))
		i += copy(dAtA[i:], m.Category)
	}
	return i, nil
}

func (m *CustomerIssue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomerIssue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IssueId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.IssueId)))
		i += copy(dAtA[i:], m.IssueId)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.State))
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CreateTime.Size()))
		n4, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ResolveTime != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.ResolveTime.Size()))
		n5, err := m.ResolveTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.UpdateTime != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.UpdateTime.Size()))
		n6, err := m.UpdateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *SupportRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportRole) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.Role != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.Role))
	}
	return i, nil
}

func (m *Comment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Comment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommon(dAtA, i, uint64(m.CreateTime.Size()))
		n7, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *IssueTaxonomy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IssueTaxonomy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for k, _ := range m.Categories {
			dAtA[i] = 0xa
			i++
			v := m.Categories[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCommon(uint64(len(k))) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	return i, nil
}

func (m *IssueTaxonomy_Component) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IssueTaxonomy_Component) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Template) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Template)))
		i += copy(dAtA[i:], m.Template)
	}
	if len(m.Subcomponents) > 0 {
		for _, msg := range m.Subcomponents {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IssueTaxonomy_Category) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IssueTaxonomy_Category) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommon(dAtA, i, uint64(len(m.DisplayName)))
		i += copy(dAtA[i:], m.DisplayName)
	}
	if len(m.Components) > 0 {
		for k, _ := range m.Components {
			dAtA[i] = 0x12
			i++
			v := m.Components[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCommon(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCommon(uint64(len(k))) + msgSize
			i = encodeVarintCommon(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCommon(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCommon(dAtA, i, uint64(v.Size()))
				n9, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	return i, nil
}

func encodeFixed64Common(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Common(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SupportAccount) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.CloudResource)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.BillingAccountName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.UnifyAccountId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.PricingModel != 0 {
		n += 1 + sovCommon(uint64(m.PricingModel))
	}
	return n
}

func (m *Case) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Component)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Subcomponent)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.ClientTimezone)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.CcAddresses) > 0 {
		for _, s := range m.CcAddresses {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Issues) > 0 {
		for _, e := range m.Issues {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	if m.Priority != 0 {
		n += 1 + sovCommon(uint64(m.Priority))
	}
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.UpdateTime != nil {
		l = m.UpdateTime.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.CreatorEmail)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Category)
	if l > 0 {
		n += 2 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *CustomerIssue) Size() (n int) {
	var l int
	_ = l
	l = len(m.IssueId)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovCommon(uint64(m.State))
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.ResolveTime != nil {
		l = m.ResolveTime.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.UpdateTime != nil {
		l = m.UpdateTime.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *SupportRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovCommon(uint64(m.Role))
	}
	return n
}

func (m *Comment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func (m *IssueTaxonomy) Size() (n int) {
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for k, v := range m.Categories {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCommon(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *IssueTaxonomy_Component) Size() (n int) {
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			l = len(s)
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	l = len(m.Template)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Subcomponents) > 0 {
		for _, e := range m.Subcomponents {
			l = e.Size()
			n += 1 + l + sovCommon(uint64(l))
		}
	}
	return n
}

func (m *IssueTaxonomy_Category) Size() (n int) {
	var l int
	_ = l
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	if len(m.Components) > 0 {
		for k, v := range m.Components {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCommon(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCommon(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCommon(uint64(mapEntrySize))
		}
	}
	return n
}

func sovCommon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SupportAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudResource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (SupportAccount_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf1.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingAccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillingAccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnifyAccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnifyAccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingModel", wireType)
			}
			m.PricingModel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PricingModel |= (SupportAccount_PricingModel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Case) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Case: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Case: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Component = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcomponent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subcomponent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTimezone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientTimezone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CcAddresses = append(m.CcAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issues = append(m.Issues, &CustomerIssue{})
			if err := m.Issues[len(m.Issues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (Case_Priority(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (Case_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf1.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateTime == nil {
				m.UpdateTime = &google_protobuf1.Timestamp{}
			}
			if err := m.UpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomerIssue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomerIssue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomerIssue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (CustomerIssue_IssueState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf1.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResolveTime == nil {
				m.ResolveTime = &google_protobuf1.Timestamp{}
			}
			if err := m.ResolveTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateTime == nil {
				m.UpdateTime = &google_protobuf1.Timestamp{}
			}
			if err := m.UpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= (SupportRole_Role(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Comment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Comment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Comment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf1.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IssueTaxonomy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IssueTaxonomy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IssueTaxonomy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Categories == nil {
				m.Categories = make(map[string]*IssueTaxonomy_Category)
			}
			var mapkey string
			var mapvalue *IssueTaxonomy_Category
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &IssueTaxonomy_Category{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Categories[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IssueTaxonomy_Component) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Component: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Component: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Template = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcomponents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subcomponents = append(m.Subcomponents, &IssueTaxonomy_Component{})
			if err := m.Subcomponents[len(m.Subcomponents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IssueTaxonomy_Category) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Category: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Category: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Components == nil {
				m.Components = make(map[string]*IssueTaxonomy_Component)
			}
			var mapkey string
			var mapvalue *IssueTaxonomy_Component
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCommon
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCommon
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &IssueTaxonomy_Component{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCommon(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCommon
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Components[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/cloud/support/common.proto", fileDescriptorCommon) }

var fileDescriptorCommon = []byte{
	// 1355 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xc1, 0x6e, 0xdb, 0x46,
	0x13, 0x0e, 0x29, 0xc9, 0x92, 0x46, 0x96, 0xbd, 0x59, 0x38, 0xf9, 0x19, 0x25, 0x71, 0x1c, 0xfd,
	0xf8, 0x11, 0xe3, 0x07, 0x2a, 0x27, 0x4e, 0x0a, 0x04, 0x09, 0x72, 0x90, 0xa5, 0xb5, 0xc0, 0x46,
	0x26, 0x09, 0x92, 0x8e, 0x93, 0x14, 0x05, 0x41, 0x53, 0x1b, 0x95, 0x0d, 0xc9, 0x25, 0x48, 0x2a,
	0x88, 0x7a, 0x2d, 0xd0, 0x3e, 0x45, 0xdf, 0xa1, 0xa7, 0xbe, 0x40, 0x7b, 0xe8, 0xb1, 0x40, 0x5f,
	0xa0, 0xc8, 0xa1, 0xcf, 0x51, 0xec, 0x92, 0x92, 0x65, 0xc7, 0xb0, 0xa3, 0x5c, 0xb4, 0x9c, 0xd9,
	0x99, 0xd9, 0x99, 0xd9, 0xef, 0xdb, 0xb1, 0xe1, 0xee, 0x98, 0xb1, 0x71, 0x40, 0x77, 0xbc, 0x80,
	0x4d, 0x46, 0x3b, 0xe9, 0x24, 0x8e, 0x59, 0x92, 0xed, 0x78, 0x2c, 0x0c, 0x59, 0xd4, 0x89, 0x13,
	0x96, 0x31, 0x7c, 0x33, 0x37, 0xe9, 0x08, 0x93, 0x4e, 0x61, 0xd2, 0xc9, 0x4d, 0x5a, 0xb7, 0x0a,
	0x7f, 0x37, 0xf6, 0x77, 0xdc, 0x28, 0x62, 0x99, 0x9b, 0xf9, 0x2c, 0x4a, 0x73, 0xd7, 0xd6, 0x9d,
	0x62, 0x57, 0x48, 0xc7, 0x93, 0x37, 0x3b, 0x99, 0x1f, 0xd2, 0x34, 0x73, 0xc3, 0x38, 0x37, 0x68,
	0xff, 0x53, 0x86, 0x35, 0x2b, 0x8f, 0xd8, 0xf5, 0x3c, 0x36, 0x89, 0x32, 0x8c, 0xa1, 0x1c, 0xb9,
	0x21, 0x55, 0xa4, 0x2d, 0x69, 0xbb, 0x6e, 0x8a, 0x6f, 0x7c, 0x1b, 0xc0, 0xcd, 0xb7, 0x1d, 0x7f,
	0xa4, 0xc8, 0x62, 0xa7, 0x5e, 0x68, 0xd4, 0x11, 0xfe, 0x1f, 0xac, 0x89, 0xe4, 0x9c, 0x84, 0xa6,
	0x6c, 0x92, 0x78, 0x54, 0x29, 0x09, 0x93, 0xa6, 0xd0, 0x9a, 0x85, 0x12, 0xdf, 0x85, 0xd5, 0x91,
	0x9f, 0xc6, 0x81, 0x3b, 0x75, 0xc4, 0x09, 0x65, 0x61, 0xd4, 0x28, 0x74, 0x1a, 0x3f, 0x68, 0x00,
	0x95, 0x34, 0x73, 0x33, 0xaa, 0x54, 0xb6, 0xa4, 0xed, 0xb5, 0xdd, 0x07, 0x9d, 0x0b, 0x6a, 0xef,
	0x9c, 0x4e, 0xbc, 0x63, 0x71, 0x47, 0x33, 0xf7, 0xc7, 0x4f, 0xa1, 0xe1, 0x25, 0xd4, 0xcd, 0xa8,
	0xc3, 0x4b, 0x56, 0x56, 0xb6, 0xa4, 0xed, 0xc6, 0x6e, 0x6b, 0x16, 0x6e, 0xd6, 0x8f, 0x8e, 0x3d,
	0xeb, 0x87, 0x09, 0xb9, 0x39, 0x57, 0xe0, 0xfb, 0xb0, 0x71, 0xec, 0x07, 0x81, 0x1f, 0x8d, 0x9d,
	0x59, 0xd9, 0x22, 0xe1, 0xaa, 0x48, 0x18, 0x17, 0x7b, 0xc5, 0xb9, 0x22, 0xef, 0x6d, 0x40, 0x93,
	0xc8, 0x7f, 0x33, 0x75, 0x16, 0xda, 0x54, 0x13, 0xd6, 0x6b, 0x42, 0xdf, 0x9d, 0xf7, 0xea, 0x1b,
	0x68, 0xc6, 0x89, 0xef, 0xf1, 0xd8, 0x21, 0x1b, 0xd1, 0x40, 0xa9, 0x8b, 0x4a, 0x1f, 0x2f, 0x53,
	0xa9, 0x91, 0x07, 0x38, 0xe0, 0xfe, 0xe6, 0x6a, 0xbc, 0x20, 0xb5, 0x0f, 0xa0, 0x22, 0xfa, 0x80,
	0xaf, 0xc1, 0x55, 0xcb, 0xee, 0xda, 0xc4, 0x39, 0xd4, 0x2c, 0x83, 0xf4, 0xd4, 0x7d, 0x95, 0xf4,
	0xd1, 0x15, 0x0c, 0xb0, 0xd2, 0xed, 0xd9, 0xea, 0x0b, 0x82, 0x24, 0xdc, 0x80, 0xaa, 0x41, 0xb4,
	0xbe, 0xaa, 0x0d, 0x90, 0x8c, 0x37, 0x00, 0x15, 0x82, 0xd3, 0x27, 0x43, 0x62, 0xab, 0xba, 0x86,
	0x4a, 0xed, 0x01, 0xac, 0x2e, 0x1e, 0x86, 0x6f, 0xc0, 0x35, 0xc3, 0x54, 0x7b, 0xdc, 0xea, 0x40,
	0xef, 0x93, 0xa1, 0x73, 0xa8, 0x3d, 0xd7, 0xf4, 0x23, 0x0d, 0x5d, 0xc1, 0xab, 0x50, 0x33, 0xba,
	0xbd, 0xe7, 0xdd, 0x01, 0xb1, 0x90, 0x84, 0xd7, 0x00, 0x0e, 0x2d, 0x62, 0x3a, 0xa6, 0x3e, 0x24,
	0x16, 0x92, 0xdb, 0xbf, 0x56, 0xa1, 0xdc, 0x73, 0x53, 0x7a, 0x2e, 0xbc, 0xce, 0x02, 0x43, 0xfe,
	0x18, 0x18, 0x5b, 0xd0, 0x18, 0xd1, 0xd4, 0x4b, 0xfc, 0x98, 0xe3, 0xbb, 0xc0, 0xd7, 0xa2, 0x0a,
	0xdf, 0x82, 0xba, 0xc7, 0xc2, 0x98, 0x45, 0x34, 0xca, 0x0a, 0x68, 0x9d, 0x28, 0x70, 0x1b, 0x56,
	0xd3, 0xc9, 0xf1, 0x89, 0x41, 0x45, 0x18, 0x9c, 0xd2, 0xe1, 0x7b, 0xb0, 0xee, 0x05, 0x3e, 0x8d,
	0x32, 0x81, 0x99, 0xef, 0x59, 0x94, 0xe3, 0xa6, 0x6e, 0xae, 0xe5, 0x6a, 0xbb, 0xd0, 0xf2, 0x7c,
	0x3d, 0xcf, 0x71, 0x47, 0xa3, 0x84, 0xa6, 0x29, 0x4d, 0x95, 0xea, 0x56, 0x89, 0x67, 0xe3, 0x79,
	0xdd, 0x99, 0x8a, 0x33, 0x26, 0x4e, 0xd8, 0x77, 0xd4, 0x5b, 0x80, 0x42, 0xbd, 0xd0, 0xa8, 0x23,
	0xbc, 0x07, 0x2b, 0x7e, 0x9a, 0x4e, 0x68, 0xaa, 0xc0, 0x56, 0x69, 0xbb, 0xb1, 0xfb, 0xff, 0x0b,
	0xaf, 0xbf, 0x37, 0x49, 0x33, 0x16, 0xd2, 0x44, 0xe5, 0x2e, 0x66, 0xe1, 0x89, 0xf7, 0xa1, 0x16,
	0x27, 0x3e, 0x4b, 0xfc, 0x6c, 0xaa, 0x34, 0x04, 0x88, 0x2e, 0x89, 0xe2, 0xa6, 0x94, 0x43, 0x47,
	0x78, 0x98, 0x73, 0x5f, 0xfc, 0x6c, 0xc6, 0xb9, 0x55, 0x11, 0xe4, 0xde, 0xe5, 0x41, 0x2e, 0x62,
	0x5a, 0x73, 0x29, 0xa6, 0x3d, 0x85, 0xc6, 0x24, 0x1e, 0xcd, 0x9d, 0xd7, 0x2e, 0x77, 0xce, 0xcd,
	0x85, 0xf3, 0x7f, 0xa1, 0x29, 0x42, 0xb1, 0xc4, 0xa1, 0xa1, 0xeb, 0x07, 0xca, 0x7a, 0x7e, 0xa9,
	0x85, 0x92, 0x70, 0x1d, 0x6e, 0x41, 0xcd, 0x73, 0x33, 0x3a, 0x66, 0xc9, 0x54, 0x41, 0x62, 0x7f,
	0x2e, 0xb7, 0x87, 0x50, 0x9b, 0xf5, 0x03, 0x2b, 0xb0, 0x61, 0x98, 0xaa, 0x6e, 0xaa, 0xf6, 0xab,
	0x33, 0x94, 0x59, 0x01, 0xd9, 0xb8, 0x8f, 0x24, 0xb1, 0x3e, 0x40, 0xb2, 0x58, 0x77, 0x51, 0x49,
	0xac, 0x0f, 0x51, 0x59, 0xac, 0x8f, 0x50, 0xa5, 0xfd, 0x97, 0x74, 0x09, 0xf7, 0xaa, 0x50, 0xd2,
	0xc8, 0x11, 0x92, 0x38, 0x55, 0xba, 0x96, 0xa5, 0x0e, 0x34, 0xd2, 0x47, 0x32, 0xde, 0x84, 0x96,
	0xaa, 0x39, 0x86, 0xa9, 0x0f, 0x4c, 0x62, 0x59, 0xce, 0x40, 0xd7, 0x07, 0x43, 0xe2, 0x58, 0x87,
	0x86, 0xa1, 0x9b, 0x36, 0x2a, 0xe1, 0x16, 0x5c, 0x3f, 0x67, 0x9f, 0x68, 0x03, 0x54, 0xc6, 0x37,
	0xe1, 0x3f, 0x8b, 0x7b, 0x82, 0x8b, 0x8e, 0x6a, 0x59, 0x87, 0x04, 0x55, 0xf0, 0x5d, 0xb8, 0x7d,
	0xd4, 0x55, 0x6d, 0x4e, 0xd6, 0x7d, 0xdd, 0x74, 0x7a, 0x87, 0x96, 0xad, 0x1f, 0x70, 0x4e, 0x12,
	0xcb, 0xd0, 0x35, 0x8b, 0xa0, 0x15, 0xce, 0x7a, 0x4b, 0x1f, 0x1e, 0x72, 0xb6, 0x3b, 0xfa, 0xfe,
	0x3e, 0x31, 0x49, 0x1f, 0x55, 0xf9, 0x23, 0xd1, 0x1b, 0xea, 0x16, 0xe9, 0xa3, 0x5a, 0xfb, 0xe7,
	0x12, 0x34, 0x4f, 0xe1, 0x0f, 0xdf, 0x80, 0x9a, 0x40, 0x20, 0x07, 0x76, 0xce, 0xe2, 0xaa, 0x90,
	0xd5, 0x11, 0x7e, 0x3e, 0x83, 0x92, 0x2c, 0xa0, 0xf4, 0xe5, 0xa7, 0xa3, 0xba, 0x23, 0x7e, 0x2f,
	0x02, 0x56, 0x69, 0x29, 0x60, 0x3d, 0x83, 0x55, 0x3e, 0x8c, 0x82, 0x77, 0x85, 0x77, 0xf9, 0x52,
	0xef, 0x46, 0x61, 0x7f, 0x1e, 0x2e, 0x2b, 0xcb, 0xe0, 0xb2, 0xfd, 0x16, 0xe0, 0xa4, 0x1a, 0x71,
	0x45, 0xfc, 0x42, 0x9c, 0xf3, 0x20, 0x51, 0x83, 0xb2, 0x6e, 0x10, 0x0d, 0x49, 0x78, 0x1d, 0x1a,
	0x0b, 0x37, 0x89, 0x64, 0x5c, 0x87, 0xca, 0xbe, 0xfa, 0x92, 0xf4, 0x51, 0x89, 0xe3, 0xe5, 0x48,
	0xd7, 0x6c, 0x67, 0x5f, 0x7d, 0x89, 0xca, 0x5c, 0x7a, 0x41, 0xcc, 0x3c, 0x42, 0xa5, 0xfd, 0x9b,
	0x04, 0x8d, 0x62, 0x3c, 0x98, 0x2c, 0xa0, 0x78, 0x03, 0x2a, 0x39, 0x19, 0xf2, 0xab, 0xc9, 0x05,
	0xdc, 0x85, 0x72, 0xc2, 0x82, 0xd9, 0xbd, 0x7c, 0xf1, 0x29, 0xc3, 0x86, 0x47, 0xeb, 0xf0, 0x1f,
	0x53, 0xb8, 0xb6, 0xbf, 0x86, 0x72, 0x71, 0x00, 0xe2, 0x8f, 0xfa, 0x99, 0x42, 0xea, 0x50, 0xd9,
	0xeb, 0x5a, 0x6a, 0x0f, 0x49, 0xb8, 0x09, 0xf5, 0x3e, 0x79, 0x41, 0x86, 0xba, 0x41, 0x4c, 0x24,
	0x73, 0x91, 0x7f, 0x75, 0xf3, 0x89, 0x22, 0x10, 0xa7, 0xda, 0xc4, 0x31, 0xc9, 0x50, 0xed, 0xee,
	0xa9, 0x43, 0xd5, 0x7e, 0x85, 0xca, 0xed, 0x1f, 0x25, 0xa8, 0xf6, 0x58, 0x18, 0xd2, 0xfc, 0x0f,
	0x90, 0x8c, 0xbe, 0xcf, 0x66, 0x13, 0x82, 0x7f, 0x9f, 0xc5, 0x82, 0xbc, 0x14, 0x16, 0xae, 0xc3,
	0x8a, 0x3b, 0xc9, 0xbe, 0x65, 0x49, 0x31, 0x36, 0x0a, 0x69, 0x3e, 0x8a, 0xca, 0x27, 0xa3, 0xa8,
	0xfd, 0x4b, 0x05, 0x9a, 0xe2, 0xf2, 0x6c, 0xf7, 0x3d, 0x8b, 0x58, 0x38, 0xc5, 0xaf, 0x01, 0x8a,
	0x07, 0xc3, 0xa7, 0xa9, 0x22, 0x89, 0xe7, 0xfa, 0xc9, 0x85, 0x0d, 0x3c, 0xe5, 0xdf, 0xe9, 0xcd,
	0x9d, 0x49, 0x94, 0x25, 0x53, 0x73, 0x21, 0x5a, 0xeb, 0x77, 0x09, 0xea, 0xbd, 0xf9, 0xfc, 0x39,
	0x3b, 0x06, 0xa5, 0x8f, 0xc7, 0xe0, 0x2d, 0xa8, 0x07, 0x6e, 0x34, 0x9e, 0xb8, 0x63, 0x9a, 0x2a,
	0xb2, 0x18, 0x3b, 0x27, 0x0a, 0xfe, 0xd6, 0x65, 0x34, 0x8c, 0x03, 0xce, 0xc0, 0xbc, 0xd4, 0xb9,
	0x8c, 0x5f, 0x43, 0x73, 0x71, 0xd8, 0xa5, 0x4a, 0x59, 0x54, 0xf2, 0x68, 0x99, 0x4a, 0x66, 0xce,
	0xe6, 0xe9, 0x50, 0xad, 0x9f, 0x64, 0xa8, 0x15, 0x65, 0x4e, 0x3f, 0xa5, 0x0a, 0x0f, 0x60, 0x21,
	0x11, 0x59, 0x24, 0xd2, 0x5b, 0xbe, 0xa5, 0x0b, 0x19, 0xcd, 0x7b, 0x7b, 0x92, 0x54, 0x0a, 0xeb,
	0x67, 0xb6, 0x31, 0x82, 0xd2, 0x5b, 0x3a, 0x2d, 0x32, 0xe2, 0x9f, 0xf8, 0x2b, 0xa8, 0xbc, 0x73,
	0x83, 0xc9, 0x0c, 0x51, 0x9f, 0xd7, 0x8d, 0x3c, 0xc4, 0x13, 0xf9, 0xb1, 0xd4, 0x4a, 0x60, 0xfd,
	0xcc, 0x7d, 0x9f, 0x73, 0xa8, 0x7a, 0xfa, 0xd0, 0x87, 0x9f, 0x51, 0xf9, 0xc2, 0x99, 0x7b, 0x3f,
	0x48, 0x7f, 0x7c, 0xd8, 0x94, 0xfe, 0xfc, 0xb0, 0x29, 0xfd, 0xfd, 0x61, 0x53, 0x82, 0x3b, 0x1e,
	0x0b, 0x2f, 0x8a, 0xb8, 0x77, 0xb5, 0xc7, 0xb5, 0x05, 0xcb, 0x0d, 0x4e, 0x9d, 0xd7, 0xdd, 0xc2,
	0x7e, 0xcc, 0x38, 0x98, 0x3a, 0x2c, 0x19, 0xef, 0x8c, 0x69, 0x24, 0x68, 0xb5, 0x93, 0x6f, 0xb9,
	0xb1, 0x9f, 0x9e, 0xfb, 0x4f, 0xca, 0xd3, 0x7c, 0x39, 0x5e, 0x11, 0xd6, 0x0f, 0xff, 0x0d, 0x00,
	0x00, 0xff, 0xff, 0xc9, 0xc7, 0x42, 0xe1, 0xd1, 0x0c, 0x00, 0x00,
}
