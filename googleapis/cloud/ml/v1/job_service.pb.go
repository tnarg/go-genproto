// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/cloud/ml/v1/job_service.proto

/*
	Package ml is a generated protocol buffer package.

	It is generated from these files:
		google/cloud/ml/v1/job_service.proto
		google/cloud/ml/v1/model_service.proto
		google/cloud/ml/v1/operation_metadata.proto
		google/cloud/ml/v1/prediction_service.proto
		google/cloud/ml/v1/project_service.proto

	It has these top-level messages:
		TrainingInput
		HyperparameterSpec
		ParameterSpec
		HyperparameterOutput
		TrainingOutput
		PredictionInput
		PredictionOutput
		Job
		CreateJobRequest
		ListJobsRequest
		ListJobsResponse
		GetJobRequest
		CancelJobRequest
		Model
		Version
		ManualScaling
		CreateModelRequest
		ListModelsRequest
		ListModelsResponse
		GetModelRequest
		DeleteModelRequest
		CreateVersionRequest
		ListVersionsRequest
		ListVersionsResponse
		GetVersionRequest
		DeleteVersionRequest
		SetDefaultVersionRequest
		OperationMetadata
		PredictRequest
		GetConfigRequest
		GetConfigResponse
*/
package ml

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "google.golang.org/genproto/googleapis/api/serviceconfig"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "github.com/gogo/protobuf/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// A scale tier is an abstract representation of the resources Cloud ML
// will allocate to a training job. When selecting a scale tier for your
// training job, you should consider the size of your training dataset and
// the complexity of your model. As the tiers increase, virtual machines are
// added to handle your job, and the individual machines in the cluster
// generally have more memory and greater processing power than they do at
// lower tiers. The number of training units charged per hour of processing
// increases as tiers get more advanced. Refer to the
// [pricing guide](/ml/pricing) for more details. Note that in addition to
// incurring costs, your use of training resources is constrained by the
// [quota policy](/ml/quota).
type TrainingInput_ScaleTier int32

const (
	// A single worker instance. This tier is suitable for learning how to use
	// Cloud ML, and for experimenting with new models using small datasets.
	TrainingInput_BASIC TrainingInput_ScaleTier = 0
	// Many workers and a few parameter servers.
	TrainingInput_STANDARD_1 TrainingInput_ScaleTier = 1
	// A large number of workers with many parameter servers.
	TrainingInput_PREMIUM_1 TrainingInput_ScaleTier = 3
	// A single worker instance [with a GPU](ml/docs/how-tos/using-gpus).
	TrainingInput_BASIC_GPU TrainingInput_ScaleTier = 6
	// The CUSTOM tier is not a set tier, but rather enables you to use your
	// own cluster specification. When you use this tier, set values to
	// configure your processing cluster according to these guidelines:
	//
	// *   You _must_ set `TrainingInput.masterType` to specify the type
	//     of machine to use for your master node. This is the only required
	//     setting.
	//
	// *   You _may_ set `TrainingInput.workerCount` to specify the number of
	//     workers to use. If you specify one or more workers, you _must_ also
	//     set `TrainingInput.workerType` to specify the type of machine to use
	//     for your worker nodes.
	//
	// *   You _may_ set `TrainingInput.parameterServerCount` to specify the
	//     number of parameter servers to use. If you specify one or more
	//     parameter servers, you _must_ also set
	//     `TrainingInput.parameterServerType` to specify the type of machine to
	//     use for your parameter servers.
	//
	// Note that all of your workers must use the same machine type, which can
	// be different from your parameter server type and master type. Your
	// parameter servers must likewise use the same machine type, which can be
	// different from your worker type and master type.
	TrainingInput_CUSTOM TrainingInput_ScaleTier = 5
)

var TrainingInput_ScaleTier_name = map[int32]string{
	0: "BASIC",
	1: "STANDARD_1",
	3: "PREMIUM_1",
	6: "BASIC_GPU",
	5: "CUSTOM",
}
var TrainingInput_ScaleTier_value = map[string]int32{
	"BASIC":      0,
	"STANDARD_1": 1,
	"PREMIUM_1":  3,
	"BASIC_GPU":  6,
	"CUSTOM":     5,
}

func (x TrainingInput_ScaleTier) String() string {
	return proto.EnumName(TrainingInput_ScaleTier_name, int32(x))
}
func (TrainingInput_ScaleTier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorJobService, []int{0, 0}
}

// The available types of optimization goals.
type HyperparameterSpec_GoalType int32

const (
	// Goal Type will default to maximize.
	HyperparameterSpec_GOAL_TYPE_UNSPECIFIED HyperparameterSpec_GoalType = 0
	// Maximize the goal metric.
	HyperparameterSpec_MAXIMIZE HyperparameterSpec_GoalType = 1
	// Minimize the goal metric.
	HyperparameterSpec_MINIMIZE HyperparameterSpec_GoalType = 2
)

var HyperparameterSpec_GoalType_name = map[int32]string{
	0: "GOAL_TYPE_UNSPECIFIED",
	1: "MAXIMIZE",
	2: "MINIMIZE",
}
var HyperparameterSpec_GoalType_value = map[string]int32{
	"GOAL_TYPE_UNSPECIFIED": 0,
	"MAXIMIZE":              1,
	"MINIMIZE":              2,
}

func (x HyperparameterSpec_GoalType) String() string {
	return proto.EnumName(HyperparameterSpec_GoalType_name, int32(x))
}
func (HyperparameterSpec_GoalType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorJobService, []int{1, 0}
}

// The type of the parameter.
type ParameterSpec_ParameterType int32

const (
	// You must specify a valid type. Using this unspecified type will result in
	// an error.
	ParameterSpec_PARAMETER_TYPE_UNSPECIFIED ParameterSpec_ParameterType = 0
	// Type for real-valued parameters.
	ParameterSpec_DOUBLE ParameterSpec_ParameterType = 1
	// Type for integral parameters.
	ParameterSpec_INTEGER ParameterSpec_ParameterType = 2
	// The parameter is categorical, with a value chosen from the categories
	// field.
	ParameterSpec_CATEGORICAL ParameterSpec_ParameterType = 3
	// The parameter is real valued, with a fixed set of feasible points. If
	// `type==DISCRETE`, feasible_points must be provided, and
	// {`min_value`, `max_value`} will be ignored.
	ParameterSpec_DISCRETE ParameterSpec_ParameterType = 4
)

var ParameterSpec_ParameterType_name = map[int32]string{
	0: "PARAMETER_TYPE_UNSPECIFIED",
	1: "DOUBLE",
	2: "INTEGER",
	3: "CATEGORICAL",
	4: "DISCRETE",
}
var ParameterSpec_ParameterType_value = map[string]int32{
	"PARAMETER_TYPE_UNSPECIFIED": 0,
	"DOUBLE":                     1,
	"INTEGER":                    2,
	"CATEGORICAL":                3,
	"DISCRETE":                   4,
}

func (x ParameterSpec_ParameterType) String() string {
	return proto.EnumName(ParameterSpec_ParameterType_name, int32(x))
}
func (ParameterSpec_ParameterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorJobService, []int{2, 0}
}

// The type of scaling that should be applied to this parameter.
type ParameterSpec_ScaleType int32

const (
	// By default, no scaling is applied.
	ParameterSpec_NONE ParameterSpec_ScaleType = 0
	// Scales the feasible space to (0, 1) linearly.
	ParameterSpec_UNIT_LINEAR_SCALE ParameterSpec_ScaleType = 1
	// Scales the feasible space logarithmically to (0, 1). The entire feasible
	// space must be strictly positive.
	ParameterSpec_UNIT_LOG_SCALE ParameterSpec_ScaleType = 2
	// Scales the feasible space "reverse" logarithmically to (0, 1). The result
	// is that values close to the top of the feasible space are spread out more
	// than points near the bottom. The entire feasible space must be strictly
	// positive.
	ParameterSpec_UNIT_REVERSE_LOG_SCALE ParameterSpec_ScaleType = 3
)

var ParameterSpec_ScaleType_name = map[int32]string{
	0: "NONE",
	1: "UNIT_LINEAR_SCALE",
	2: "UNIT_LOG_SCALE",
	3: "UNIT_REVERSE_LOG_SCALE",
}
var ParameterSpec_ScaleType_value = map[string]int32{
	"NONE":                   0,
	"UNIT_LINEAR_SCALE":      1,
	"UNIT_LOG_SCALE":         2,
	"UNIT_REVERSE_LOG_SCALE": 3,
}

func (x ParameterSpec_ScaleType) String() string {
	return proto.EnumName(ParameterSpec_ScaleType_name, int32(x))
}
func (ParameterSpec_ScaleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorJobService, []int{2, 1}
}

// The format used to separate data instances in the source files.
type PredictionInput_DataFormat int32

const (
	// Unspecified format.
	PredictionInput_DATA_FORMAT_UNSPECIFIED PredictionInput_DataFormat = 0
	// The source file is a text file with instances separated by the
	// new-line character.
	PredictionInput_TEXT PredictionInput_DataFormat = 1
	// The source file is a TFRecord file.
	PredictionInput_TF_RECORD PredictionInput_DataFormat = 2
	// The source file is a GZIP-compressed TFRecord file.
	PredictionInput_TF_RECORD_GZIP PredictionInput_DataFormat = 3
)

var PredictionInput_DataFormat_name = map[int32]string{
	0: "DATA_FORMAT_UNSPECIFIED",
	1: "TEXT",
	2: "TF_RECORD",
	3: "TF_RECORD_GZIP",
}
var PredictionInput_DataFormat_value = map[string]int32{
	"DATA_FORMAT_UNSPECIFIED": 0,
	"TEXT":           1,
	"TF_RECORD":      2,
	"TF_RECORD_GZIP": 3,
}

func (x PredictionInput_DataFormat) String() string {
	return proto.EnumName(PredictionInput_DataFormat_name, int32(x))
}
func (PredictionInput_DataFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorJobService, []int{5, 0}
}

// Describes the job state.
type Job_State int32

const (
	// The job state is unspecified.
	Job_STATE_UNSPECIFIED Job_State = 0
	// The job has been just created and processing has not yet begun.
	Job_QUEUED Job_State = 1
	// The service is preparing to run the job.
	Job_PREPARING Job_State = 2
	// The job is in progress.
	Job_RUNNING Job_State = 3
	// The job completed successfully.
	Job_SUCCEEDED Job_State = 4
	// The job failed.
	// `error_message` should contain the details of the failure.
	Job_FAILED Job_State = 5
	// The job is being cancelled.
	// `error_message` should describe the reason for the cancellation.
	Job_CANCELLING Job_State = 6
	// The job has been cancelled.
	// `error_message` should describe the reason for the cancellation.
	Job_CANCELLED Job_State = 7
)

var Job_State_name = map[int32]string{
	0: "STATE_UNSPECIFIED",
	1: "QUEUED",
	2: "PREPARING",
	3: "RUNNING",
	4: "SUCCEEDED",
	5: "FAILED",
	6: "CANCELLING",
	7: "CANCELLED",
}
var Job_State_value = map[string]int32{
	"STATE_UNSPECIFIED": 0,
	"QUEUED":            1,
	"PREPARING":         2,
	"RUNNING":           3,
	"SUCCEEDED":         4,
	"FAILED":            5,
	"CANCELLING":        6,
	"CANCELLED":         7,
}

func (x Job_State) String() string {
	return proto.EnumName(Job_State_name, int32(x))
}
func (Job_State) EnumDescriptor() ([]byte, []int) { return fileDescriptorJobService, []int{7, 0} }

// Represents input parameters for a training job.
type TrainingInput struct {
	// Required. Specifies the machine types, the number of replicas for workers
	// and parameter servers.
	ScaleTier TrainingInput_ScaleTier `protobuf:"varint,1,opt,name=scale_tier,json=scaleTier,proto3,enum=google.cloud.ml.v1.TrainingInput_ScaleTier" json:"scale_tier,omitempty"`
	// Optional. Specifies the type of virtual machine to use for your training
	// job's master worker.
	//
	// The following types are supported:
	//
	// <dl>
	//   <dt>standard</dt>
	//   <dd>
	//   A basic machine configuration suitable for training simple models with
	//   small to moderate datasets.
	//   </dd>
	//   <dt>large_model</dt>
	//   <dd>
	//   A machine with a lot of memory, specially suited for parameter servers
	//   when your model is large (having many hidden layers or layers with very
	//   large numbers of nodes).
	//   </dd>
	//   <dt>complex_model_s</dt>
	//   <dd>
	//   A machine suitable for the master and workers of the cluster when your
	//   model requires more computation than the standard machine can handle
	//   satisfactorily.
	//   </dd>
	//   <dt>complex_model_m</dt>
	//   <dd>
	//   A machine with roughly twice the number of cores and roughly double the
	//   memory of <code suppresswarning="true">complex_model_s</code>.
	//   </dd>
	//   <dt>complex_model_l</dt>
	//   <dd>
	//   A machine with roughly twice the number of cores and roughly double the
	//   memory of <code suppresswarning="true">complex_model_m</code>.
	//   </dd>
	//   <dt>standard_gpu</dt>
	//   <dd>
	//   A machine equivalent to <code suppresswarning="true">standard</code> that
	//   also includes a
	//   <a href="ml/docs/how-tos/using-gpus">
	//   GPU that you can use in your trainer</a>.
	//   </dd>
	//   <dt>complex_model_m_gpu</dt>
	//   <dd>
	//   A machine equivalent to
	//   <code suppresswarning="true">coplex_model_m</code> that also includes
	//   four GPUs.
	//   </dd>
	// </dl>
	//
	// You must set this value when `scaleTier` is set to `CUSTOM`.
	MasterType string `protobuf:"bytes,2,opt,name=master_type,json=masterType,proto3" json:"master_type,omitempty"`
	// Optional. Specifies the type of virtual machine to use for your training
	// job's worker nodes.
	//
	// The supported values are the same as those described in the entry for
	// `masterType`.
	//
	// This value must be present when `scaleTier` is set to `CUSTOM` and
	// `workerCount` is greater than zero.
	WorkerType string `protobuf:"bytes,3,opt,name=worker_type,json=workerType,proto3" json:"worker_type,omitempty"`
	// Optional. Specifies the type of virtual machine to use for your training
	// job's parameter server.
	//
	// The supported values are the same as those described in the entry for
	// `master_type`.
	//
	// This value must be present when `scaleTier` is set to `CUSTOM` and
	// `parameter_server_count` is greater than zero.
	ParameterServerType string `protobuf:"bytes,4,opt,name=parameter_server_type,json=parameterServerType,proto3" json:"parameter_server_type,omitempty"`
	// Optional. The number of worker replicas to use for the training job. Each
	// replica in the cluster will be of the type specified in `worker_type`.
	//
	// This value can only be used when `scale_tier` is set to `CUSTOM`. If you
	// set this value, you must also set `worker_type`.
	WorkerCount int64 `protobuf:"varint,5,opt,name=worker_count,json=workerCount,proto3" json:"worker_count,omitempty"`
	// Optional. The number of parameter server replicas to use for the training
	// job. Each replica in the cluster will be of the type specified in
	// `parameter_server_type`.
	//
	// This value can only be used when `scale_tier` is set to `CUSTOM`.If you
	// set this value, you must also set `parameter_server_type`.
	ParameterServerCount int64 `protobuf:"varint,6,opt,name=parameter_server_count,json=parameterServerCount,proto3" json:"parameter_server_count,omitempty"`
	// Required. The Google Cloud Storage location of the packages with
	// the training program and any additional dependencies.
	PackageUris []string `protobuf:"bytes,7,rep,name=package_uris,json=packageUris" json:"package_uris,omitempty"`
	// Required. The Python module name to run after installing the packages.
	PythonModule string `protobuf:"bytes,8,opt,name=python_module,json=pythonModule,proto3" json:"python_module,omitempty"`
	// Optional. Command line arguments to pass to the program.
	Args []string `protobuf:"bytes,10,rep,name=args" json:"args,omitempty"`
	// Optional. The set of Hyperparameters to tune.
	Hyperparameters *HyperparameterSpec `protobuf:"bytes,12,opt,name=hyperparameters" json:"hyperparameters,omitempty"`
	// Required. The Google Compute Engine region to run the training job in.
	Region string `protobuf:"bytes,14,opt,name=region,proto3" json:"region,omitempty"`
	// Optional. A Google Cloud Storage path in which to store training outputs
	// and other data needed for training. This path is passed to your TensorFlow
	// program as the 'job_dir' command-line argument. The benefit of specifying
	// this field is that Cloud ML validates the path for use in training.
	JobDir string `protobuf:"bytes,16,opt,name=job_dir,json=jobDir,proto3" json:"job_dir,omitempty"`
	// Optional. The Google Cloud ML runtime version to use for training.  If not
	// set, Google Cloud ML will choose the latest stable version.
	RuntimeVersion string `protobuf:"bytes,15,opt,name=runtime_version,json=runtimeVersion,proto3" json:"runtime_version,omitempty"`
}

func (m *TrainingInput) Reset()                    { *m = TrainingInput{} }
func (m *TrainingInput) String() string            { return proto.CompactTextString(m) }
func (*TrainingInput) ProtoMessage()               {}
func (*TrainingInput) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{0} }

func (m *TrainingInput) GetScaleTier() TrainingInput_ScaleTier {
	if m != nil {
		return m.ScaleTier
	}
	return TrainingInput_BASIC
}

func (m *TrainingInput) GetMasterType() string {
	if m != nil {
		return m.MasterType
	}
	return ""
}

func (m *TrainingInput) GetWorkerType() string {
	if m != nil {
		return m.WorkerType
	}
	return ""
}

func (m *TrainingInput) GetParameterServerType() string {
	if m != nil {
		return m.ParameterServerType
	}
	return ""
}

func (m *TrainingInput) GetWorkerCount() int64 {
	if m != nil {
		return m.WorkerCount
	}
	return 0
}

func (m *TrainingInput) GetParameterServerCount() int64 {
	if m != nil {
		return m.ParameterServerCount
	}
	return 0
}

func (m *TrainingInput) GetPackageUris() []string {
	if m != nil {
		return m.PackageUris
	}
	return nil
}

func (m *TrainingInput) GetPythonModule() string {
	if m != nil {
		return m.PythonModule
	}
	return ""
}

func (m *TrainingInput) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *TrainingInput) GetHyperparameters() *HyperparameterSpec {
	if m != nil {
		return m.Hyperparameters
	}
	return nil
}

func (m *TrainingInput) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *TrainingInput) GetJobDir() string {
	if m != nil {
		return m.JobDir
	}
	return ""
}

func (m *TrainingInput) GetRuntimeVersion() string {
	if m != nil {
		return m.RuntimeVersion
	}
	return ""
}

// Represents a set of hyperparameters to optimize.
type HyperparameterSpec struct {
	// Required. The type of goal to use for tuning. Available types are
	// `MAXIMIZE` and `MINIMIZE`.
	//
	// Defaults to `MAXIMIZE`.
	Goal HyperparameterSpec_GoalType `protobuf:"varint,1,opt,name=goal,proto3,enum=google.cloud.ml.v1.HyperparameterSpec_GoalType" json:"goal,omitempty"`
	// Required. The set of parameters to tune.
	Params []*ParameterSpec `protobuf:"bytes,2,rep,name=params" json:"params,omitempty"`
	// Optional. How many training trials should be attempted to optimize
	// the specified hyperparameters.
	//
	// Defaults to one.
	MaxTrials int32 `protobuf:"varint,3,opt,name=max_trials,json=maxTrials,proto3" json:"max_trials,omitempty"`
	// Optional. The number of training trials to run concurrently.
	// You can reduce the time it takes to perform hyperparameter tuning by adding
	// trials in parallel. However, each trail only benefits from the information
	// gained in completed trials. That means that a trial does not get access to
	// the results of trials running at the same time, which could reduce the
	// quality of the overall optimization.
	//
	// Each trial will use the same scale tier and machine types.
	//
	// Defaults to one.
	MaxParallelTrials int32 `protobuf:"varint,4,opt,name=max_parallel_trials,json=maxParallelTrials,proto3" json:"max_parallel_trials,omitempty"`
	// Optional. The Tensorflow summary tag name to use for optimizing trials. For
	// current versions of Tensorflow, this tag name should exactly match what is
	// shown in Tensorboard, including all scopes.  For versions of Tensorflow
	// prior to 0.12, this should be only the tag passed to tf.Summary.
	// By default, "training/hptuning/metric" will be used.
	HyperparameterMetricTag string `protobuf:"bytes,5,opt,name=hyperparameter_metric_tag,json=hyperparameterMetricTag,proto3" json:"hyperparameter_metric_tag,omitempty"`
}

func (m *HyperparameterSpec) Reset()                    { *m = HyperparameterSpec{} }
func (m *HyperparameterSpec) String() string            { return proto.CompactTextString(m) }
func (*HyperparameterSpec) ProtoMessage()               {}
func (*HyperparameterSpec) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{1} }

func (m *HyperparameterSpec) GetGoal() HyperparameterSpec_GoalType {
	if m != nil {
		return m.Goal
	}
	return HyperparameterSpec_GOAL_TYPE_UNSPECIFIED
}

func (m *HyperparameterSpec) GetParams() []*ParameterSpec {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *HyperparameterSpec) GetMaxTrials() int32 {
	if m != nil {
		return m.MaxTrials
	}
	return 0
}

func (m *HyperparameterSpec) GetMaxParallelTrials() int32 {
	if m != nil {
		return m.MaxParallelTrials
	}
	return 0
}

func (m *HyperparameterSpec) GetHyperparameterMetricTag() string {
	if m != nil {
		return m.HyperparameterMetricTag
	}
	return ""
}

// Represents a single hyperparameter to optimize.
type ParameterSpec struct {
	// Required. The parameter name must be unique amongst all ParameterConfigs in
	// a HyperparameterSpec message. E.g., "learning_rate".
	ParameterName string `protobuf:"bytes,1,opt,name=parameter_name,json=parameterName,proto3" json:"parameter_name,omitempty"`
	// Required. The type of the parameter.
	Type ParameterSpec_ParameterType `protobuf:"varint,4,opt,name=type,proto3,enum=google.cloud.ml.v1.ParameterSpec_ParameterType" json:"type,omitempty"`
	// Required if type is `DOUBLE` or `INTEGER`. This field
	// should be unset if type is `CATEGORICAL`. This value should be integers if
	// type is INTEGER.
	MinValue float64 `protobuf:"fixed64,2,opt,name=min_value,json=minValue,proto3" json:"min_value,omitempty"`
	// Required if typeis `DOUBLE` or `INTEGER`. This field
	// should be unset if type is `CATEGORICAL`. This value should be integers if
	// type is `INTEGER`.
	MaxValue float64 `protobuf:"fixed64,3,opt,name=max_value,json=maxValue,proto3" json:"max_value,omitempty"`
	// Required if type is `CATEGORICAL`. The list of possible categories.
	CategoricalValues []string `protobuf:"bytes,5,rep,name=categorical_values,json=categoricalValues" json:"categorical_values,omitempty"`
	// Required if type is `DISCRETE`.
	// A list of feasible points.
	// The list should be in strictly increasing order. For instance, this
	// parameter might have possible settings of 1.5, 2.5, and 4.0. This list
	// should not contain more than 1,000 values.
	DiscreteValues []float64 `protobuf:"fixed64,6,rep,packed,name=discrete_values,json=discreteValues" json:"discrete_values,omitempty"`
	// Optional. How the parameter should be scaled to the hypercube.
	// Leave unset for categorical parameters.
	// Some kind of scaling is strongly recommended for real or integral
	// parameters (e.g., `UNIT_LINEAR_SCALE`).
	ScaleType ParameterSpec_ScaleType `protobuf:"varint,7,opt,name=scale_type,json=scaleType,proto3,enum=google.cloud.ml.v1.ParameterSpec_ScaleType" json:"scale_type,omitempty"`
}

func (m *ParameterSpec) Reset()                    { *m = ParameterSpec{} }
func (m *ParameterSpec) String() string            { return proto.CompactTextString(m) }
func (*ParameterSpec) ProtoMessage()               {}
func (*ParameterSpec) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{2} }

func (m *ParameterSpec) GetParameterName() string {
	if m != nil {
		return m.ParameterName
	}
	return ""
}

func (m *ParameterSpec) GetType() ParameterSpec_ParameterType {
	if m != nil {
		return m.Type
	}
	return ParameterSpec_PARAMETER_TYPE_UNSPECIFIED
}

func (m *ParameterSpec) GetMinValue() float64 {
	if m != nil {
		return m.MinValue
	}
	return 0
}

func (m *ParameterSpec) GetMaxValue() float64 {
	if m != nil {
		return m.MaxValue
	}
	return 0
}

func (m *ParameterSpec) GetCategoricalValues() []string {
	if m != nil {
		return m.CategoricalValues
	}
	return nil
}

func (m *ParameterSpec) GetDiscreteValues() []float64 {
	if m != nil {
		return m.DiscreteValues
	}
	return nil
}

func (m *ParameterSpec) GetScaleType() ParameterSpec_ScaleType {
	if m != nil {
		return m.ScaleType
	}
	return ParameterSpec_NONE
}

// Represents the result of a single hyperparameter tuning trial from a
// training job. The TrainingOutput object that is returned on successful
// completion of a training job with hyperparameter tuning includes a list
// of HyperparameterOutput objects, one for each successful trial.
type HyperparameterOutput struct {
	// The trial id for these results.
	TrialId string `protobuf:"bytes,1,opt,name=trial_id,json=trialId,proto3" json:"trial_id,omitempty"`
	// The hyperparameters given to this trial.
	Hyperparameters map[string]string `protobuf:"bytes,2,rep,name=hyperparameters" json:"hyperparameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The final objective metric seen for this trial.
	FinalMetric *HyperparameterOutput_HyperparameterMetric `protobuf:"bytes,3,opt,name=final_metric,json=finalMetric" json:"final_metric,omitempty"`
	// All recorded object metrics for this trial.
	AllMetrics []*HyperparameterOutput_HyperparameterMetric `protobuf:"bytes,4,rep,name=all_metrics,json=allMetrics" json:"all_metrics,omitempty"`
}

func (m *HyperparameterOutput) Reset()                    { *m = HyperparameterOutput{} }
func (m *HyperparameterOutput) String() string            { return proto.CompactTextString(m) }
func (*HyperparameterOutput) ProtoMessage()               {}
func (*HyperparameterOutput) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{3} }

func (m *HyperparameterOutput) GetTrialId() string {
	if m != nil {
		return m.TrialId
	}
	return ""
}

func (m *HyperparameterOutput) GetHyperparameters() map[string]string {
	if m != nil {
		return m.Hyperparameters
	}
	return nil
}

func (m *HyperparameterOutput) GetFinalMetric() *HyperparameterOutput_HyperparameterMetric {
	if m != nil {
		return m.FinalMetric
	}
	return nil
}

func (m *HyperparameterOutput) GetAllMetrics() []*HyperparameterOutput_HyperparameterMetric {
	if m != nil {
		return m.AllMetrics
	}
	return nil
}

// An observed value of a metric.
type HyperparameterOutput_HyperparameterMetric struct {
	// The global training step for this metric.
	TrainingStep int64 `protobuf:"varint,1,opt,name=training_step,json=trainingStep,proto3" json:"training_step,omitempty"`
	// The objective value at this training step.
	ObjectiveValue float64 `protobuf:"fixed64,2,opt,name=objective_value,json=objectiveValue,proto3" json:"objective_value,omitempty"`
}

func (m *HyperparameterOutput_HyperparameterMetric) Reset() {
	*m = HyperparameterOutput_HyperparameterMetric{}
}
func (m *HyperparameterOutput_HyperparameterMetric) String() string { return proto.CompactTextString(m) }
func (*HyperparameterOutput_HyperparameterMetric) ProtoMessage()    {}
func (*HyperparameterOutput_HyperparameterMetric) Descriptor() ([]byte, []int) {
	return fileDescriptorJobService, []int{3, 0}
}

func (m *HyperparameterOutput_HyperparameterMetric) GetTrainingStep() int64 {
	if m != nil {
		return m.TrainingStep
	}
	return 0
}

func (m *HyperparameterOutput_HyperparameterMetric) GetObjectiveValue() float64 {
	if m != nil {
		return m.ObjectiveValue
	}
	return 0
}

// Represents results of a training job. Output only.
type TrainingOutput struct {
	// The number of hyperparameter tuning trials that completed successfully.
	// Only set for hyperparameter tuning jobs.
	CompletedTrialCount int64 `protobuf:"varint,1,opt,name=completed_trial_count,json=completedTrialCount,proto3" json:"completed_trial_count,omitempty"`
	// Results for individual Hyperparameter trials.
	// Only set for hyperparameter tuning jobs.
	Trials []*HyperparameterOutput `protobuf:"bytes,2,rep,name=trials" json:"trials,omitempty"`
	// The amount of ML units consumed by the job.
	ConsumedMlUnits float64 `protobuf:"fixed64,3,opt,name=consumed_ml_units,json=consumedMlUnits,proto3" json:"consumed_ml_units,omitempty"`
	// Whether this job is a hyperparameter tuning job.
	IsHyperparameterTuningJob bool `protobuf:"varint,4,opt,name=is_hyperparameter_tuning_job,json=isHyperparameterTuningJob,proto3" json:"is_hyperparameter_tuning_job,omitempty"`
}

func (m *TrainingOutput) Reset()                    { *m = TrainingOutput{} }
func (m *TrainingOutput) String() string            { return proto.CompactTextString(m) }
func (*TrainingOutput) ProtoMessage()               {}
func (*TrainingOutput) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{4} }

func (m *TrainingOutput) GetCompletedTrialCount() int64 {
	if m != nil {
		return m.CompletedTrialCount
	}
	return 0
}

func (m *TrainingOutput) GetTrials() []*HyperparameterOutput {
	if m != nil {
		return m.Trials
	}
	return nil
}

func (m *TrainingOutput) GetConsumedMlUnits() float64 {
	if m != nil {
		return m.ConsumedMlUnits
	}
	return 0
}

func (m *TrainingOutput) GetIsHyperparameterTuningJob() bool {
	if m != nil {
		return m.IsHyperparameterTuningJob
	}
	return false
}

// Represents input parameters for a prediction job.
type PredictionInput struct {
	// Required. The model or the version to use for prediction.
	//
	// Types that are valid to be assigned to ModelVersion:
	//	*PredictionInput_ModelName
	//	*PredictionInput_VersionName
	//	*PredictionInput_Uri
	ModelVersion isPredictionInput_ModelVersion `protobuf_oneof:"model_version"`
	// Required. The format of the input data files.
	DataFormat PredictionInput_DataFormat `protobuf:"varint,3,opt,name=data_format,json=dataFormat,proto3,enum=google.cloud.ml.v1.PredictionInput_DataFormat" json:"data_format,omitempty"`
	// Required. The Google Cloud Storage location of the input data files.
	// May contain wildcards.
	InputPaths []string `protobuf:"bytes,4,rep,name=input_paths,json=inputPaths" json:"input_paths,omitempty"`
	// Required. The output Google Cloud Storage location.
	OutputPath string `protobuf:"bytes,5,opt,name=output_path,json=outputPath,proto3" json:"output_path,omitempty"`
	// Optional. The maximum number of workers to be used for parallel processing.
	// Defaults to 10 if not specified.
	MaxWorkerCount int64 `protobuf:"varint,6,opt,name=max_worker_count,json=maxWorkerCount,proto3" json:"max_worker_count,omitempty"`
	// Required. The Google Compute Engine region to run the prediction job in.
	Region string `protobuf:"bytes,7,opt,name=region,proto3" json:"region,omitempty"`
	// Optional. The Google Cloud ML runtime version to use for this batch
	// prediction. If not set, Google Cloud ML will pick the runtime version used
	// during the CreateVersion request for this model version, or choose the
	// latest stable version when model version information is not available
	// such as when the model is specified by uri.
	RuntimeVersion string `protobuf:"bytes,8,opt,name=runtime_version,json=runtimeVersion,proto3" json:"runtime_version,omitempty"`
}

func (m *PredictionInput) Reset()                    { *m = PredictionInput{} }
func (m *PredictionInput) String() string            { return proto.CompactTextString(m) }
func (*PredictionInput) ProtoMessage()               {}
func (*PredictionInput) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{5} }

type isPredictionInput_ModelVersion interface {
	isPredictionInput_ModelVersion()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PredictionInput_ModelName struct {
	ModelName string `protobuf:"bytes,1,opt,name=model_name,json=modelName,proto3,oneof"`
}
type PredictionInput_VersionName struct {
	VersionName string `protobuf:"bytes,2,opt,name=version_name,json=versionName,proto3,oneof"`
}
type PredictionInput_Uri struct {
	Uri string `protobuf:"bytes,9,opt,name=uri,proto3,oneof"`
}

func (*PredictionInput_ModelName) isPredictionInput_ModelVersion()   {}
func (*PredictionInput_VersionName) isPredictionInput_ModelVersion() {}
func (*PredictionInput_Uri) isPredictionInput_ModelVersion()         {}

func (m *PredictionInput) GetModelVersion() isPredictionInput_ModelVersion {
	if m != nil {
		return m.ModelVersion
	}
	return nil
}

func (m *PredictionInput) GetModelName() string {
	if x, ok := m.GetModelVersion().(*PredictionInput_ModelName); ok {
		return x.ModelName
	}
	return ""
}

func (m *PredictionInput) GetVersionName() string {
	if x, ok := m.GetModelVersion().(*PredictionInput_VersionName); ok {
		return x.VersionName
	}
	return ""
}

func (m *PredictionInput) GetUri() string {
	if x, ok := m.GetModelVersion().(*PredictionInput_Uri); ok {
		return x.Uri
	}
	return ""
}

func (m *PredictionInput) GetDataFormat() PredictionInput_DataFormat {
	if m != nil {
		return m.DataFormat
	}
	return PredictionInput_DATA_FORMAT_UNSPECIFIED
}

func (m *PredictionInput) GetInputPaths() []string {
	if m != nil {
		return m.InputPaths
	}
	return nil
}

func (m *PredictionInput) GetOutputPath() string {
	if m != nil {
		return m.OutputPath
	}
	return ""
}

func (m *PredictionInput) GetMaxWorkerCount() int64 {
	if m != nil {
		return m.MaxWorkerCount
	}
	return 0
}

func (m *PredictionInput) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *PredictionInput) GetRuntimeVersion() string {
	if m != nil {
		return m.RuntimeVersion
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PredictionInput) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PredictionInput_OneofMarshaler, _PredictionInput_OneofUnmarshaler, _PredictionInput_OneofSizer, []interface{}{
		(*PredictionInput_ModelName)(nil),
		(*PredictionInput_VersionName)(nil),
		(*PredictionInput_Uri)(nil),
	}
}

func _PredictionInput_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PredictionInput)
	// model_version
	switch x := m.ModelVersion.(type) {
	case *PredictionInput_ModelName:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ModelName)
	case *PredictionInput_VersionName:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.VersionName)
	case *PredictionInput_Uri:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Uri)
	case nil:
	default:
		return fmt.Errorf("PredictionInput.ModelVersion has unexpected type %T", x)
	}
	return nil
}

func _PredictionInput_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PredictionInput)
	switch tag {
	case 1: // model_version.model_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ModelVersion = &PredictionInput_ModelName{x}
		return true, err
	case 2: // model_version.version_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ModelVersion = &PredictionInput_VersionName{x}
		return true, err
	case 9: // model_version.uri
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ModelVersion = &PredictionInput_Uri{x}
		return true, err
	default:
		return false, nil
	}
}

func _PredictionInput_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PredictionInput)
	// model_version
	switch x := m.ModelVersion.(type) {
	case *PredictionInput_ModelName:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ModelName)))
		n += len(x.ModelName)
	case *PredictionInput_VersionName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.VersionName)))
		n += len(x.VersionName)
	case *PredictionInput_Uri:
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Uri)))
		n += len(x.Uri)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Represents results of a prediction job.
type PredictionOutput struct {
	// The output Google Cloud Storage location provided at the job creation time.
	OutputPath string `protobuf:"bytes,1,opt,name=output_path,json=outputPath,proto3" json:"output_path,omitempty"`
	// The number of generated predictions.
	PredictionCount int64 `protobuf:"varint,2,opt,name=prediction_count,json=predictionCount,proto3" json:"prediction_count,omitempty"`
	// The number of data instances which resulted in errors.
	ErrorCount int64 `protobuf:"varint,3,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
	// Node hours used by the batch prediction job.
	NodeHours float64 `protobuf:"fixed64,4,opt,name=node_hours,json=nodeHours,proto3" json:"node_hours,omitempty"`
}

func (m *PredictionOutput) Reset()                    { *m = PredictionOutput{} }
func (m *PredictionOutput) String() string            { return proto.CompactTextString(m) }
func (*PredictionOutput) ProtoMessage()               {}
func (*PredictionOutput) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{6} }

func (m *PredictionOutput) GetOutputPath() string {
	if m != nil {
		return m.OutputPath
	}
	return ""
}

func (m *PredictionOutput) GetPredictionCount() int64 {
	if m != nil {
		return m.PredictionCount
	}
	return 0
}

func (m *PredictionOutput) GetErrorCount() int64 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

func (m *PredictionOutput) GetNodeHours() float64 {
	if m != nil {
		return m.NodeHours
	}
	return 0
}

// Represents a training or prediction job.
type Job struct {
	// Required. The user-specified id of the job.
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Required. Parameters to create a job.
	//
	// Types that are valid to be assigned to Input:
	//	*Job_TrainingInput
	//	*Job_PredictionInput
	Input isJob_Input `protobuf_oneof:"input"`
	// Output only. When the job was created.
	CreateTime *google_protobuf2.Timestamp `protobuf:"bytes,4,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Output only. When the job processing was started.
	StartTime *google_protobuf2.Timestamp `protobuf:"bytes,5,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Output only. When the job processing was completed.
	EndTime *google_protobuf2.Timestamp `protobuf:"bytes,6,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// Output only. The detailed state of a job.
	State Job_State `protobuf:"varint,7,opt,name=state,proto3,enum=google.cloud.ml.v1.Job_State" json:"state,omitempty"`
	// Output only. The details of a failure or a cancellation.
	ErrorMessage string `protobuf:"bytes,8,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Output only. The current result of the job.
	//
	// Types that are valid to be assigned to Output:
	//	*Job_TrainingOutput
	//	*Job_PredictionOutput
	Output isJob_Output `protobuf_oneof:"output"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{7} }

type isJob_Input interface {
	isJob_Input()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isJob_Output interface {
	isJob_Output()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Job_TrainingInput struct {
	TrainingInput *TrainingInput `protobuf:"bytes,2,opt,name=training_input,json=trainingInput,oneof"`
}
type Job_PredictionInput struct {
	PredictionInput *PredictionInput `protobuf:"bytes,3,opt,name=prediction_input,json=predictionInput,oneof"`
}
type Job_TrainingOutput struct {
	TrainingOutput *TrainingOutput `protobuf:"bytes,9,opt,name=training_output,json=trainingOutput,oneof"`
}
type Job_PredictionOutput struct {
	PredictionOutput *PredictionOutput `protobuf:"bytes,10,opt,name=prediction_output,json=predictionOutput,oneof"`
}

func (*Job_TrainingInput) isJob_Input()     {}
func (*Job_PredictionInput) isJob_Input()   {}
func (*Job_TrainingOutput) isJob_Output()   {}
func (*Job_PredictionOutput) isJob_Output() {}

func (m *Job) GetInput() isJob_Input {
	if m != nil {
		return m.Input
	}
	return nil
}
func (m *Job) GetOutput() isJob_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *Job) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *Job) GetTrainingInput() *TrainingInput {
	if x, ok := m.GetInput().(*Job_TrainingInput); ok {
		return x.TrainingInput
	}
	return nil
}

func (m *Job) GetPredictionInput() *PredictionInput {
	if x, ok := m.GetInput().(*Job_PredictionInput); ok {
		return x.PredictionInput
	}
	return nil
}

func (m *Job) GetCreateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Job) GetStartTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Job) GetEndTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *Job) GetState() Job_State {
	if m != nil {
		return m.State
	}
	return Job_STATE_UNSPECIFIED
}

func (m *Job) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *Job) GetTrainingOutput() *TrainingOutput {
	if x, ok := m.GetOutput().(*Job_TrainingOutput); ok {
		return x.TrainingOutput
	}
	return nil
}

func (m *Job) GetPredictionOutput() *PredictionOutput {
	if x, ok := m.GetOutput().(*Job_PredictionOutput); ok {
		return x.PredictionOutput
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Job) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Job_OneofMarshaler, _Job_OneofUnmarshaler, _Job_OneofSizer, []interface{}{
		(*Job_TrainingInput)(nil),
		(*Job_PredictionInput)(nil),
		(*Job_TrainingOutput)(nil),
		(*Job_PredictionOutput)(nil),
	}
}

func _Job_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Job)
	// input
	switch x := m.Input.(type) {
	case *Job_TrainingInput:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TrainingInput); err != nil {
			return err
		}
	case *Job_PredictionInput:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PredictionInput); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Job.Input has unexpected type %T", x)
	}
	// output
	switch x := m.Output.(type) {
	case *Job_TrainingOutput:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TrainingOutput); err != nil {
			return err
		}
	case *Job_PredictionOutput:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PredictionOutput); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Job.Output has unexpected type %T", x)
	}
	return nil
}

func _Job_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Job)
	switch tag {
	case 2: // input.training_input
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TrainingInput)
		err := b.DecodeMessage(msg)
		m.Input = &Job_TrainingInput{msg}
		return true, err
	case 3: // input.prediction_input
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PredictionInput)
		err := b.DecodeMessage(msg)
		m.Input = &Job_PredictionInput{msg}
		return true, err
	case 9: // output.training_output
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TrainingOutput)
		err := b.DecodeMessage(msg)
		m.Output = &Job_TrainingOutput{msg}
		return true, err
	case 10: // output.prediction_output
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PredictionOutput)
		err := b.DecodeMessage(msg)
		m.Output = &Job_PredictionOutput{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Job_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Job)
	// input
	switch x := m.Input.(type) {
	case *Job_TrainingInput:
		s := proto.Size(x.TrainingInput)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Job_PredictionInput:
		s := proto.Size(x.PredictionInput)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// output
	switch x := m.Output.(type) {
	case *Job_TrainingOutput:
		s := proto.Size(x.TrainingOutput)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Job_PredictionOutput:
		s := proto.Size(x.PredictionOutput)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request message for the CreateJob method.
type CreateJobRequest struct {
	// Required. The project name.
	//
	// Authorization: requires `Editor` role on the specified project.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// Required. The job to create.
	Job *Job `protobuf:"bytes,2,opt,name=job" json:"job,omitempty"`
}

func (m *CreateJobRequest) Reset()                    { *m = CreateJobRequest{} }
func (m *CreateJobRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateJobRequest) ProtoMessage()               {}
func (*CreateJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{8} }

func (m *CreateJobRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *CreateJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

// Request message for the ListJobs method.
type ListJobsRequest struct {
	// Required. The name of the project for which to list jobs.
	//
	// Authorization: requires `Viewer` role on the specified project.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// Optional. Specifies the subset of jobs to retrieve.
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	// Optional. A page token to request the next page of results.
	//
	// You get the token from the `next_page_token` field of the response from
	// the previous call.
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Optional. The number of jobs to retrieve per "page" of results. If there
	// are more remaining results than this number, the response message will
	// contain a valid value in the `next_page_token` field.
	//
	// The default value is 20, and the maximum page size is 100.
	PageSize int32 `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *ListJobsRequest) Reset()                    { *m = ListJobsRequest{} }
func (m *ListJobsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListJobsRequest) ProtoMessage()               {}
func (*ListJobsRequest) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{9} }

func (m *ListJobsRequest) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *ListJobsRequest) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ListJobsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListJobsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// Response message for the ListJobs method.
type ListJobsResponse struct {
	// The list of jobs.
	Jobs []*Job `protobuf:"bytes,1,rep,name=jobs" json:"jobs,omitempty"`
	// Optional. Pass this token as the `page_token` field of the request for a
	// subsequent call.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *ListJobsResponse) Reset()                    { *m = ListJobsResponse{} }
func (m *ListJobsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListJobsResponse) ProtoMessage()               {}
func (*ListJobsResponse) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{10} }

func (m *ListJobsResponse) GetJobs() []*Job {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *ListJobsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Request message for the GetJob method.
type GetJobRequest struct {
	// Required. The name of the job to get the description of.
	//
	// Authorization: requires `Viewer` role on the parent project.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetJobRequest) Reset()                    { *m = GetJobRequest{} }
func (m *GetJobRequest) String() string            { return proto.CompactTextString(m) }
func (*GetJobRequest) ProtoMessage()               {}
func (*GetJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{11} }

func (m *GetJobRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Request message for the CancelJob method.
type CancelJobRequest struct {
	// Required. The name of the job to cancel.
	//
	// Authorization: requires `Editor` role on the parent project.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CancelJobRequest) Reset()                    { *m = CancelJobRequest{} }
func (m *CancelJobRequest) String() string            { return proto.CompactTextString(m) }
func (*CancelJobRequest) ProtoMessage()               {}
func (*CancelJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorJobService, []int{12} }

func (m *CancelJobRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*TrainingInput)(nil), "google.cloud.ml.v1.TrainingInput")
	proto.RegisterType((*HyperparameterSpec)(nil), "google.cloud.ml.v1.HyperparameterSpec")
	proto.RegisterType((*ParameterSpec)(nil), "google.cloud.ml.v1.ParameterSpec")
	proto.RegisterType((*HyperparameterOutput)(nil), "google.cloud.ml.v1.HyperparameterOutput")
	proto.RegisterType((*HyperparameterOutput_HyperparameterMetric)(nil), "google.cloud.ml.v1.HyperparameterOutput.HyperparameterMetric")
	proto.RegisterType((*TrainingOutput)(nil), "google.cloud.ml.v1.TrainingOutput")
	proto.RegisterType((*PredictionInput)(nil), "google.cloud.ml.v1.PredictionInput")
	proto.RegisterType((*PredictionOutput)(nil), "google.cloud.ml.v1.PredictionOutput")
	proto.RegisterType((*Job)(nil), "google.cloud.ml.v1.Job")
	proto.RegisterType((*CreateJobRequest)(nil), "google.cloud.ml.v1.CreateJobRequest")
	proto.RegisterType((*ListJobsRequest)(nil), "google.cloud.ml.v1.ListJobsRequest")
	proto.RegisterType((*ListJobsResponse)(nil), "google.cloud.ml.v1.ListJobsResponse")
	proto.RegisterType((*GetJobRequest)(nil), "google.cloud.ml.v1.GetJobRequest")
	proto.RegisterType((*CancelJobRequest)(nil), "google.cloud.ml.v1.CancelJobRequest")
	proto.RegisterEnum("google.cloud.ml.v1.TrainingInput_ScaleTier", TrainingInput_ScaleTier_name, TrainingInput_ScaleTier_value)
	proto.RegisterEnum("google.cloud.ml.v1.HyperparameterSpec_GoalType", HyperparameterSpec_GoalType_name, HyperparameterSpec_GoalType_value)
	proto.RegisterEnum("google.cloud.ml.v1.ParameterSpec_ParameterType", ParameterSpec_ParameterType_name, ParameterSpec_ParameterType_value)
	proto.RegisterEnum("google.cloud.ml.v1.ParameterSpec_ScaleType", ParameterSpec_ScaleType_name, ParameterSpec_ScaleType_value)
	proto.RegisterEnum("google.cloud.ml.v1.PredictionInput_DataFormat", PredictionInput_DataFormat_name, PredictionInput_DataFormat_value)
	proto.RegisterEnum("google.cloud.ml.v1.Job_State", Job_State_name, Job_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for JobService service

type JobServiceClient interface {
	// Creates a training or a batch prediction job.
	CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*Job, error)
	// Lists the jobs in the project.
	ListJobs(ctx context.Context, in *ListJobsRequest, opts ...grpc.CallOption) (*ListJobsResponse, error)
	// Describes a job.
	GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*Job, error)
	// Cancels a running job.
	CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
}

type jobServiceClient struct {
	cc *grpc.ClientConn
}

func NewJobServiceClient(cc *grpc.ClientConn) JobServiceClient {
	return &jobServiceClient{cc}
}

func (c *jobServiceClient) CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := grpc.Invoke(ctx, "/google.cloud.ml.v1.JobService/CreateJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) ListJobs(ctx context.Context, in *ListJobsRequest, opts ...grpc.CallOption) (*ListJobsResponse, error) {
	out := new(ListJobsResponse)
	err := grpc.Invoke(ctx, "/google.cloud.ml.v1.JobService/ListJobs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := grpc.Invoke(ctx, "/google.cloud.ml.v1.JobService/GetJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/google.cloud.ml.v1.JobService/CancelJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for JobService service

type JobServiceServer interface {
	// Creates a training or a batch prediction job.
	CreateJob(context.Context, *CreateJobRequest) (*Job, error)
	// Lists the jobs in the project.
	ListJobs(context.Context, *ListJobsRequest) (*ListJobsResponse, error)
	// Describes a job.
	GetJob(context.Context, *GetJobRequest) (*Job, error)
	// Cancels a running job.
	CancelJob(context.Context, *CancelJobRequest) (*google_protobuf1.Empty, error)
}

func RegisterJobServiceServer(s *grpc.Server, srv JobServiceServer) {
	s.RegisterService(&_JobService_serviceDesc, srv)
}

func _JobService_CreateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).CreateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.cloud.ml.v1.JobService/CreateJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).CreateJob(ctx, req.(*CreateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_ListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).ListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.cloud.ml.v1.JobService/ListJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).ListJobs(ctx, req.(*ListJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.cloud.ml.v1.JobService/GetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetJob(ctx, req.(*GetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.cloud.ml.v1.JobService/CancelJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).CancelJob(ctx, req.(*CancelJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _JobService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.ml.v1.JobService",
	HandlerType: (*JobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateJob",
			Handler:    _JobService_CreateJob_Handler,
		},
		{
			MethodName: "ListJobs",
			Handler:    _JobService_ListJobs_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _JobService_GetJob_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _JobService_CancelJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/ml/v1/job_service.proto",
}

func (m *TrainingInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrainingInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ScaleTier != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.ScaleTier))
	}
	if len(m.MasterType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.MasterType)))
		i += copy(dAtA[i:], m.MasterType)
	}
	if len(m.WorkerType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.WorkerType)))
		i += copy(dAtA[i:], m.WorkerType)
	}
	if len(m.ParameterServerType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.ParameterServerType)))
		i += copy(dAtA[i:], m.ParameterServerType)
	}
	if m.WorkerCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.WorkerCount))
	}
	if m.ParameterServerCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.ParameterServerCount))
	}
	if len(m.PackageUris) > 0 {
		for _, s := range m.PackageUris {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PythonModule) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.PythonModule)))
		i += copy(dAtA[i:], m.PythonModule)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Hyperparameters != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.Hyperparameters.Size()))
		n1, err := m.Hyperparameters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.RuntimeVersion) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.RuntimeVersion)))
		i += copy(dAtA[i:], m.RuntimeVersion)
	}
	if len(m.JobDir) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.JobDir)))
		i += copy(dAtA[i:], m.JobDir)
	}
	return i, nil
}

func (m *HyperparameterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperparameterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Goal != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.Goal))
	}
	if len(m.Params) > 0 {
		for _, msg := range m.Params {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MaxTrials != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.MaxTrials))
	}
	if m.MaxParallelTrials != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.MaxParallelTrials))
	}
	if len(m.HyperparameterMetricTag) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.HyperparameterMetricTag)))
		i += copy(dAtA[i:], m.HyperparameterMetricTag)
	}
	return i, nil
}

func (m *ParameterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParameterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ParameterName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.ParameterName)))
		i += copy(dAtA[i:], m.ParameterName)
	}
	if m.MinValue != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64JobService(dAtA, i, uint64(math.Float64bits(float64(m.MinValue))))
	}
	if m.MaxValue != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64JobService(dAtA, i, uint64(math.Float64bits(float64(m.MaxValue))))
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.Type))
	}
	if len(m.CategoricalValues) > 0 {
		for _, s := range m.CategoricalValues {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DiscreteValues) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.DiscreteValues)*8))
		for _, num := range m.DiscreteValues {
			f2 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f2)
			i++
			dAtA[i] = uint8(f2 >> 8)
			i++
			dAtA[i] = uint8(f2 >> 16)
			i++
			dAtA[i] = uint8(f2 >> 24)
			i++
			dAtA[i] = uint8(f2 >> 32)
			i++
			dAtA[i] = uint8(f2 >> 40)
			i++
			dAtA[i] = uint8(f2 >> 48)
			i++
			dAtA[i] = uint8(f2 >> 56)
			i++
		}
	}
	if m.ScaleType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.ScaleType))
	}
	return i, nil
}

func (m *HyperparameterOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperparameterOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TrialId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.TrialId)))
		i += copy(dAtA[i:], m.TrialId)
	}
	if len(m.Hyperparameters) > 0 {
		for k, _ := range m.Hyperparameters {
			dAtA[i] = 0x12
			i++
			v := m.Hyperparameters[k]
			mapSize := 1 + len(k) + sovJobService(uint64(len(k))) + 1 + len(v) + sovJobService(uint64(len(v)))
			i = encodeVarintJobService(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobService(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobService(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.FinalMetric != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.FinalMetric.Size()))
		n3, err := m.FinalMetric.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.AllMetrics) > 0 {
		for _, msg := range m.AllMetrics {
			dAtA[i] = 0x22
			i++
			i = encodeVarintJobService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HyperparameterOutput_HyperparameterMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HyperparameterOutput_HyperparameterMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TrainingStep != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.TrainingStep))
	}
	if m.ObjectiveValue != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64JobService(dAtA, i, uint64(math.Float64bits(float64(m.ObjectiveValue))))
	}
	return i, nil
}

func (m *TrainingOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrainingOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CompletedTrialCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.CompletedTrialCount))
	}
	if len(m.Trials) > 0 {
		for _, msg := range m.Trials {
			dAtA[i] = 0x12
			i++
			i = encodeVarintJobService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ConsumedMlUnits != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64JobService(dAtA, i, uint64(math.Float64bits(float64(m.ConsumedMlUnits))))
	}
	if m.IsHyperparameterTuningJob {
		dAtA[i] = 0x20
		i++
		if m.IsHyperparameterTuningJob {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PredictionInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredictionInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ModelVersion != nil {
		nn4, err := m.ModelVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.DataFormat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.DataFormat))
	}
	if len(m.InputPaths) > 0 {
		for _, s := range m.InputPaths {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.OutputPath) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.OutputPath)))
		i += copy(dAtA[i:], m.OutputPath)
	}
	if m.MaxWorkerCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.MaxWorkerCount))
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.RuntimeVersion) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.RuntimeVersion)))
		i += copy(dAtA[i:], m.RuntimeVersion)
	}
	return i, nil
}

func (m *PredictionInput_ModelName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintJobService(dAtA, i, uint64(len(m.ModelName)))
	i += copy(dAtA[i:], m.ModelName)
	return i, nil
}
func (m *PredictionInput_VersionName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintJobService(dAtA, i, uint64(len(m.VersionName)))
	i += copy(dAtA[i:], m.VersionName)
	return i, nil
}
func (m *PredictionInput_Uri) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x4a
	i++
	i = encodeVarintJobService(dAtA, i, uint64(len(m.Uri)))
	i += copy(dAtA[i:], m.Uri)
	return i, nil
}
func (m *PredictionOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredictionOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OutputPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.OutputPath)))
		i += copy(dAtA[i:], m.OutputPath)
	}
	if m.PredictionCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.PredictionCount))
	}
	if m.ErrorCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.ErrorCount))
	}
	if m.NodeHours != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64JobService(dAtA, i, uint64(math.Float64bits(float64(m.NodeHours))))
	}
	return i, nil
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.JobId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.JobId)))
		i += copy(dAtA[i:], m.JobId)
	}
	if m.Input != nil {
		nn5, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.CreateTime.Size()))
		n6, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.StartTime != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.StartTime.Size()))
		n7, err := m.StartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.EndTime != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.EndTime.Size()))
		n8, err := m.EndTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.State != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.State))
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	if m.Output != nil {
		nn9, err := m.Output.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	return i, nil
}

func (m *Job_TrainingInput) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TrainingInput != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.TrainingInput.Size()))
		n10, err := m.TrainingInput.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Job_PredictionInput) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PredictionInput != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.PredictionInput.Size()))
		n11, err := m.PredictionInput.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Job_TrainingOutput) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TrainingOutput != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.TrainingOutput.Size()))
		n12, err := m.TrainingOutput.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Job_PredictionOutput) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PredictionOutput != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.PredictionOutput.Size()))
		n13, err := m.PredictionOutput.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *CreateJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parent) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	if m.Job != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.Job.Size()))
		n14, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *ListJobsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJobsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parent) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	if len(m.Filter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintJobService(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *ListJobsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJobsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, msg := range m.Jobs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintJobService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *GetJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *CancelJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintJobService(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func encodeFixed64JobService(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32JobService(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintJobService(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TrainingInput) Size() (n int) {
	var l int
	_ = l
	if m.ScaleTier != 0 {
		n += 1 + sovJobService(uint64(m.ScaleTier))
	}
	l = len(m.MasterType)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	l = len(m.WorkerType)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	l = len(m.ParameterServerType)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.WorkerCount != 0 {
		n += 1 + sovJobService(uint64(m.WorkerCount))
	}
	if m.ParameterServerCount != 0 {
		n += 1 + sovJobService(uint64(m.ParameterServerCount))
	}
	if len(m.PackageUris) > 0 {
		for _, s := range m.PackageUris {
			l = len(s)
			n += 1 + l + sovJobService(uint64(l))
		}
	}
	l = len(m.PythonModule)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovJobService(uint64(l))
		}
	}
	if m.Hyperparameters != nil {
		l = m.Hyperparameters.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	l = len(m.RuntimeVersion)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	l = len(m.JobDir)
	if l > 0 {
		n += 2 + l + sovJobService(uint64(l))
	}
	return n
}

func (m *HyperparameterSpec) Size() (n int) {
	var l int
	_ = l
	if m.Goal != 0 {
		n += 1 + sovJobService(uint64(m.Goal))
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovJobService(uint64(l))
		}
	}
	if m.MaxTrials != 0 {
		n += 1 + sovJobService(uint64(m.MaxTrials))
	}
	if m.MaxParallelTrials != 0 {
		n += 1 + sovJobService(uint64(m.MaxParallelTrials))
	}
	l = len(m.HyperparameterMetricTag)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}

func (m *ParameterSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.ParameterName)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.MinValue != 0 {
		n += 9
	}
	if m.MaxValue != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 1 + sovJobService(uint64(m.Type))
	}
	if len(m.CategoricalValues) > 0 {
		for _, s := range m.CategoricalValues {
			l = len(s)
			n += 1 + l + sovJobService(uint64(l))
		}
	}
	if len(m.DiscreteValues) > 0 {
		n += 1 + sovJobService(uint64(len(m.DiscreteValues)*8)) + len(m.DiscreteValues)*8
	}
	if m.ScaleType != 0 {
		n += 1 + sovJobService(uint64(m.ScaleType))
	}
	return n
}

func (m *HyperparameterOutput) Size() (n int) {
	var l int
	_ = l
	l = len(m.TrialId)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if len(m.Hyperparameters) > 0 {
		for k, v := range m.Hyperparameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJobService(uint64(len(k))) + 1 + len(v) + sovJobService(uint64(len(v)))
			n += mapEntrySize + 1 + sovJobService(uint64(mapEntrySize))
		}
	}
	if m.FinalMetric != nil {
		l = m.FinalMetric.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	if len(m.AllMetrics) > 0 {
		for _, e := range m.AllMetrics {
			l = e.Size()
			n += 1 + l + sovJobService(uint64(l))
		}
	}
	return n
}

func (m *HyperparameterOutput_HyperparameterMetric) Size() (n int) {
	var l int
	_ = l
	if m.TrainingStep != 0 {
		n += 1 + sovJobService(uint64(m.TrainingStep))
	}
	if m.ObjectiveValue != 0 {
		n += 9
	}
	return n
}

func (m *TrainingOutput) Size() (n int) {
	var l int
	_ = l
	if m.CompletedTrialCount != 0 {
		n += 1 + sovJobService(uint64(m.CompletedTrialCount))
	}
	if len(m.Trials) > 0 {
		for _, e := range m.Trials {
			l = e.Size()
			n += 1 + l + sovJobService(uint64(l))
		}
	}
	if m.ConsumedMlUnits != 0 {
		n += 9
	}
	if m.IsHyperparameterTuningJob {
		n += 2
	}
	return n
}

func (m *PredictionInput) Size() (n int) {
	var l int
	_ = l
	if m.ModelVersion != nil {
		n += m.ModelVersion.Size()
	}
	if m.DataFormat != 0 {
		n += 1 + sovJobService(uint64(m.DataFormat))
	}
	if len(m.InputPaths) > 0 {
		for _, s := range m.InputPaths {
			l = len(s)
			n += 1 + l + sovJobService(uint64(l))
		}
	}
	l = len(m.OutputPath)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.MaxWorkerCount != 0 {
		n += 1 + sovJobService(uint64(m.MaxWorkerCount))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	l = len(m.RuntimeVersion)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}

func (m *PredictionInput_ModelName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ModelName)
	n += 1 + l + sovJobService(uint64(l))
	return n
}
func (m *PredictionInput_VersionName) Size() (n int) {
	var l int
	_ = l
	l = len(m.VersionName)
	n += 1 + l + sovJobService(uint64(l))
	return n
}
func (m *PredictionInput_Uri) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uri)
	n += 1 + l + sovJobService(uint64(l))
	return n
}
func (m *PredictionOutput) Size() (n int) {
	var l int
	_ = l
	l = len(m.OutputPath)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.PredictionCount != 0 {
		n += 1 + sovJobService(uint64(m.PredictionCount))
	}
	if m.ErrorCount != 0 {
		n += 1 + sovJobService(uint64(m.ErrorCount))
	}
	if m.NodeHours != 0 {
		n += 9
	}
	return n
}

func (m *Job) Size() (n int) {
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.Input != nil {
		n += m.Input.Size()
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovJobService(uint64(m.State))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.Output != nil {
		n += m.Output.Size()
	}
	return n
}

func (m *Job_TrainingInput) Size() (n int) {
	var l int
	_ = l
	if m.TrainingInput != nil {
		l = m.TrainingInput.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}
func (m *Job_PredictionInput) Size() (n int) {
	var l int
	_ = l
	if m.PredictionInput != nil {
		l = m.PredictionInput.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}
func (m *Job_TrainingOutput) Size() (n int) {
	var l int
	_ = l
	if m.TrainingOutput != nil {
		l = m.TrainingOutput.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}
func (m *Job_PredictionOutput) Size() (n int) {
	var l int
	_ = l
	if m.PredictionOutput != nil {
		l = m.PredictionOutput.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}
func (m *CreateJobRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}

func (m *ListJobsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovJobService(uint64(m.PageSize))
	}
	return n
}

func (m *ListJobsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovJobService(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}

func (m *GetJobRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}

func (m *CancelJobRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovJobService(uint64(l))
	}
	return n
}

func sovJobService(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozJobService(x uint64) (n int) {
	return sovJobService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TrainingInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrainingInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrainingInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleTier", wireType)
			}
			m.ScaleTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScaleTier |= (TrainingInput_ScaleTier(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterServerType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterServerType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerCount", wireType)
			}
			m.WorkerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterServerCount", wireType)
			}
			m.ParameterServerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParameterServerCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageUris", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageUris = append(m.PackageUris, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PythonModule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PythonModule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hyperparameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hyperparameters == nil {
				m.Hyperparameters = &HyperparameterSpec{}
			}
			if err := m.Hyperparameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperparameterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperparameterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperparameterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goal", wireType)
			}
			m.Goal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Goal |= (HyperparameterSpec_GoalType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &ParameterSpec{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTrials", wireType)
			}
			m.MaxTrials = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTrials |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallelTrials", wireType)
			}
			m.MaxParallelTrials = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallelTrials |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HyperparameterMetricTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HyperparameterMetricTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParameterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MinValue = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MaxValue = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ParameterSpec_ParameterType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoricalValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CategoricalValues = append(m.CategoricalValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.DiscreteValues = append(m.DiscreteValues, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthJobService
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.DiscreteValues = append(m.DiscreteValues, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscreteValues", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleType", wireType)
			}
			m.ScaleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScaleType |= (ParameterSpec_ScaleType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperparameterOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperparameterOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperparameterOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrialId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrialId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hyperparameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hyperparameters == nil {
				m.Hyperparameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJobService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJobService
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJobService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthJobService
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJobService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthJobService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Hyperparameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalMetric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalMetric == nil {
				m.FinalMetric = &HyperparameterOutput_HyperparameterMetric{}
			}
			if err := m.FinalMetric.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllMetrics = append(m.AllMetrics, &HyperparameterOutput_HyperparameterMetric{})
			if err := m.AllMetrics[len(m.AllMetrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HyperparameterOutput_HyperparameterMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HyperparameterMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HyperparameterMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingStep", wireType)
			}
			m.TrainingStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingStep |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectiveValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ObjectiveValue = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrainingOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrainingOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrainingOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedTrialCount", wireType)
			}
			m.CompletedTrialCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedTrialCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trials = append(m.Trials, &HyperparameterOutput{})
			if err := m.Trials[len(m.Trials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumedMlUnits", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ConsumedMlUnits = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHyperparameterTuningJob", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHyperparameterTuningJob = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredictionInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredictionInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredictionInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = &PredictionInput_ModelName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = &PredictionInput_VersionName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFormat", wireType)
			}
			m.DataFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFormat |= (PredictionInput_DataFormat(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputPaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputPaths = append(m.InputPaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWorkerCount", wireType)
			}
			m.MaxWorkerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWorkerCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = &PredictionInput_Uri{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredictionOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredictionOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredictionOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictionCount", wireType)
			}
			m.PredictionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PredictionCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeHours", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.NodeHours = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TrainingInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &Job_TrainingInput{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictionInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PredictionInput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Input = &Job_PredictionInput{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf2.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &google_protobuf2.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &google_protobuf2.Timestamp{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (Job_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TrainingOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &Job_TrainingOutput{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictionOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PredictionOutput{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Output = &Job_PredictionOutput{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJobsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJobsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJobsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJobsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJobsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJobsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &Job{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJobService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJobService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJobService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJobService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJobService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJobService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthJobService
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowJobService
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipJobService(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthJobService = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJobService   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/cloud/ml/v1/job_service.proto", fileDescriptorJobService) }

var fileDescriptorJobService = []byte{
	// 2087 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xdb, 0x6e, 0x1b, 0xc9,
	0xd1, 0xd6, 0xf0, 0x24, 0xb2, 0x28, 0x91, 0xe3, 0xb6, 0x65, 0xd3, 0xf4, 0x49, 0x1e, 0xf9, 0xf7,
	0x2f, 0x7b, 0x11, 0x12, 0xd2, 0x6e, 0x80, 0xac, 0x17, 0x8b, 0x84, 0x22, 0xc7, 0x12, 0x05, 0x91,
	0x62, 0x9a, 0x43, 0x67, 0x63, 0x04, 0x99, 0x34, 0xc9, 0x36, 0x3d, 0xf2, 0x9c, 0x76, 0xa6, 0xa9,
	0x48, 0xbb, 0x30, 0x10, 0x04, 0x41, 0x5e, 0x20, 0xf7, 0x41, 0x1e, 0x27, 0x97, 0x41, 0xf2, 0x02,
	0x81, 0x11, 0x20, 0x0f, 0x90, 0xeb, 0x00, 0x41, 0x1f, 0x78, 0xd4, 0xc1, 0x46, 0x72, 0xc7, 0xfe,
	0xea, 0xab, 0xaa, 0xee, 0xaa, 0xea, 0xea, 0x1a, 0xc2, 0x93, 0x51, 0x10, 0x8c, 0x5c, 0x5a, 0x1d,
	0xb8, 0xc1, 0x78, 0x58, 0xf5, 0xdc, 0xea, 0xe9, 0x4e, 0xf5, 0x24, 0xe8, 0xdb, 0x31, 0x8d, 0x4e,
	0x9d, 0x01, 0xad, 0x84, 0x51, 0xc0, 0x02, 0x84, 0x24, 0xab, 0x22, 0x58, 0x15, 0xcf, 0xad, 0x9c,
	0xee, 0x94, 0xef, 0x2b, 0x4d, 0x12, 0x3a, 0x55, 0xe2, 0xfb, 0x01, 0x23, 0xcc, 0x09, 0xfc, 0x58,
	0x6a, 0x94, 0x37, 0xe6, 0xa5, 0x63, 0xf6, 0x56, 0xc1, 0xf7, 0x14, 0x2c, 0x56, 0xfd, 0xf1, 0x9b,
	0x2a, 0xf5, 0x42, 0x76, 0xae, 0x84, 0x8f, 0x96, 0x85, 0xcc, 0xf1, 0x68, 0xcc, 0x88, 0x17, 0x4a,
	0x82, 0xf1, 0xbb, 0x34, 0xac, 0x5b, 0x11, 0x71, 0x7c, 0xc7, 0x1f, 0x35, 0xfd, 0x70, 0xcc, 0xd0,
	0x21, 0x40, 0x3c, 0x20, 0x2e, 0xb5, 0x99, 0x43, 0xa3, 0x92, 0xb6, 0xa9, 0x6d, 0x17, 0x76, 0x3f,
	0xab, 0x5c, 0xdc, 0x6d, 0x65, 0x41, 0xad, 0xd2, 0xe5, 0x3a, 0x96, 0x43, 0x23, 0x9c, 0x8b, 0x27,
	0x3f, 0xd1, 0x23, 0xc8, 0x7b, 0x24, 0x66, 0x34, 0xb2, 0xd9, 0x79, 0x48, 0x4b, 0x89, 0x4d, 0x6d,
	0x3b, 0x87, 0x41, 0x42, 0xd6, 0x79, 0x48, 0x39, 0xe1, 0xd7, 0x41, 0xf4, 0x6e, 0x42, 0x48, 0x4a,
	0x82, 0x84, 0x04, 0x61, 0x17, 0x36, 0x42, 0x12, 0x11, 0x8f, 0x72, 0x23, 0x3c, 0x82, 0x13, 0x6a,
	0x4a, 0x50, 0x6f, 0x4e, 0x85, 0x5d, 0x21, 0x13, 0x3a, 0x8f, 0x61, 0x4d, 0x19, 0x1d, 0x04, 0x63,
	0x9f, 0x95, 0xd2, 0x9b, 0xda, 0x76, 0x12, 0x2b, 0x47, 0x75, 0x0e, 0xa1, 0x2f, 0xe0, 0xf6, 0x05,
	0xb3, 0x92, 0x9c, 0x11, 0xe4, 0x5b, 0x4b, 0x76, 0xa5, 0xd6, 0x63, 0x58, 0x0b, 0xc9, 0xe0, 0x1d,
	0x19, 0x51, 0x7b, 0x1c, 0x39, 0x71, 0x69, 0x75, 0x33, 0xb9, 0x9d, 0xc3, 0x79, 0x85, 0xf5, 0x22,
	0x27, 0x46, 0x5b, 0xb0, 0x1e, 0x9e, 0xb3, 0xb7, 0x81, 0x6f, 0x7b, 0xc1, 0x70, 0xec, 0xd2, 0x52,
	0x56, 0xec, 0x73, 0x4d, 0x82, 0x2d, 0x81, 0x21, 0x04, 0x29, 0x12, 0x8d, 0xe2, 0x12, 0x08, 0x7d,
	0xf1, 0x1b, 0x75, 0xa0, 0xf8, 0xf6, 0x3c, 0xa4, 0xd1, 0xd4, 0x71, 0x5c, 0x5a, 0xdb, 0xd4, 0xb6,
	0xf3, 0xbb, 0x4f, 0x2f, 0x8b, 0xfd, 0xc1, 0x02, 0xb5, 0x1b, 0xd2, 0x01, 0x5e, 0x56, 0x47, 0xb7,
	0x21, 0x13, 0xd1, 0x91, 0x13, 0xf8, 0xa5, 0x82, 0xd8, 0x83, 0x5a, 0xa1, 0xff, 0x87, 0x62, 0x34,
	0xf6, 0x79, 0x21, 0xd8, 0xa7, 0x34, 0x8a, 0x39, 0xa1, 0x28, 0x08, 0x05, 0x05, 0xbf, 0x92, 0x28,
	0xba, 0x03, 0xab, 0xbc, 0x6e, 0x87, 0x4e, 0x54, 0xd2, 0xa5, 0x85, 0x93, 0xa0, 0xdf, 0x70, 0x22,
	0xa3, 0x03, 0xb9, 0x69, 0xba, 0x51, 0x0e, 0xd2, 0x7b, 0xb5, 0x6e, 0xb3, 0xae, 0xaf, 0xa0, 0x02,
	0x40, 0xd7, 0xaa, 0xb5, 0x1b, 0x35, 0xdc, 0xb0, 0x77, 0x74, 0x0d, 0xad, 0x43, 0xae, 0x83, 0xcd,
	0x56, 0xb3, 0xd7, 0xb2, 0x77, 0xf4, 0x24, 0x5f, 0x0a, 0xa6, 0xbd, 0xdf, 0xe9, 0xe9, 0x19, 0x04,
	0x90, 0xa9, 0xf7, 0xba, 0xd6, 0x71, 0x4b, 0x4f, 0x1b, 0x1f, 0x12, 0x80, 0x2e, 0x9e, 0x09, 0xd5,
	0x21, 0x35, 0x0a, 0x88, 0xab, 0xaa, 0xb0, 0xfa, 0x69, 0x91, 0xa8, 0xec, 0x07, 0xc4, 0xe5, 0x85,
	0x80, 0x85, 0x32, 0xfa, 0x12, 0x32, 0x42, 0x1e, 0x97, 0x12, 0x9b, 0xc9, 0xed, 0xfc, 0xee, 0xe3,
	0xcb, 0xcc, 0x74, 0x16, 0x62, 0xa9, 0x14, 0xd0, 0x03, 0x00, 0x8f, 0x9c, 0xd9, 0x2c, 0x72, 0x88,
	0x1b, 0x8b, 0xea, 0x4c, 0xe3, 0x9c, 0x47, 0xce, 0x2c, 0x01, 0xa0, 0x0a, 0xdc, 0xe4, 0x62, 0x4e,
	0x76, 0x5d, 0xea, 0x4e, 0x78, 0x29, 0xc1, 0xbb, 0xe1, 0x91, 0xb3, 0x8e, 0x92, 0x28, 0xfe, 0x0b,
	0xb8, 0xbb, 0x98, 0x24, 0xdb, 0xa3, 0x2c, 0x72, 0x06, 0x36, 0x23, 0x23, 0x51, 0xa5, 0x39, 0x7c,
	0x67, 0x91, 0xd0, 0x12, 0x72, 0x8b, 0x8c, 0x8c, 0x1a, 0x64, 0x27, 0xe7, 0x42, 0x77, 0x61, 0x63,
	0xff, 0xb8, 0x76, 0x64, 0x5b, 0x3f, 0xef, 0x98, 0x76, 0xaf, 0xdd, 0xed, 0x98, 0xf5, 0xe6, 0xcb,
	0xa6, 0xd9, 0xd0, 0x57, 0xd0, 0x1a, 0x64, 0x5b, 0xb5, 0x6f, 0x9a, 0xad, 0xe6, 0x6b, 0x53, 0xd7,
	0xc4, 0xaa, 0xd9, 0x96, 0xab, 0x84, 0xf1, 0xa7, 0x14, 0xac, 0x2f, 0x9c, 0x13, 0xfd, 0x1f, 0x14,
	0x66, 0x7b, 0xf1, 0x89, 0x47, 0x45, 0xa4, 0x73, 0x78, 0x7d, 0x8a, 0xb6, 0x89, 0x47, 0xd1, 0x3d,
	0xc8, 0x79, 0x8e, 0x6f, 0x9f, 0x12, 0x77, 0x2c, 0x2f, 0xb1, 0x86, 0xb3, 0x9e, 0xe3, 0xbf, 0xe2,
	0x6b, 0x21, 0x24, 0x67, 0x4a, 0x98, 0x54, 0x42, 0x72, 0x26, 0x85, 0x75, 0x48, 0x4d, 0x6f, 0xeb,
	0x15, 0x09, 0x5c, 0xd8, 0xd1, 0x6c, 0x25, 0x13, 0xc8, 0x95, 0xd1, 0x0f, 0x00, 0x0d, 0x08, 0xa3,
	0xa3, 0x20, 0x72, 0x06, 0xc4, 0x95, 0x9e, 0xe2, 0x52, 0x5a, 0x5c, 0x9e, 0x1b, 0x73, 0x12, 0xe1,
	0x32, 0xe6, 0xf5, 0x3d, 0x74, 0xe2, 0x41, 0x44, 0x19, 0x9d, 0x70, 0x33, 0x9b, 0xc9, 0x6d, 0x0d,
	0x17, 0x26, 0xb0, 0x22, 0xce, 0x3a, 0x1d, 0xdf, 0xe2, 0xea, 0xd5, 0x9d, 0x6e, 0x71, 0x8b, 0xb2,
	0xf4, 0xf9, 0xf6, 0x54, 0xa7, 0x3b, 0x0f, 0xa9, 0x31, 0x9a, 0x0b, 0xad, 0xc8, 0xd1, 0x43, 0x28,
	0x77, 0x6a, 0xb8, 0xd6, 0x32, 0x2d, 0x13, 0x5f, 0x96, 0x28, 0x80, 0x4c, 0xe3, 0xb8, 0xb7, 0x77,
	0xc4, 0xd3, 0x94, 0x87, 0xd5, 0x66, 0xdb, 0x32, 0xf7, 0x4d, 0xac, 0x27, 0x50, 0x11, 0xf2, 0xf5,
	0x9a, 0x65, 0xee, 0x1f, 0xe3, 0x66, 0xbd, 0x76, 0xa4, 0x27, 0x79, 0x12, 0x1b, 0xcd, 0x6e, 0x1d,
	0x9b, 0x96, 0xa9, 0xa7, 0x8c, 0x5f, 0x4c, 0xee, 0x1e, 0x77, 0x92, 0x85, 0x54, 0xfb, 0xb8, 0x6d,
	0xea, 0x2b, 0x68, 0x03, 0x6e, 0xf4, 0xda, 0x4d, 0xcb, 0x3e, 0x6a, 0xb6, 0xcd, 0x1a, 0xb6, 0xbb,
	0xf5, 0x9a, 0xb0, 0x8c, 0xa0, 0x20, 0xe1, 0xe3, 0x7d, 0x85, 0x25, 0x50, 0x19, 0x6e, 0x0b, 0x0c,
	0x9b, 0xaf, 0x4c, 0xdc, 0x35, 0xe7, 0x64, 0x49, 0xe3, 0xf7, 0x29, 0xb8, 0xb5, 0x78, 0xa3, 0x8e,
	0xc7, 0x8c, 0xbf, 0x0a, 0x77, 0x21, 0x2b, 0xaa, 0xdb, 0x76, 0x86, 0xaa, 0x46, 0x56, 0xc5, 0xba,
	0x39, 0x44, 0xa3, 0x8b, 0x9d, 0x4b, 0x5e, 0xb4, 0xaf, 0x3f, 0x7e, 0x5f, 0xa5, 0xf5, 0x25, 0x30,
	0x36, 0x7d, 0x16, 0x9d, 0x5f, 0x6c, 0x68, 0xbf, 0x82, 0xb5, 0x37, 0x8e, 0x4f, 0x5c, 0x75, 0x6b,
	0x44, 0xb1, 0xfd, 0xf7, 0x5e, 0xe4, 0xd5, 0xc2, 0x79, 0x61, 0x52, 0x2e, 0xd0, 0x2f, 0x21, 0x4f,
	0xdc, 0x89, 0x7d, 0x7e, 0x91, 0x93, 0xff, 0xbb, 0x03, 0x20, 0xae, 0x32, 0x1f, 0x97, 0x87, 0xcb,
	0xd1, 0x55, 0x7e, 0xb7, 0x60, 0x9d, 0xa9, 0xd7, 0xd4, 0x8e, 0x19, 0x0d, 0x45, 0x88, 0x93, 0x78,
	0x6d, 0x02, 0x76, 0x19, 0x0d, 0x79, 0x5d, 0x07, 0xfd, 0x13, 0x3a, 0x60, 0xce, 0x29, 0x5d, 0xb8,
	0x8b, 0x85, 0x29, 0x2c, 0x0a, 0xbb, 0xbc, 0xb7, 0xec, 0x45, 0x06, 0x14, 0xe9, 0x90, 0x7c, 0x47,
	0xcf, 0x55, 0xfa, 0xf8, 0x4f, 0x74, 0x0b, 0xd2, 0x33, 0x43, 0x39, 0x2c, 0x17, 0x2f, 0x12, 0x3f,
	0xd2, 0x8c, 0x7f, 0x69, 0x50, 0x98, 0x3c, 0xf0, 0xaa, 0x04, 0x76, 0x61, 0x63, 0x10, 0x78, 0xa1,
	0x4b, 0x19, 0x1d, 0xca, 0x56, 0xa7, 0x9e, 0x4c, 0xb9, 0xd9, 0x9b, 0x53, 0xa1, 0xe8, 0x76, 0xf2,
	0xc5, 0xfc, 0x09, 0x64, 0x54, 0x53, 0x94, 0x25, 0xb1, 0xfd, 0xa9, 0xb1, 0xc4, 0x4a, 0x0f, 0x3d,
	0x87, 0x1b, 0x83, 0xc0, 0x8f, 0xc7, 0x1e, 0x1d, 0xda, 0x9e, 0x6b, 0x8f, 0x7d, 0x87, 0xc5, 0xaa,
	0xcd, 0x14, 0x27, 0x82, 0x96, 0xdb, 0xe3, 0x30, 0xfa, 0x31, 0xdc, 0x77, 0x62, 0x7b, 0xa9, 0xc5,
	0xb2, 0xb1, 0x08, 0xeb, 0x49, 0xd0, 0x17, 0x5d, 0x28, 0x8b, 0xef, 0x3a, 0xf1, 0xa2, 0x47, 0x4b,
	0x30, 0x0e, 0x83, 0xbe, 0xf1, 0xd7, 0x24, 0x14, 0x3b, 0x11, 0x1d, 0x3a, 0x03, 0x3e, 0x78, 0xc9,
	0x79, 0xe8, 0x11, 0x80, 0x17, 0x0c, 0xa9, 0x3b, 0xd7, 0x1f, 0x0f, 0x56, 0x70, 0x4e, 0x60, 0xa2,
	0x3b, 0x6e, 0xc1, 0x9a, 0x7a, 0x47, 0x25, 0x25, 0xa1, 0x28, 0x79, 0x85, 0x0a, 0xd2, 0x31, 0xe4,
	0x87, 0x84, 0x11, 0xfb, 0x4d, 0x10, 0x79, 0x84, 0x89, 0x03, 0x14, 0x76, 0x2b, 0x97, 0x36, 0x9b,
	0x45, 0xff, 0x95, 0x06, 0x61, 0xe4, 0xa5, 0xd0, 0xc2, 0x30, 0x9c, 0xfe, 0xe6, 0x93, 0x93, 0xc3,
	0xe5, 0x76, 0x48, 0xd8, 0x5b, 0x59, 0xaa, 0x39, 0x0c, 0x02, 0xea, 0x70, 0x84, 0x13, 0x02, 0x11,
	0x4a, 0xc1, 0x50, 0xcf, 0x0b, 0x48, 0x88, 0x33, 0xd0, 0x36, 0xe8, 0xbc, 0x71, 0x2f, 0x8c, 0x4a,
	0x72, 0xfa, 0x29, 0x78, 0xe4, 0xec, 0x67, 0x73, 0xd3, 0xd2, 0x6c, 0x92, 0x58, 0xfd, 0xd8, 0x24,
	0x91, 0xbd, 0x74, 0x92, 0x40, 0x90, 0x1c, 0x47, 0x4e, 0x29, 0xa7, 0x22, 0xc3, 0x17, 0xc6, 0x2b,
	0x80, 0xd9, 0xd1, 0xd0, 0x3d, 0xb8, 0xd3, 0xa8, 0x59, 0x35, 0xfb, 0xe5, 0x31, 0x6e, 0xd5, 0xac,
	0xa5, 0x5e, 0x99, 0x85, 0x94, 0x65, 0x7e, 0x63, 0xc9, 0x89, 0xc2, 0x7a, 0x69, 0x63, 0xb3, 0x7e,
	0x8c, 0x1b, 0x7a, 0x82, 0xb7, 0xb7, 0xe9, 0xd2, 0xde, 0x7f, 0xdd, 0xec, 0xe8, 0xc9, 0xbd, 0x22,
	0xac, 0xcb, 0x7c, 0xa9, 0x2d, 0x19, 0x7f, 0xd4, 0x40, 0x9f, 0x05, 0x55, 0x15, 0xf3, 0x52, 0x74,
	0xb4, 0x0b, 0xd1, 0x79, 0x06, 0x7a, 0x38, 0x55, 0x52, 0xd1, 0x49, 0x88, 0xe8, 0x14, 0x67, 0xb8,
	0x0c, 0xcf, 0x23, 0xc8, 0xd3, 0x28, 0x0a, 0x26, 0x31, 0x4c, 0x0a, 0x16, 0x08, 0x48, 0x12, 0x1e,
	0x00, 0xf8, 0xc1, 0x90, 0xda, 0x6f, 0x83, 0x71, 0x24, 0xc7, 0x03, 0x0d, 0xe7, 0x38, 0x72, 0xc0,
	0x01, 0xe3, 0xdf, 0x69, 0x48, 0x1e, 0x06, 0x7d, 0xb4, 0x01, 0x7c, 0xc0, 0x9a, 0x75, 0xd8, 0xf4,
	0x49, 0xd0, 0x6f, 0x0e, 0xd1, 0x21, 0x14, 0xa6, 0xcd, 0x41, 0xe4, 0x57, 0xec, 0xe3, 0x8a, 0x39,
	0x66, 0x61, 0x28, 0x3f, 0x58, 0xc1, 0xd3, 0xbe, 0x22, 0x8b, 0xb9, 0xb3, 0x70, 0x2a, 0x69, 0x4d,
	0xb6, 0xd1, 0xad, 0x4f, 0xa8, 0xc5, 0x83, 0x95, 0xf9, 0xc3, 0x4b, 0x8b, 0x5f, 0x41, 0x7e, 0x10,
	0x51, 0xc2, 0xf8, 0xf7, 0x82, 0x27, 0x1f, 0xfa, 0xfc, 0x6e, 0x79, 0x62, 0x6c, 0xf2, 0xdd, 0x51,
	0xb1, 0x26, 0xdf, 0x1d, 0x18, 0x24, 0x9d, 0x03, 0xe8, 0x4b, 0x80, 0x98, 0x91, 0x88, 0x49, 0xdd,
	0xf4, 0x47, 0x75, 0x73, 0x82, 0x2d, 0x54, 0x7f, 0x08, 0x59, 0xea, 0x0f, 0xa5, 0x62, 0xe6, 0xa3,
	0x8a, 0xab, 0xd4, 0x1f, 0x0a, 0xb5, 0xcf, 0x21, 0x1d, 0x33, 0xc2, 0x26, 0xcf, 0xfd, 0x83, 0xcb,
	0x4e, 0x7d, 0x18, 0xf4, 0x2b, 0x5d, 0x4e, 0xc2, 0x92, 0xcb, 0xdb, 0xb3, 0x4c, 0xb0, 0x47, 0xe3,
	0x98, 0x8c, 0xa6, 0x43, 0xbd, 0x00, 0x5b, 0x12, 0x43, 0x2d, 0x28, 0x4e, 0xd3, 0x24, 0xeb, 0x48,
	0xd4, 0x7b, 0x7e, 0xd7, 0xb8, 0x2e, 0x4f, 0xb2, 0x1c, 0x0f, 0x34, 0x3c, 0xcd, 0xb1, 0x2a, 0xd0,
	0x2e, 0xdc, 0x98, 0xcb, 0x94, 0x32, 0x08, 0xc2, 0xe0, 0x93, 0xeb, 0x53, 0x35, 0x35, 0x39, 0x97,
	0x6a, 0x89, 0x19, 0xbf, 0xd1, 0x20, 0x2d, 0x4e, 0xc6, 0xe7, 0x85, 0xae, 0x55, 0xb3, 0x2e, 0x99,
	0x4a, 0x7e, 0xda, 0x33, 0x7b, 0x66, 0x63, 0x3a, 0xbd, 0x77, 0x6a, 0xb8, 0xd9, 0xde, 0xd7, 0x13,
	0x7c, 0x48, 0xc1, 0xbd, 0x76, 0x9b, 0x2f, 0xc4, 0x28, 0xdf, 0xed, 0xd5, 0xeb, 0xa6, 0xd9, 0x30,
	0x1b, 0x7a, 0x8a, 0xab, 0xbd, 0xac, 0x35, 0x8f, 0xcc, 0x86, 0x9e, 0xe6, 0x1f, 0x01, 0xf5, 0x5a,
	0xbb, 0x6e, 0x1e, 0x1d, 0x71, 0x6a, 0x86, 0x53, 0xd5, 0xda, 0x6c, 0xe8, 0xab, 0x7b, 0xab, 0x90,
	0x16, 0x65, 0xb7, 0x97, 0x85, 0x8c, 0x3c, 0x95, 0xd1, 0x03, 0xbd, 0x2e, 0x6a, 0xe2, 0x30, 0xe8,
	0x63, 0xfa, 0xed, 0x98, 0xc6, 0xa2, 0xe5, 0x84, 0x24, 0xa2, 0xea, 0x75, 0xc9, 0x61, 0xb5, 0x42,
	0xcf, 0x20, 0xc9, 0x3b, 0xb9, 0xbc, 0x01, 0x77, 0xae, 0xc8, 0x1e, 0xe6, 0x1c, 0xe3, 0x3d, 0x14,
	0x8f, 0x9c, 0x98, 0x1d, 0x06, 0xfd, 0xf8, 0x63, 0x56, 0x6f, 0x43, 0xe6, 0x8d, 0xe3, 0x32, 0x1a,
	0xa9, 0x87, 0x50, 0xad, 0xf8, 0xc5, 0x0d, 0xf9, 0xd7, 0x1e, 0x0b, 0xde, 0x51, 0x5f, 0x7d, 0x72,
	0xe6, 0x38, 0x62, 0x71, 0x80, 0x8f, 0xbe, 0x42, 0x1c, 0x3b, 0xdf, 0xc9, 0xea, 0x4d, 0xe3, 0x2c,
	0x07, 0xba, 0xce, 0x77, 0x7c, 0x22, 0xd4, 0x67, 0xee, 0xe3, 0x30, 0xf0, 0x63, 0x8a, 0x3e, 0x83,
	0xd4, 0x49, 0xd0, 0x8f, 0x4b, 0x9a, 0x78, 0x0c, 0xaf, 0xdc, 0xbe, 0x20, 0xa1, 0xa7, 0x50, 0xf4,
	0xe9, 0x19, 0x6f, 0x50, 0xd3, 0x1d, 0xc8, 0xdd, 0xad, 0x73, 0xb8, 0x33, 0xd9, 0x85, 0xb1, 0x05,
	0xeb, 0xfb, 0x94, 0xcd, 0xc5, 0x0e, 0x41, 0x6a, 0x6e, 0x96, 0x17, 0xbf, 0x8d, 0xa7, 0xa0, 0xd7,
	0x89, 0x3f, 0xa0, 0xee, 0xf5, 0xbc, 0xdd, 0x7f, 0x26, 0x01, 0x0e, 0x83, 0x7e, 0x57, 0xfe, 0x57,
	0x81, 0xc6, 0x90, 0x9b, 0xa6, 0x06, 0x5d, 0x5a, 0x77, 0xcb, 0x99, 0x2b, 0x5f, 0x75, 0x2a, 0xe3,
	0xd9, 0x6f, 0xff, 0xf6, 0x8f, 0x3f, 0x24, 0xb6, 0x8c, 0xfb, 0xd5, 0xd3, 0x9d, 0xea, 0xf7, 0x32,
	0xf2, 0x5f, 0x87, 0x51, 0xc0, 0x67, 0x97, 0xb8, 0xfa, 0xfc, 0x7d, 0x95, 0x9f, 0xfa, 0x05, 0x4f,
	0x1d, 0xfa, 0x1e, 0xb2, 0x93, 0xd8, 0xa1, 0x4b, 0x1b, 0xd3, 0x52, 0x62, 0xcb, 0x4f, 0xae, 0x27,
	0xc9, 0xf0, 0x1b, 0x4f, 0xc4, 0x0e, 0x1e, 0xa2, 0x6b, 0x77, 0x80, 0x4e, 0x20, 0x23, 0xe3, 0x89,
	0x2e, 0xed, 0xb0, 0x0b, 0xb1, 0xbe, 0xfa, 0xb4, 0x8b, 0xbe, 0x78, 0x6c, 0xe7, 0x3c, 0x09, 0x47,
	0xd5, 0xe7, 0xef, 0xd1, 0x39, 0xe4, 0xa6, 0x69, 0xb9, 0x22, 0xbe, 0x4b, 0x59, 0x2b, 0xdf, 0xbe,
	0xd0, 0xe6, 0x4c, 0x2f, 0x64, 0xe7, 0x46, 0x45, 0x38, 0xdc, 0x36, 0xb6, 0xae, 0x73, 0xf8, 0x62,
	0x20, 0xcc, 0xbd, 0xd0, 0x9e, 0xef, 0x7d, 0xfb, 0xe7, 0x0f, 0x0f, 0xb5, 0xbf, 0x7c, 0x78, 0xa8,
	0xfd, 0xfd, 0xc3, 0x43, 0x0d, 0xca, 0x83, 0xc0, 0xbb, 0xe0, 0x9e, 0x84, 0x4e, 0xe5, 0x74, 0x67,
	0xaf, 0x38, 0x2b, 0x88, 0x0e, 0xf7, 0xd9, 0xd1, 0x5e, 0x7f, 0xa1, 0xa8, 0xa3, 0xc0, 0x25, 0xfe,
	0xa8, 0x12, 0x44, 0xa3, 0xea, 0x88, 0xfa, 0x62, 0x47, 0x55, 0x29, 0x22, 0xa1, 0x13, 0xcf, 0xff,
	0x05, 0xf6, 0x95, 0xe7, 0xf6, 0x33, 0x82, 0xf0, 0xf9, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xa2,
	0x96, 0x0f, 0x78, 0x22, 0x13, 0x00, 0x00,
}
