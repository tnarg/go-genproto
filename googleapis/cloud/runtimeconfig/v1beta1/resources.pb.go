// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/cloud/runtimeconfig/v1beta1/resources.proto

/*
	Package runtimeconfig is a generated protocol buffer package.

	It is generated from these files:
		google/cloud/runtimeconfig/v1beta1/resources.proto
		google/cloud/runtimeconfig/v1beta1/runtimeconfig.proto

	It has these top-level messages:
		RuntimeConfig
		Variable
		EndCondition
		Waiter
		ListConfigsRequest
		ListConfigsResponse
		GetConfigRequest
		CreateConfigRequest
		UpdateConfigRequest
		DeleteConfigRequest
		ListVariablesRequest
		ListVariablesResponse
		WatchVariableRequest
		GetVariableRequest
		CreateVariableRequest
		UpdateVariableRequest
		DeleteVariableRequest
		ListWaitersRequest
		ListWaitersResponse
		GetWaiterRequest
		CreateWaiterRequest
		DeleteWaiterRequest
*/
package runtimeconfig

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "github.com/gogo/protobuf/types"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// The `VariableState` describes the last known state of the variable and is
// used during a `variables().watch` call to distinguish the state of the
// variable.
type VariableState int32

const (
	// Default variable state.
	VariableState_VARIABLE_STATE_UNSPECIFIED VariableState = 0
	// The variable was updated, while `variables().watch` was executing.
	VariableState_UPDATED VariableState = 1
	// The variable was deleted, while `variables().watch` was executing.
	VariableState_DELETED VariableState = 2
)

var VariableState_name = map[int32]string{
	0: "VARIABLE_STATE_UNSPECIFIED",
	1: "UPDATED",
	2: "DELETED",
}
var VariableState_value = map[string]int32{
	"VARIABLE_STATE_UNSPECIFIED": 0,
	"UPDATED":                    1,
	"DELETED":                    2,
}

func (x VariableState) String() string {
	return proto.EnumName(VariableState_name, int32(x))
}
func (VariableState) EnumDescriptor() ([]byte, []int) { return fileDescriptorResources, []int{0} }

// A RuntimeConfig resource is the primary resource in the Cloud RuntimeConfig
// service. A RuntimeConfig resource consists of metadata and a hierarchy of
// variables.
type RuntimeConfig struct {
	// The resource name of a runtime config. The name must have the format:
	//
	//     projects/[PROJECT_ID]/configs/[CONFIG_NAME]
	//
	// The `[PROJECT_ID]` must be a valid project ID, and `[CONFIG_NAME]` is an
	// arbitrary name that matches RFC 1035 segment specification. The length of
	// `[CONFIG_NAME]` must be less than 64 bytes.
	//
	// You pick the RuntimeConfig resource name, but the server will validate that
	// the name adheres to this format. After you create the resource, you cannot
	// change the resource's name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// An optional description of the RuntimeConfig object.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *RuntimeConfig) Reset()                    { *m = RuntimeConfig{} }
func (m *RuntimeConfig) String() string            { return proto.CompactTextString(m) }
func (*RuntimeConfig) ProtoMessage()               {}
func (*RuntimeConfig) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{0} }

func (m *RuntimeConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RuntimeConfig) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Describes a single variable within a RuntimeConfig resource.
// The name denotes the hierarchical variable name. For example,
// `ports/serving_port` is a valid variable name. The variable value is an
// opaque string and only leaf variables can have values (that is, variables
// that do not have any child variables).
type Variable struct {
	// The name of the variable resource, in the format:
	//
	//     projects/[PROJECT_ID]/configs/[CONFIG_NAME]/variables/[VARIABLE_NAME]
	//
	// The `[PROJECT_ID]` must be a valid project ID, `[CONFIG_NAME]` must be a
	// valid RuntimeConfig reource and `[VARIABLE_NAME]` follows Unix file system
	// file path naming.
	//
	// The `[VARIABLE_NAME]` can contain ASCII letters, numbers, slashes and
	// dashes. Slashes are used as path element separators and are not part of the
	// `[VARIABLE_NAME]` itself, so `[VARIABLE_NAME]` must contain at least one
	// non-slash character. Multiple slashes are coalesced into single slash
	// character. Each path segment should follow RFC 1035 segment specification.
	// The length of a `[VARIABLE_NAME]` must be less than 256 bytes.
	//
	// Once you create a variable, you cannot change the variable name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The the value of the variable. It can be either a binary or a string
	// value. You must specify one of either `value` or `text`. Specifying both
	// will cause the server to return an error.
	//
	// Types that are valid to be assigned to Contents:
	//	*Variable_Value
	//	*Variable_Text
	Contents isVariable_Contents `protobuf_oneof:"contents"`
	// [Output Only] The time of the last variable update.
	UpdateTime *google_protobuf2.Timestamp `protobuf:"bytes,3,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
	// [Ouput only] The current state of the variable. The variable state indicates
	// the outcome of the `variables().watch` call and is visible through the
	// `get` and `list` calls.
	State VariableState `protobuf:"varint,4,opt,name=state,proto3,enum=google.cloud.runtimeconfig.v1beta1.VariableState" json:"state,omitempty"`
}

func (m *Variable) Reset()                    { *m = Variable{} }
func (m *Variable) String() string            { return proto.CompactTextString(m) }
func (*Variable) ProtoMessage()               {}
func (*Variable) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{1} }

type isVariable_Contents interface {
	isVariable_Contents()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Variable_Value struct {
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3,oneof"`
}
type Variable_Text struct {
	Text string `protobuf:"bytes,5,opt,name=text,proto3,oneof"`
}

func (*Variable_Value) isVariable_Contents() {}
func (*Variable_Text) isVariable_Contents()  {}

func (m *Variable) GetContents() isVariable_Contents {
	if m != nil {
		return m.Contents
	}
	return nil
}

func (m *Variable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Variable) GetValue() []byte {
	if x, ok := m.GetContents().(*Variable_Value); ok {
		return x.Value
	}
	return nil
}

func (m *Variable) GetText() string {
	if x, ok := m.GetContents().(*Variable_Text); ok {
		return x.Text
	}
	return ""
}

func (m *Variable) GetUpdateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *Variable) GetState() VariableState {
	if m != nil {
		return m.State
	}
	return VariableState_VARIABLE_STATE_UNSPECIFIED
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Variable) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Variable_OneofMarshaler, _Variable_OneofUnmarshaler, _Variable_OneofSizer, []interface{}{
		(*Variable_Value)(nil),
		(*Variable_Text)(nil),
	}
}

func _Variable_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Variable)
	// contents
	switch x := m.Contents.(type) {
	case *Variable_Value:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Value)
	case *Variable_Text:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Text)
	case nil:
	default:
		return fmt.Errorf("Variable.Contents has unexpected type %T", x)
	}
	return nil
}

func _Variable_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Variable)
	switch tag {
	case 2: // contents.value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Contents = &Variable_Value{x}
		return true, err
	case 5: // contents.text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Contents = &Variable_Text{x}
		return true, err
	default:
		return false, nil
	}
}

func _Variable_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Variable)
	// contents
	switch x := m.Contents.(type) {
	case *Variable_Value:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Value)))
		n += len(x.Value)
	case *Variable_Text:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Text)))
		n += len(x.Text)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The condition that a Waiter resource is waiting for.
type EndCondition struct {
	// The condition oneof holds the available condition types for this
	// EndCondition. Currently, the only available type is Cardinality.
	//
	// Types that are valid to be assigned to Condition:
	//	*EndCondition_Cardinality_
	Condition isEndCondition_Condition `protobuf_oneof:"condition"`
}

func (m *EndCondition) Reset()                    { *m = EndCondition{} }
func (m *EndCondition) String() string            { return proto.CompactTextString(m) }
func (*EndCondition) ProtoMessage()               {}
func (*EndCondition) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{2} }

type isEndCondition_Condition interface {
	isEndCondition_Condition()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EndCondition_Cardinality_ struct {
	Cardinality *EndCondition_Cardinality `protobuf:"bytes,1,opt,name=cardinality,oneof"`
}

func (*EndCondition_Cardinality_) isEndCondition_Condition() {}

func (m *EndCondition) GetCondition() isEndCondition_Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *EndCondition) GetCardinality() *EndCondition_Cardinality {
	if x, ok := m.GetCondition().(*EndCondition_Cardinality_); ok {
		return x.Cardinality
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndCondition) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndCondition_OneofMarshaler, _EndCondition_OneofUnmarshaler, _EndCondition_OneofSizer, []interface{}{
		(*EndCondition_Cardinality_)(nil),
	}
}

func _EndCondition_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndCondition)
	// condition
	switch x := m.Condition.(type) {
	case *EndCondition_Cardinality_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cardinality); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EndCondition.Condition has unexpected type %T", x)
	}
	return nil
}

func _EndCondition_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndCondition)
	switch tag {
	case 1: // condition.cardinality
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndCondition_Cardinality)
		err := b.DecodeMessage(msg)
		m.Condition = &EndCondition_Cardinality_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EndCondition_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndCondition)
	// condition
	switch x := m.Condition.(type) {
	case *EndCondition_Cardinality_:
		s := proto.Size(x.Cardinality)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A Cardinality condition for the Waiter resource. A cardinality condition is
// met when the number of variables under a specified path prefix reaches a
// predefined number. For example, if you set a Cardinality condition where
// the `path` is set to `/foo` and the number of paths is set to 2, the
// following variables would meet the condition in a RuntimeConfig resource:
//
// + `/foo/variable1 = "value1"`
// + `/foo/variable2 = "value2"`
// + `/bar/variable3 = "value3"`
//
// It would not would not satisify the same condition with the `number` set to
// 3, however, because there is only 2 paths that start with `/foo`.
// Cardinality conditions are recursive; all subtrees under the specific
// path prefix are counted.
type EndCondition_Cardinality struct {
	// The root of the variable subtree to monitor. For example, `/foo`.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The number variables under the `path` that must exist to meet this
	// condition. Defaults to 1 if not specified.
	Number int32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *EndCondition_Cardinality) Reset()         { *m = EndCondition_Cardinality{} }
func (m *EndCondition_Cardinality) String() string { return proto.CompactTextString(m) }
func (*EndCondition_Cardinality) ProtoMessage()    {}
func (*EndCondition_Cardinality) Descriptor() ([]byte, []int) {
	return fileDescriptorResources, []int{2, 0}
}

func (m *EndCondition_Cardinality) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *EndCondition_Cardinality) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// A Waiter resource waits for some end condition within a RuntimeConfig resource
// to be met before it returns. For example, assume you have a distributed
// system where each node writes to a Variable resource indidicating the node's
// readiness as part of the startup process.
//
// You then configure a Waiter resource with the success condition set to wait
// until some number of nodes have checked in. Afterwards, your application
// runs some arbitrary code after the condition has been met and the waiter
// returns successfully.
//
// Once created, a Waiter resource is immutable.
//
// To learn more about using waiters, read the
// [Creating a Waiter](/deployment-manager/runtime-configurator/creating-a-waiter)
// documentation.
type Waiter struct {
	// The name of the Waiter resource, in the format:
	//
	//     projects/[PROJECT_ID]/configs/[CONFIG_NAME]/waiters/[WAITER_NAME]
	//
	// The `[PROJECT_ID]` must be a valid Google Cloud project ID,
	// the `[CONFIG_NAME]` must be a valid RuntimeConfig resource, the
	// `[WAITER_NAME]` must match RFC 1035 segment specification, and the length
	// of `[WAITER_NAME]` must be less than 64 bytes.
	//
	// After you create a Waiter resource, you cannot change the resource name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// [Required] Specifies the timeout of the waiter in seconds, beginning from
	// the instant that `waiters().create` method is called. If this time elapses
	// before the success or failure conditions are met, the waiter fails and sets
	// the `error` code to `DEADLINE_EXCEEDED`.
	Timeout *google_protobuf1.Duration `protobuf:"bytes,2,opt,name=timeout" json:"timeout,omitempty"`
	// [Optional] The failure condition of this waiter. If this condition is met,
	// `done` will be set to `true` and the `error` code will be set to `ABORTED`.
	// The failure condition takes precedence over the success condition. If both
	// conditions are met, a failure will be indicated. This value is optional; if
	// no failure condition is set, the only failure scenario will be a timeout.
	Failure *EndCondition `protobuf:"bytes,3,opt,name=failure" json:"failure,omitempty"`
	// [Required] The success condition. If this condition is met, `done` will be
	// set to `true` and the `error` value will remain unset. The failure condition
	// takes precedence over the success condition. If both conditions are met, a
	// failure will be indicated.
	Success *EndCondition `protobuf:"bytes,4,opt,name=success" json:"success,omitempty"`
	// [Output Only] The instant at which this Waiter resource was created. Adding
	// the value of `timeout` to this instant yields the timeout deadline for the
	// waiter.
	CreateTime *google_protobuf2.Timestamp `protobuf:"bytes,5,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// [Output Only] If the value is `false`, it means the waiter is still waiting
	// for one of its conditions to be met.
	//
	// If true, the waiter has finished. If the waiter finished due to a timeout
	// or failure, `error` will be set.
	Done bool `protobuf:"varint,6,opt,name=done,proto3" json:"done,omitempty"`
	// [Output Only] If the waiter ended due to a failure or timeout, this value
	// will be set.
	Error *google_rpc.Status `protobuf:"bytes,7,opt,name=error" json:"error,omitempty"`
}

func (m *Waiter) Reset()                    { *m = Waiter{} }
func (m *Waiter) String() string            { return proto.CompactTextString(m) }
func (*Waiter) ProtoMessage()               {}
func (*Waiter) Descriptor() ([]byte, []int) { return fileDescriptorResources, []int{3} }

func (m *Waiter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Waiter) GetTimeout() *google_protobuf1.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *Waiter) GetFailure() *EndCondition {
	if m != nil {
		return m.Failure
	}
	return nil
}

func (m *Waiter) GetSuccess() *EndCondition {
	if m != nil {
		return m.Success
	}
	return nil
}

func (m *Waiter) GetCreateTime() *google_protobuf2.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *Waiter) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *Waiter) GetError() *google_rpc.Status {
	if m != nil {
		return m.Error
	}
	return nil
}

func init() {
	proto.RegisterType((*RuntimeConfig)(nil), "google.cloud.runtimeconfig.v1beta1.RuntimeConfig")
	proto.RegisterType((*Variable)(nil), "google.cloud.runtimeconfig.v1beta1.Variable")
	proto.RegisterType((*EndCondition)(nil), "google.cloud.runtimeconfig.v1beta1.EndCondition")
	proto.RegisterType((*EndCondition_Cardinality)(nil), "google.cloud.runtimeconfig.v1beta1.EndCondition.Cardinality")
	proto.RegisterType((*Waiter)(nil), "google.cloud.runtimeconfig.v1beta1.Waiter")
	proto.RegisterEnum("google.cloud.runtimeconfig.v1beta1.VariableState", VariableState_name, VariableState_value)
}
func (m *RuntimeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *Variable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Variable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Contents != nil {
		nn1, err := m.Contents.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.UpdateTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.UpdateTime.Size()))
		n2, err := m.UpdateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *Variable_Value) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}
func (m *Variable_Text) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x2a
	i++
	i = encodeVarintResources(dAtA, i, uint64(len(m.Text)))
	i += copy(dAtA[i:], m.Text)
	return i, nil
}
func (m *EndCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Condition != nil {
		nn3, err := m.Condition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *EndCondition_Cardinality_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Cardinality != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.Cardinality.Size()))
		n4, err := m.Cardinality.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *EndCondition_Cardinality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndCondition_Cardinality) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *Waiter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Waiter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintResources(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Timeout != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.Timeout.Size()))
		n5, err := m.Timeout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Failure != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.Failure.Size()))
		n6, err := m.Failure.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Success != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.Success.Size()))
		n7, err := m.Success.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.CreateTime != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.CreateTime.Size()))
		n8, err := m.CreateTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Done {
		dAtA[i] = 0x30
		i++
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Error != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintResources(dAtA, i, uint64(m.Error.Size()))
		n9, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func encodeFixed64Resources(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Resources(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintResources(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RuntimeConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}

func (m *Variable) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	if m.Contents != nil {
		n += m.Contents.Size()
	}
	if m.UpdateTime != nil {
		l = m.UpdateTime.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovResources(uint64(m.State))
	}
	return n
}

func (m *Variable_Value) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}
func (m *Variable_Text) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovResources(uint64(l))
	return n
}
func (m *EndCondition) Size() (n int) {
	var l int
	_ = l
	if m.Condition != nil {
		n += m.Condition.Size()
	}
	return n
}

func (m *EndCondition_Cardinality_) Size() (n int) {
	var l int
	_ = l
	if m.Cardinality != nil {
		l = m.Cardinality.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}
func (m *EndCondition_Cardinality) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovResources(uint64(m.Number))
	}
	return n
}

func (m *Waiter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovResources(uint64(l))
	}
	if m.Timeout != nil {
		l = m.Timeout.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	if m.Failure != nil {
		l = m.Failure.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	if m.Success != nil {
		l = m.Success.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	if m.Done {
		n += 2
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovResources(uint64(l))
	}
	return n
}

func sovResources(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozResources(x uint64) (n int) {
	return sovResources(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RuntimeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Variable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Contents = &Variable_Value{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateTime == nil {
				m.UpdateTime = &google_protobuf2.Timestamp{}
			}
			if err := m.UpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (VariableState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contents = &Variable_Text{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cardinality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndCondition_Cardinality{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Condition = &EndCondition_Cardinality_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndCondition_Cardinality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cardinality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cardinality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Waiter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowResources
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Waiter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Waiter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = &google_protobuf1.Duration{}
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Failure == nil {
				m.Failure = &EndCondition{}
			}
			if err := m.Failure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Success == nil {
				m.Success = &EndCondition{}
			}
			if err := m.Success.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &google_protobuf2.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowResources
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthResources
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &google_rpc.Status{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipResources(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthResources
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipResources(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowResources
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowResources
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowResources
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthResources
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowResources
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipResources(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthResources = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowResources   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("google/cloud/runtimeconfig/v1beta1/resources.proto", fileDescriptorResources)
}

var fileDescriptorResources = []byte{
	// 629 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0xc7, 0x9b, 0xd2, 0x8f, 0xed, 0x64, 0x43, 0x93, 0x85, 0x46, 0xa8, 0x50, 0xa9, 0x7a, 0x81,
	0x2a, 0x2e, 0x12, 0xda, 0x5d, 0xa1, 0x71, 0xd3, 0x8f, 0xb0, 0x15, 0x4d, 0x30, 0xa5, 0xdd, 0x90,
	0xb8, 0x19, 0xae, 0xe3, 0x85, 0x48, 0xa9, 0x1d, 0x39, 0xce, 0x04, 0xaf, 0x84, 0x78, 0x00, 0x1e,
	0x81, 0x4b, 0x9e, 0x00, 0xa1, 0x89, 0x07, 0x41, 0x76, 0x1c, 0x68, 0x61, 0x62, 0x83, 0x3b, 0x1f,
	0x9f, 0xf3, 0xff, 0x9d, 0x0f, 0x9f, 0x04, 0x06, 0x11, 0xe7, 0x51, 0x42, 0x3d, 0x92, 0xf0, 0x3c,
	0xf4, 0x44, 0xce, 0x64, 0xbc, 0xa4, 0x84, 0xb3, 0xf3, 0x38, 0xf2, 0x2e, 0xfa, 0x0b, 0x2a, 0x71,
	0xdf, 0x13, 0x34, 0xe3, 0xb9, 0x20, 0x34, 0x73, 0x53, 0xc1, 0x25, 0x47, 0xdd, 0x42, 0xe3, 0x6a,
	0x8d, 0xbb, 0xa6, 0x71, 0x8d, 0xa6, 0x75, 0xdf, 0x70, 0x71, 0x1a, 0x7b, 0x98, 0x31, 0x2e, 0xb1,
	0x8c, 0x39, 0x33, 0x84, 0x56, 0xdb, 0x78, 0xb5, 0xb5, 0xc8, 0xcf, 0xbd, 0x30, 0x17, 0x3a, 0xc0,
	0xf8, 0x1f, 0xfc, 0xee, 0x57, 0x19, 0x32, 0x89, 0x97, 0xa9, 0x09, 0xb8, 0x6b, 0x02, 0x44, 0x4a,
	0xbc, 0x4c, 0x62, 0x99, 0x1b, 0x72, 0xd7, 0x87, 0xed, 0xa0, 0x28, 0x68, 0xac, 0x0b, 0x42, 0x08,
	0x6a, 0x0c, 0x2f, 0xa9, 0x63, 0x75, 0xac, 0xde, 0x66, 0xa0, 0xcf, 0xa8, 0x03, 0x76, 0x48, 0x33,
	0x22, 0xe2, 0x54, 0xe5, 0x74, 0xaa, 0xda, 0xb5, 0x7a, 0xd5, 0xfd, 0x6a, 0xc1, 0xc6, 0x29, 0x16,
	0x31, 0x5e, 0x24, 0xf4, 0x4a, 0xc4, 0x2e, 0xd4, 0x2f, 0x70, 0x92, 0x53, 0x2d, 0xde, 0x3a, 0xac,
	0x04, 0x85, 0x89, 0xf6, 0xc1, 0xce, 0xd3, 0x10, 0x4b, 0x7a, 0xa6, 0x6a, 0x70, 0x6e, 0x75, 0xac,
	0x9e, 0x3d, 0x68, 0xb9, 0x66, 0x62, 0x65, 0x3f, 0xee, 0xbc, 0xec, 0x27, 0x80, 0x22, 0x5c, 0x5d,
	0xa0, 0x03, 0xa8, 0xab, 0x66, 0xa8, 0x53, 0xeb, 0x58, 0xbd, 0xdb, 0x83, 0xbe, 0x7b, 0xfd, 0xa0,
	0xdd, 0xb2, 0xca, 0x99, 0x12, 0x06, 0x85, 0x1e, 0xdd, 0x81, 0x9a, 0xa4, 0xef, 0xa4, 0x53, 0x57,
	0x15, 0x1f, 0x56, 0x02, 0x6d, 0x8d, 0x00, 0x36, 0x08, 0x67, 0x92, 0x32, 0x99, 0x75, 0x3f, 0x59,
	0xb0, 0xe5, 0xb3, 0x70, 0xcc, 0x59, 0x18, 0xab, 0x8e, 0xd1, 0x1b, 0xb0, 0x09, 0x16, 0x61, 0xcc,
	0x70, 0x12, 0xcb, 0xf7, 0xba, 0x57, 0x7b, 0xf0, 0xf4, 0x26, 0x15, 0xac, 0x62, 0xdc, 0xf1, 0x2f,
	0xc6, 0x61, 0x25, 0x58, 0x45, 0xb6, 0x9e, 0x80, 0xbd, 0xe2, 0x55, 0x53, 0x4d, 0xb1, 0x7c, 0x5b,
	0x4e, 0x55, 0x9d, 0xd1, 0x2e, 0x34, 0x58, 0xbe, 0x5c, 0x50, 0xa1, 0xc7, 0x5a, 0x0f, 0x8c, 0x35,
	0xb2, 0x61, 0x93, 0x94, 0x29, 0xba, 0xdf, 0xab, 0xd0, 0x78, 0x85, 0x63, 0x49, 0xc5, 0x95, 0x2f,
	0xb3, 0x07, 0x4d, 0x55, 0x24, 0xcf, 0xa5, 0x86, 0xd8, 0x83, 0x7b, 0x7f, 0x4c, 0x7f, 0x62, 0xb6,
	0x2d, 0x28, 0x23, 0xd1, 0x73, 0x68, 0x9e, 0xe3, 0x38, 0xc9, 0x45, 0xf9, 0x64, 0x8f, 0xff, 0xb5,
	0xf3, 0xa0, 0x04, 0x28, 0x56, 0x96, 0x13, 0x42, 0xb3, 0x4c, 0xbf, 0xe3, 0x7f, 0xb1, 0x0c, 0x40,
	0xad, 0x13, 0x11, 0xf4, 0xe7, 0x3a, 0xd5, 0xaf, 0x5f, 0xa7, 0x22, 0x5c, 0xaf, 0x13, 0x82, 0x5a,
	0xc8, 0x19, 0x75, 0x1a, 0x1d, 0xab, 0xb7, 0x11, 0xe8, 0x33, 0xea, 0x41, 0x9d, 0x0a, 0xc1, 0x85,
	0xd3, 0xd4, 0x28, 0x54, 0xa2, 0x44, 0x4a, 0xdc, 0x99, 0xfe, 0x90, 0x82, 0x22, 0xe0, 0xd1, 0x14,
	0xb6, 0xd7, 0x76, 0x0b, 0xb5, 0xa1, 0x75, 0x3a, 0x0c, 0xa6, 0xc3, 0xd1, 0x91, 0x7f, 0x36, 0x9b,
	0x0f, 0xe7, 0xfe, 0xd9, 0xc9, 0x8b, 0xd9, 0xb1, 0x3f, 0x9e, 0x3e, 0x9b, 0xfa, 0x93, 0x9d, 0x0a,
	0xb2, 0xa1, 0x79, 0x72, 0x3c, 0x19, 0xce, 0xfd, 0xc9, 0x8e, 0xa5, 0x8c, 0x89, 0x7f, 0xe4, 0x2b,
	0xa3, 0x3a, 0xfa, 0x68, 0x7d, 0xbe, 0x6c, 0x5b, 0x5f, 0x2e, 0xdb, 0xd6, 0xb7, 0xcb, 0xb6, 0x05,
	0x0f, 0x09, 0x5f, 0xde, 0x60, 0x24, 0xc7, 0xd6, 0xeb, 0x97, 0x26, 0x2a, 0xe2, 0x09, 0x66, 0x91,
	0xcb, 0x45, 0xe4, 0x45, 0x94, 0xe9, 0xb6, 0xbd, 0xc2, 0x85, 0xd3, 0x38, 0xfb, 0xdb, 0xcf, 0x6b,
	0x7f, 0xed, 0xf6, 0x43, 0xb5, 0x7b, 0x50, 0x10, 0xc7, 0x3a, 0xef, 0xda, 0xaf, 0xc2, 0x3d, 0xed,
	0x8f, 0x94, 0x64, 0xd1, 0xd0, 0x09, 0xf6, 0x7e, 0x04, 0x00, 0x00, 0xff, 0xff, 0xdc, 0xb9, 0xad,
	0xe3, 0x1c, 0x05, 0x00, 0x00,
}
