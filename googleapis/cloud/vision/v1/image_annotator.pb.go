// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/cloud/vision/v1/image_annotator.proto

package vision

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"
import google_type "google.golang.org/genproto/googleapis/type/color"
import google_type1 "google.golang.org/genproto/googleapis/type/latlng"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A bucketized representation of likelihood, which is intended to give clients
// highly stable results across model upgrades.
type Likelihood int32

const (
	// Unknown likelihood.
	Likelihood_UNKNOWN Likelihood = 0
	// It is very unlikely that the image belongs to the specified vertical.
	Likelihood_VERY_UNLIKELY Likelihood = 1
	// It is unlikely that the image belongs to the specified vertical.
	Likelihood_UNLIKELY Likelihood = 2
	// It is possible that the image belongs to the specified vertical.
	Likelihood_POSSIBLE Likelihood = 3
	// It is likely that the image belongs to the specified vertical.
	Likelihood_LIKELY Likelihood = 4
	// It is very likely that the image belongs to the specified vertical.
	Likelihood_VERY_LIKELY Likelihood = 5
)

var Likelihood_name = map[int32]string{
	0: "UNKNOWN",
	1: "VERY_UNLIKELY",
	2: "UNLIKELY",
	3: "POSSIBLE",
	4: "LIKELY",
	5: "VERY_LIKELY",
}
var Likelihood_value = map[string]int32{
	"UNKNOWN":       0,
	"VERY_UNLIKELY": 1,
	"UNLIKELY":      2,
	"POSSIBLE":      3,
	"LIKELY":        4,
	"VERY_LIKELY":   5,
}

func (x Likelihood) String() string {
	return proto.EnumName(Likelihood_name, int32(x))
}
func (Likelihood) EnumDescriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{0} }

// Type of image feature.
type Feature_Type int32

const (
	// Unspecified feature type.
	Feature_TYPE_UNSPECIFIED Feature_Type = 0
	// Run face detection.
	Feature_FACE_DETECTION Feature_Type = 1
	// Run landmark detection.
	Feature_LANDMARK_DETECTION Feature_Type = 2
	// Run logo detection.
	Feature_LOGO_DETECTION Feature_Type = 3
	// Run label detection.
	Feature_LABEL_DETECTION Feature_Type = 4
	// Run OCR.
	Feature_TEXT_DETECTION Feature_Type = 5
	// Run dense text document OCR. Takes precedence when both
	// DOCUMENT_TEXT_DETECTION and TEXT_DETECTION are present.
	Feature_DOCUMENT_TEXT_DETECTION Feature_Type = 11
	// Run computer vision models to compute image safe-search properties.
	Feature_SAFE_SEARCH_DETECTION Feature_Type = 6
	// Compute a set of image properties, such as the image's dominant colors.
	Feature_IMAGE_PROPERTIES Feature_Type = 7
	// Run crop hints.
	Feature_CROP_HINTS Feature_Type = 9
	// Run web detection.
	Feature_WEB_DETECTION Feature_Type = 10
)

var Feature_Type_name = map[int32]string{
	0:  "TYPE_UNSPECIFIED",
	1:  "FACE_DETECTION",
	2:  "LANDMARK_DETECTION",
	3:  "LOGO_DETECTION",
	4:  "LABEL_DETECTION",
	5:  "TEXT_DETECTION",
	11: "DOCUMENT_TEXT_DETECTION",
	6:  "SAFE_SEARCH_DETECTION",
	7:  "IMAGE_PROPERTIES",
	9:  "CROP_HINTS",
	10: "WEB_DETECTION",
}
var Feature_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED":        0,
	"FACE_DETECTION":          1,
	"LANDMARK_DETECTION":      2,
	"LOGO_DETECTION":          3,
	"LABEL_DETECTION":         4,
	"TEXT_DETECTION":          5,
	"DOCUMENT_TEXT_DETECTION": 11,
	"SAFE_SEARCH_DETECTION":   6,
	"IMAGE_PROPERTIES":        7,
	"CROP_HINTS":              9,
	"WEB_DETECTION":           10,
}

func (x Feature_Type) String() string {
	return proto.EnumName(Feature_Type_name, int32(x))
}
func (Feature_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{0, 0} }

// Face landmark (feature) type.
// Left and right are defined from the vantage of the viewer of the image
// without considering mirror projections typical of photos. So, `LEFT_EYE`,
// typically, is the person's right eye.
type FaceAnnotation_Landmark_Type int32

const (
	// Unknown face landmark detected. Should not be filled.
	FaceAnnotation_Landmark_UNKNOWN_LANDMARK FaceAnnotation_Landmark_Type = 0
	// Left eye.
	FaceAnnotation_Landmark_LEFT_EYE FaceAnnotation_Landmark_Type = 1
	// Right eye.
	FaceAnnotation_Landmark_RIGHT_EYE FaceAnnotation_Landmark_Type = 2
	// Left of left eyebrow.
	FaceAnnotation_Landmark_LEFT_OF_LEFT_EYEBROW FaceAnnotation_Landmark_Type = 3
	// Right of left eyebrow.
	FaceAnnotation_Landmark_RIGHT_OF_LEFT_EYEBROW FaceAnnotation_Landmark_Type = 4
	// Left of right eyebrow.
	FaceAnnotation_Landmark_LEFT_OF_RIGHT_EYEBROW FaceAnnotation_Landmark_Type = 5
	// Right of right eyebrow.
	FaceAnnotation_Landmark_RIGHT_OF_RIGHT_EYEBROW FaceAnnotation_Landmark_Type = 6
	// Midpoint between eyes.
	FaceAnnotation_Landmark_MIDPOINT_BETWEEN_EYES FaceAnnotation_Landmark_Type = 7
	// Nose tip.
	FaceAnnotation_Landmark_NOSE_TIP FaceAnnotation_Landmark_Type = 8
	// Upper lip.
	FaceAnnotation_Landmark_UPPER_LIP FaceAnnotation_Landmark_Type = 9
	// Lower lip.
	FaceAnnotation_Landmark_LOWER_LIP FaceAnnotation_Landmark_Type = 10
	// Mouth left.
	FaceAnnotation_Landmark_MOUTH_LEFT FaceAnnotation_Landmark_Type = 11
	// Mouth right.
	FaceAnnotation_Landmark_MOUTH_RIGHT FaceAnnotation_Landmark_Type = 12
	// Mouth center.
	FaceAnnotation_Landmark_MOUTH_CENTER FaceAnnotation_Landmark_Type = 13
	// Nose, bottom right.
	FaceAnnotation_Landmark_NOSE_BOTTOM_RIGHT FaceAnnotation_Landmark_Type = 14
	// Nose, bottom left.
	FaceAnnotation_Landmark_NOSE_BOTTOM_LEFT FaceAnnotation_Landmark_Type = 15
	// Nose, bottom center.
	FaceAnnotation_Landmark_NOSE_BOTTOM_CENTER FaceAnnotation_Landmark_Type = 16
	// Left eye, top boundary.
	FaceAnnotation_Landmark_LEFT_EYE_TOP_BOUNDARY FaceAnnotation_Landmark_Type = 17
	// Left eye, right corner.
	FaceAnnotation_Landmark_LEFT_EYE_RIGHT_CORNER FaceAnnotation_Landmark_Type = 18
	// Left eye, bottom boundary.
	FaceAnnotation_Landmark_LEFT_EYE_BOTTOM_BOUNDARY FaceAnnotation_Landmark_Type = 19
	// Left eye, left corner.
	FaceAnnotation_Landmark_LEFT_EYE_LEFT_CORNER FaceAnnotation_Landmark_Type = 20
	// Right eye, top boundary.
	FaceAnnotation_Landmark_RIGHT_EYE_TOP_BOUNDARY FaceAnnotation_Landmark_Type = 21
	// Right eye, right corner.
	FaceAnnotation_Landmark_RIGHT_EYE_RIGHT_CORNER FaceAnnotation_Landmark_Type = 22
	// Right eye, bottom boundary.
	FaceAnnotation_Landmark_RIGHT_EYE_BOTTOM_BOUNDARY FaceAnnotation_Landmark_Type = 23
	// Right eye, left corner.
	FaceAnnotation_Landmark_RIGHT_EYE_LEFT_CORNER FaceAnnotation_Landmark_Type = 24
	// Left eyebrow, upper midpoint.
	FaceAnnotation_Landmark_LEFT_EYEBROW_UPPER_MIDPOINT FaceAnnotation_Landmark_Type = 25
	// Right eyebrow, upper midpoint.
	FaceAnnotation_Landmark_RIGHT_EYEBROW_UPPER_MIDPOINT FaceAnnotation_Landmark_Type = 26
	// Left ear tragion.
	FaceAnnotation_Landmark_LEFT_EAR_TRAGION FaceAnnotation_Landmark_Type = 27
	// Right ear tragion.
	FaceAnnotation_Landmark_RIGHT_EAR_TRAGION FaceAnnotation_Landmark_Type = 28
	// Left eye pupil.
	FaceAnnotation_Landmark_LEFT_EYE_PUPIL FaceAnnotation_Landmark_Type = 29
	// Right eye pupil.
	FaceAnnotation_Landmark_RIGHT_EYE_PUPIL FaceAnnotation_Landmark_Type = 30
	// Forehead glabella.
	FaceAnnotation_Landmark_FOREHEAD_GLABELLA FaceAnnotation_Landmark_Type = 31
	// Chin gnathion.
	FaceAnnotation_Landmark_CHIN_GNATHION FaceAnnotation_Landmark_Type = 32
	// Chin left gonion.
	FaceAnnotation_Landmark_CHIN_LEFT_GONION FaceAnnotation_Landmark_Type = 33
	// Chin right gonion.
	FaceAnnotation_Landmark_CHIN_RIGHT_GONION FaceAnnotation_Landmark_Type = 34
)

var FaceAnnotation_Landmark_Type_name = map[int32]string{
	0:  "UNKNOWN_LANDMARK",
	1:  "LEFT_EYE",
	2:  "RIGHT_EYE",
	3:  "LEFT_OF_LEFT_EYEBROW",
	4:  "RIGHT_OF_LEFT_EYEBROW",
	5:  "LEFT_OF_RIGHT_EYEBROW",
	6:  "RIGHT_OF_RIGHT_EYEBROW",
	7:  "MIDPOINT_BETWEEN_EYES",
	8:  "NOSE_TIP",
	9:  "UPPER_LIP",
	10: "LOWER_LIP",
	11: "MOUTH_LEFT",
	12: "MOUTH_RIGHT",
	13: "MOUTH_CENTER",
	14: "NOSE_BOTTOM_RIGHT",
	15: "NOSE_BOTTOM_LEFT",
	16: "NOSE_BOTTOM_CENTER",
	17: "LEFT_EYE_TOP_BOUNDARY",
	18: "LEFT_EYE_RIGHT_CORNER",
	19: "LEFT_EYE_BOTTOM_BOUNDARY",
	20: "LEFT_EYE_LEFT_CORNER",
	21: "RIGHT_EYE_TOP_BOUNDARY",
	22: "RIGHT_EYE_RIGHT_CORNER",
	23: "RIGHT_EYE_BOTTOM_BOUNDARY",
	24: "RIGHT_EYE_LEFT_CORNER",
	25: "LEFT_EYEBROW_UPPER_MIDPOINT",
	26: "RIGHT_EYEBROW_UPPER_MIDPOINT",
	27: "LEFT_EAR_TRAGION",
	28: "RIGHT_EAR_TRAGION",
	29: "LEFT_EYE_PUPIL",
	30: "RIGHT_EYE_PUPIL",
	31: "FOREHEAD_GLABELLA",
	32: "CHIN_GNATHION",
	33: "CHIN_LEFT_GONION",
	34: "CHIN_RIGHT_GONION",
}
var FaceAnnotation_Landmark_Type_value = map[string]int32{
	"UNKNOWN_LANDMARK":             0,
	"LEFT_EYE":                     1,
	"RIGHT_EYE":                    2,
	"LEFT_OF_LEFT_EYEBROW":         3,
	"RIGHT_OF_LEFT_EYEBROW":        4,
	"LEFT_OF_RIGHT_EYEBROW":        5,
	"RIGHT_OF_RIGHT_EYEBROW":       6,
	"MIDPOINT_BETWEEN_EYES":        7,
	"NOSE_TIP":                     8,
	"UPPER_LIP":                    9,
	"LOWER_LIP":                    10,
	"MOUTH_LEFT":                   11,
	"MOUTH_RIGHT":                  12,
	"MOUTH_CENTER":                 13,
	"NOSE_BOTTOM_RIGHT":            14,
	"NOSE_BOTTOM_LEFT":             15,
	"NOSE_BOTTOM_CENTER":           16,
	"LEFT_EYE_TOP_BOUNDARY":        17,
	"LEFT_EYE_RIGHT_CORNER":        18,
	"LEFT_EYE_BOTTOM_BOUNDARY":     19,
	"LEFT_EYE_LEFT_CORNER":         20,
	"RIGHT_EYE_TOP_BOUNDARY":       21,
	"RIGHT_EYE_RIGHT_CORNER":       22,
	"RIGHT_EYE_BOTTOM_BOUNDARY":    23,
	"RIGHT_EYE_LEFT_CORNER":        24,
	"LEFT_EYEBROW_UPPER_MIDPOINT":  25,
	"RIGHT_EYEBROW_UPPER_MIDPOINT": 26,
	"LEFT_EAR_TRAGION":             27,
	"RIGHT_EAR_TRAGION":            28,
	"LEFT_EYE_PUPIL":               29,
	"RIGHT_EYE_PUPIL":              30,
	"FOREHEAD_GLABELLA":            31,
	"CHIN_GNATHION":                32,
	"CHIN_LEFT_GONION":             33,
	"CHIN_RIGHT_GONION":            34,
}

func (x FaceAnnotation_Landmark_Type) String() string {
	return proto.EnumName(FaceAnnotation_Landmark_Type_name, int32(x))
}
func (FaceAnnotation_Landmark_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImageAnnotator, []int{3, 0, 0}
}

// Users describe the type of Google Cloud Vision API tasks to perform over
// images by using *Feature*s. Each Feature indicates a type of image
// detection task to perform. Features encode the Cloud Vision API
// vertical to operate on and the number of top-scoring results to return.
type Feature struct {
	// The feature type.
	Type Feature_Type `protobuf:"varint,1,opt,name=type,proto3,enum=google.cloud.vision.v1.Feature_Type" json:"type,omitempty"`
	// Maximum number of results of this type.
	MaxResults int32 `protobuf:"varint,2,opt,name=max_results,json=maxResults,proto3" json:"max_results,omitempty"`
}

func (m *Feature) Reset()                    { *m = Feature{} }
func (m *Feature) String() string            { return proto.CompactTextString(m) }
func (*Feature) ProtoMessage()               {}
func (*Feature) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{0} }

func (m *Feature) GetType() Feature_Type {
	if m != nil {
		return m.Type
	}
	return Feature_TYPE_UNSPECIFIED
}

func (m *Feature) GetMaxResults() int32 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

// External image source (Google Cloud Storage image location).
type ImageSource struct {
	// NOTE: For new code `image_uri` below is preferred.
	// Google Cloud Storage image URI, which must be in the following form:
	// `gs://bucket_name/object_name` (for details, see
	// [Google Cloud Storage Request
	// URIs](https://cloud.google.com/storage/docs/reference-uris)).
	// NOTE: Cloud Storage object versioning is not supported.
	GcsImageUri string `protobuf:"bytes,1,opt,name=gcs_image_uri,json=gcsImageUri,proto3" json:"gcs_image_uri,omitempty"`
	// Image URI which supports:
	// 1) Google Cloud Storage image URI, which must be in the following form:
	// `gs://bucket_name/object_name` (for details, see
	// [Google Cloud Storage Request
	// URIs](https://cloud.google.com/storage/docs/reference-uris)).
	// NOTE: Cloud Storage object versioning is not supported.
	// 2) Publicly accessible image HTTP/HTTPS URL.
	// This is preferred over the legacy `gcs_image_uri` above. When both
	// `gcs_image_uri` and `image_uri` are specified, `image_uri` takes
	// precedence.
	ImageUri string `protobuf:"bytes,2,opt,name=image_uri,json=imageUri,proto3" json:"image_uri,omitempty"`
}

func (m *ImageSource) Reset()                    { *m = ImageSource{} }
func (m *ImageSource) String() string            { return proto.CompactTextString(m) }
func (*ImageSource) ProtoMessage()               {}
func (*ImageSource) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{1} }

func (m *ImageSource) GetGcsImageUri() string {
	if m != nil {
		return m.GcsImageUri
	}
	return ""
}

func (m *ImageSource) GetImageUri() string {
	if m != nil {
		return m.ImageUri
	}
	return ""
}

// Client image to perform Google Cloud Vision API tasks over.
type Image struct {
	// Image content, represented as a stream of bytes.
	// Note: as with all `bytes` fields, protobuffers use a pure binary
	// representation, whereas JSON representations use base64.
	Content []byte `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Google Cloud Storage image location. If both `content` and `source`
	// are provided for an image, `content` takes precedence and is
	// used to perform the image annotation request.
	Source *ImageSource `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{2} }

func (m *Image) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Image) GetSource() *ImageSource {
	if m != nil {
		return m.Source
	}
	return nil
}

// A face annotation object contains the results of face detection.
type FaceAnnotation struct {
	// The bounding polygon around the face. The coordinates of the bounding box
	// are in the original image's scale, as returned in `ImageParams`.
	// The bounding box is computed to "frame" the face in accordance with human
	// expectations. It is based on the landmarker results.
	// Note that one or more x and/or y coordinates may not be generated in the
	// `BoundingPoly` (the polygon will be unbounded) if only a partial face
	// appears in the image to be annotated.
	BoundingPoly *BoundingPoly `protobuf:"bytes,1,opt,name=bounding_poly,json=boundingPoly" json:"bounding_poly,omitempty"`
	// The `fd_bounding_poly` bounding polygon is tighter than the
	// `boundingPoly`, and encloses only the skin part of the face. Typically, it
	// is used to eliminate the face from any image analysis that detects the
	// "amount of skin" visible in an image. It is not based on the
	// landmarker results, only on the initial face detection, hence
	// the <code>fd</code> (face detection) prefix.
	FdBoundingPoly *BoundingPoly `protobuf:"bytes,2,opt,name=fd_bounding_poly,json=fdBoundingPoly" json:"fd_bounding_poly,omitempty"`
	// Detected face landmarks.
	Landmarks []*FaceAnnotation_Landmark `protobuf:"bytes,3,rep,name=landmarks" json:"landmarks,omitempty"`
	// Roll angle, which indicates the amount of clockwise/anti-clockwise rotation
	// of the face relative to the image vertical about the axis perpendicular to
	// the face. Range [-180,180].
	RollAngle float32 `protobuf:"fixed32,4,opt,name=roll_angle,json=rollAngle,proto3" json:"roll_angle,omitempty"`
	// Yaw angle, which indicates the leftward/rightward angle that the face is
	// pointing relative to the vertical plane perpendicular to the image. Range
	// [-180,180].
	PanAngle float32 `protobuf:"fixed32,5,opt,name=pan_angle,json=panAngle,proto3" json:"pan_angle,omitempty"`
	// Pitch angle, which indicates the upwards/downwards angle that the face is
	// pointing relative to the image's horizontal plane. Range [-180,180].
	TiltAngle float32 `protobuf:"fixed32,6,opt,name=tilt_angle,json=tiltAngle,proto3" json:"tilt_angle,omitempty"`
	// Detection confidence. Range [0, 1].
	DetectionConfidence float32 `protobuf:"fixed32,7,opt,name=detection_confidence,json=detectionConfidence,proto3" json:"detection_confidence,omitempty"`
	// Face landmarking confidence. Range [0, 1].
	LandmarkingConfidence float32 `protobuf:"fixed32,8,opt,name=landmarking_confidence,json=landmarkingConfidence,proto3" json:"landmarking_confidence,omitempty"`
	// Joy likelihood.
	JoyLikelihood Likelihood `protobuf:"varint,9,opt,name=joy_likelihood,json=joyLikelihood,proto3,enum=google.cloud.vision.v1.Likelihood" json:"joy_likelihood,omitempty"`
	// Sorrow likelihood.
	SorrowLikelihood Likelihood `protobuf:"varint,10,opt,name=sorrow_likelihood,json=sorrowLikelihood,proto3,enum=google.cloud.vision.v1.Likelihood" json:"sorrow_likelihood,omitempty"`
	// Anger likelihood.
	AngerLikelihood Likelihood `protobuf:"varint,11,opt,name=anger_likelihood,json=angerLikelihood,proto3,enum=google.cloud.vision.v1.Likelihood" json:"anger_likelihood,omitempty"`
	// Surprise likelihood.
	SurpriseLikelihood Likelihood `protobuf:"varint,12,opt,name=surprise_likelihood,json=surpriseLikelihood,proto3,enum=google.cloud.vision.v1.Likelihood" json:"surprise_likelihood,omitempty"`
	// Under-exposed likelihood.
	UnderExposedLikelihood Likelihood `protobuf:"varint,13,opt,name=under_exposed_likelihood,json=underExposedLikelihood,proto3,enum=google.cloud.vision.v1.Likelihood" json:"under_exposed_likelihood,omitempty"`
	// Blurred likelihood.
	BlurredLikelihood Likelihood `protobuf:"varint,14,opt,name=blurred_likelihood,json=blurredLikelihood,proto3,enum=google.cloud.vision.v1.Likelihood" json:"blurred_likelihood,omitempty"`
	// Headwear likelihood.
	HeadwearLikelihood Likelihood `protobuf:"varint,15,opt,name=headwear_likelihood,json=headwearLikelihood,proto3,enum=google.cloud.vision.v1.Likelihood" json:"headwear_likelihood,omitempty"`
}

func (m *FaceAnnotation) Reset()                    { *m = FaceAnnotation{} }
func (m *FaceAnnotation) String() string            { return proto.CompactTextString(m) }
func (*FaceAnnotation) ProtoMessage()               {}
func (*FaceAnnotation) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{3} }

func (m *FaceAnnotation) GetBoundingPoly() *BoundingPoly {
	if m != nil {
		return m.BoundingPoly
	}
	return nil
}

func (m *FaceAnnotation) GetFdBoundingPoly() *BoundingPoly {
	if m != nil {
		return m.FdBoundingPoly
	}
	return nil
}

func (m *FaceAnnotation) GetLandmarks() []*FaceAnnotation_Landmark {
	if m != nil {
		return m.Landmarks
	}
	return nil
}

func (m *FaceAnnotation) GetRollAngle() float32 {
	if m != nil {
		return m.RollAngle
	}
	return 0
}

func (m *FaceAnnotation) GetPanAngle() float32 {
	if m != nil {
		return m.PanAngle
	}
	return 0
}

func (m *FaceAnnotation) GetTiltAngle() float32 {
	if m != nil {
		return m.TiltAngle
	}
	return 0
}

func (m *FaceAnnotation) GetDetectionConfidence() float32 {
	if m != nil {
		return m.DetectionConfidence
	}
	return 0
}

func (m *FaceAnnotation) GetLandmarkingConfidence() float32 {
	if m != nil {
		return m.LandmarkingConfidence
	}
	return 0
}

func (m *FaceAnnotation) GetJoyLikelihood() Likelihood {
	if m != nil {
		return m.JoyLikelihood
	}
	return Likelihood_UNKNOWN
}

func (m *FaceAnnotation) GetSorrowLikelihood() Likelihood {
	if m != nil {
		return m.SorrowLikelihood
	}
	return Likelihood_UNKNOWN
}

func (m *FaceAnnotation) GetAngerLikelihood() Likelihood {
	if m != nil {
		return m.AngerLikelihood
	}
	return Likelihood_UNKNOWN
}

func (m *FaceAnnotation) GetSurpriseLikelihood() Likelihood {
	if m != nil {
		return m.SurpriseLikelihood
	}
	return Likelihood_UNKNOWN
}

func (m *FaceAnnotation) GetUnderExposedLikelihood() Likelihood {
	if m != nil {
		return m.UnderExposedLikelihood
	}
	return Likelihood_UNKNOWN
}

func (m *FaceAnnotation) GetBlurredLikelihood() Likelihood {
	if m != nil {
		return m.BlurredLikelihood
	}
	return Likelihood_UNKNOWN
}

func (m *FaceAnnotation) GetHeadwearLikelihood() Likelihood {
	if m != nil {
		return m.HeadwearLikelihood
	}
	return Likelihood_UNKNOWN
}

// A face-specific landmark (for example, a face feature).
// Landmark positions may fall outside the bounds of the image
// if the face is near one or more edges of the image.
// Therefore it is NOT guaranteed that `0 <= x < width` or
// `0 <= y < height`.
type FaceAnnotation_Landmark struct {
	// Face landmark type.
	Type FaceAnnotation_Landmark_Type `protobuf:"varint,3,opt,name=type,proto3,enum=google.cloud.vision.v1.FaceAnnotation_Landmark_Type" json:"type,omitempty"`
	// Face landmark position.
	Position *Position `protobuf:"bytes,4,opt,name=position" json:"position,omitempty"`
}

func (m *FaceAnnotation_Landmark) Reset()         { *m = FaceAnnotation_Landmark{} }
func (m *FaceAnnotation_Landmark) String() string { return proto.CompactTextString(m) }
func (*FaceAnnotation_Landmark) ProtoMessage()    {}
func (*FaceAnnotation_Landmark) Descriptor() ([]byte, []int) {
	return fileDescriptorImageAnnotator, []int{3, 0}
}

func (m *FaceAnnotation_Landmark) GetType() FaceAnnotation_Landmark_Type {
	if m != nil {
		return m.Type
	}
	return FaceAnnotation_Landmark_UNKNOWN_LANDMARK
}

func (m *FaceAnnotation_Landmark) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

// Detected entity location information.
type LocationInfo struct {
	// lat/long location coordinates.
	LatLng *google_type1.LatLng `protobuf:"bytes,1,opt,name=lat_lng,json=latLng" json:"lat_lng,omitempty"`
}

func (m *LocationInfo) Reset()                    { *m = LocationInfo{} }
func (m *LocationInfo) String() string            { return proto.CompactTextString(m) }
func (*LocationInfo) ProtoMessage()               {}
func (*LocationInfo) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{4} }

func (m *LocationInfo) GetLatLng() *google_type1.LatLng {
	if m != nil {
		return m.LatLng
	}
	return nil
}

// A `Property` consists of a user-supplied name/value pair.
type Property struct {
	// Name of the property.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Value of the property.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Property) Reset()                    { *m = Property{} }
func (m *Property) String() string            { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()               {}
func (*Property) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{5} }

func (m *Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Property) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Set of detected entity features.
type EntityAnnotation struct {
	// Opaque entity ID. Some IDs may be available in
	// [Google Knowledge Graph Search API](https://developers.google.com/knowledge-graph/).
	Mid string `protobuf:"bytes,1,opt,name=mid,proto3" json:"mid,omitempty"`
	// The language code for the locale in which the entity textual
	// `description` is expressed.
	Locale string `protobuf:"bytes,2,opt,name=locale,proto3" json:"locale,omitempty"`
	// Entity textual description, expressed in its `locale` language.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Overall score of the result. Range [0, 1].
	Score float32 `protobuf:"fixed32,4,opt,name=score,proto3" json:"score,omitempty"`
	// The accuracy of the entity detection in an image.
	// For example, for an image in which the "Eiffel Tower" entity is detected,
	// this field represents the confidence that there is a tower in the query
	// image. Range [0, 1].
	Confidence float32 `protobuf:"fixed32,5,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// The relevancy of the ICA (Image Content Annotation) label to the
	// image. For example, the relevancy of "tower" is likely higher to an image
	// containing the detected "Eiffel Tower" than to an image containing a
	// detected distant towering building, even though the confidence that
	// there is a tower in each image may be the same. Range [0, 1].
	Topicality float32 `protobuf:"fixed32,6,opt,name=topicality,proto3" json:"topicality,omitempty"`
	// Image region to which this entity belongs. Currently not produced
	// for `LABEL_DETECTION` features. For `TEXT_DETECTION` (OCR), `boundingPoly`s
	// are produced for the entire text detected in an image region, followed by
	// `boundingPoly`s for each word within the detected text.
	BoundingPoly *BoundingPoly `protobuf:"bytes,7,opt,name=bounding_poly,json=boundingPoly" json:"bounding_poly,omitempty"`
	// The location information for the detected entity. Multiple
	// `LocationInfo` elements can be present because one location may
	// indicate the location of the scene in the image, and another location
	// may indicate the location of the place where the image was taken.
	// Location information is usually present for landmarks.
	Locations []*LocationInfo `protobuf:"bytes,8,rep,name=locations" json:"locations,omitempty"`
	// Some entities may have optional user-supplied `Property` (name/value)
	// fields, such a score or string that qualifies the entity.
	Properties []*Property `protobuf:"bytes,9,rep,name=properties" json:"properties,omitempty"`
}

func (m *EntityAnnotation) Reset()                    { *m = EntityAnnotation{} }
func (m *EntityAnnotation) String() string            { return proto.CompactTextString(m) }
func (*EntityAnnotation) ProtoMessage()               {}
func (*EntityAnnotation) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{6} }

func (m *EntityAnnotation) GetMid() string {
	if m != nil {
		return m.Mid
	}
	return ""
}

func (m *EntityAnnotation) GetLocale() string {
	if m != nil {
		return m.Locale
	}
	return ""
}

func (m *EntityAnnotation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *EntityAnnotation) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *EntityAnnotation) GetConfidence() float32 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *EntityAnnotation) GetTopicality() float32 {
	if m != nil {
		return m.Topicality
	}
	return 0
}

func (m *EntityAnnotation) GetBoundingPoly() *BoundingPoly {
	if m != nil {
		return m.BoundingPoly
	}
	return nil
}

func (m *EntityAnnotation) GetLocations() []*LocationInfo {
	if m != nil {
		return m.Locations
	}
	return nil
}

func (m *EntityAnnotation) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

// Set of features pertaining to the image, computed by computer vision
// methods over safe-search verticals (for example, adult, spoof, medical,
// violence).
type SafeSearchAnnotation struct {
	// Represents the adult content likelihood for the image.
	Adult Likelihood `protobuf:"varint,1,opt,name=adult,proto3,enum=google.cloud.vision.v1.Likelihood" json:"adult,omitempty"`
	// Spoof likelihood. The likelihood that an modification
	// was made to the image's canonical version to make it appear
	// funny or offensive.
	Spoof Likelihood `protobuf:"varint,2,opt,name=spoof,proto3,enum=google.cloud.vision.v1.Likelihood" json:"spoof,omitempty"`
	// Likelihood that this is a medical image.
	Medical Likelihood `protobuf:"varint,3,opt,name=medical,proto3,enum=google.cloud.vision.v1.Likelihood" json:"medical,omitempty"`
	// Violence likelihood.
	Violence Likelihood `protobuf:"varint,4,opt,name=violence,proto3,enum=google.cloud.vision.v1.Likelihood" json:"violence,omitempty"`
}

func (m *SafeSearchAnnotation) Reset()         { *m = SafeSearchAnnotation{} }
func (m *SafeSearchAnnotation) String() string { return proto.CompactTextString(m) }
func (*SafeSearchAnnotation) ProtoMessage()    {}
func (*SafeSearchAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptorImageAnnotator, []int{7}
}

func (m *SafeSearchAnnotation) GetAdult() Likelihood {
	if m != nil {
		return m.Adult
	}
	return Likelihood_UNKNOWN
}

func (m *SafeSearchAnnotation) GetSpoof() Likelihood {
	if m != nil {
		return m.Spoof
	}
	return Likelihood_UNKNOWN
}

func (m *SafeSearchAnnotation) GetMedical() Likelihood {
	if m != nil {
		return m.Medical
	}
	return Likelihood_UNKNOWN
}

func (m *SafeSearchAnnotation) GetViolence() Likelihood {
	if m != nil {
		return m.Violence
	}
	return Likelihood_UNKNOWN
}

// Rectangle determined by min and max `LatLng` pairs.
type LatLongRect struct {
	// Min lat/long pair.
	MinLatLng *google_type1.LatLng `protobuf:"bytes,1,opt,name=min_lat_lng,json=minLatLng" json:"min_lat_lng,omitempty"`
	// Max lat/long pair.
	MaxLatLng *google_type1.LatLng `protobuf:"bytes,2,opt,name=max_lat_lng,json=maxLatLng" json:"max_lat_lng,omitempty"`
}

func (m *LatLongRect) Reset()                    { *m = LatLongRect{} }
func (m *LatLongRect) String() string            { return proto.CompactTextString(m) }
func (*LatLongRect) ProtoMessage()               {}
func (*LatLongRect) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{8} }

func (m *LatLongRect) GetMinLatLng() *google_type1.LatLng {
	if m != nil {
		return m.MinLatLng
	}
	return nil
}

func (m *LatLongRect) GetMaxLatLng() *google_type1.LatLng {
	if m != nil {
		return m.MaxLatLng
	}
	return nil
}

// Color information consists of RGB channels, score, and the fraction of
// the image that the color occupies in the image.
type ColorInfo struct {
	// RGB components of the color.
	Color *google_type.Color `protobuf:"bytes,1,opt,name=color" json:"color,omitempty"`
	// Image-specific score for this color. Value in range [0, 1].
	Score float32 `protobuf:"fixed32,2,opt,name=score,proto3" json:"score,omitempty"`
	// The fraction of pixels the color occupies in the image.
	// Value in range [0, 1].
	PixelFraction float32 `protobuf:"fixed32,3,opt,name=pixel_fraction,json=pixelFraction,proto3" json:"pixel_fraction,omitempty"`
}

func (m *ColorInfo) Reset()                    { *m = ColorInfo{} }
func (m *ColorInfo) String() string            { return proto.CompactTextString(m) }
func (*ColorInfo) ProtoMessage()               {}
func (*ColorInfo) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{9} }

func (m *ColorInfo) GetColor() *google_type.Color {
	if m != nil {
		return m.Color
	}
	return nil
}

func (m *ColorInfo) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ColorInfo) GetPixelFraction() float32 {
	if m != nil {
		return m.PixelFraction
	}
	return 0
}

// Set of dominant colors and their corresponding scores.
type DominantColorsAnnotation struct {
	// RGB color values with their score and pixel fraction.
	Colors []*ColorInfo `protobuf:"bytes,1,rep,name=colors" json:"colors,omitempty"`
}

func (m *DominantColorsAnnotation) Reset()         { *m = DominantColorsAnnotation{} }
func (m *DominantColorsAnnotation) String() string { return proto.CompactTextString(m) }
func (*DominantColorsAnnotation) ProtoMessage()    {}
func (*DominantColorsAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptorImageAnnotator, []int{10}
}

func (m *DominantColorsAnnotation) GetColors() []*ColorInfo {
	if m != nil {
		return m.Colors
	}
	return nil
}

// Stores image properties, such as dominant colors.
type ImageProperties struct {
	// If present, dominant colors completed successfully.
	DominantColors *DominantColorsAnnotation `protobuf:"bytes,1,opt,name=dominant_colors,json=dominantColors" json:"dominant_colors,omitempty"`
}

func (m *ImageProperties) Reset()                    { *m = ImageProperties{} }
func (m *ImageProperties) String() string            { return proto.CompactTextString(m) }
func (*ImageProperties) ProtoMessage()               {}
func (*ImageProperties) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{11} }

func (m *ImageProperties) GetDominantColors() *DominantColorsAnnotation {
	if m != nil {
		return m.DominantColors
	}
	return nil
}

// Single crop hint that is used to generate a new crop when serving an image.
type CropHint struct {
	// The bounding polygon for the crop region. The coordinates of the bounding
	// box are in the original image's scale, as returned in `ImageParams`.
	BoundingPoly *BoundingPoly `protobuf:"bytes,1,opt,name=bounding_poly,json=boundingPoly" json:"bounding_poly,omitempty"`
	// Confidence of this being a salient region.  Range [0, 1].
	Confidence float32 `protobuf:"fixed32,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// Fraction of importance of this salient region with respect to the original
	// image.
	ImportanceFraction float32 `protobuf:"fixed32,3,opt,name=importance_fraction,json=importanceFraction,proto3" json:"importance_fraction,omitempty"`
}

func (m *CropHint) Reset()                    { *m = CropHint{} }
func (m *CropHint) String() string            { return proto.CompactTextString(m) }
func (*CropHint) ProtoMessage()               {}
func (*CropHint) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{12} }

func (m *CropHint) GetBoundingPoly() *BoundingPoly {
	if m != nil {
		return m.BoundingPoly
	}
	return nil
}

func (m *CropHint) GetConfidence() float32 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *CropHint) GetImportanceFraction() float32 {
	if m != nil {
		return m.ImportanceFraction
	}
	return 0
}

// Set of crop hints that are used to generate new crops when serving images.
type CropHintsAnnotation struct {
	CropHints []*CropHint `protobuf:"bytes,1,rep,name=crop_hints,json=cropHints" json:"crop_hints,omitempty"`
}

func (m *CropHintsAnnotation) Reset()         { *m = CropHintsAnnotation{} }
func (m *CropHintsAnnotation) String() string { return proto.CompactTextString(m) }
func (*CropHintsAnnotation) ProtoMessage()    {}
func (*CropHintsAnnotation) Descriptor() ([]byte, []int) {
	return fileDescriptorImageAnnotator, []int{13}
}

func (m *CropHintsAnnotation) GetCropHints() []*CropHint {
	if m != nil {
		return m.CropHints
	}
	return nil
}

// Parameters for crop hints annotation request.
type CropHintsParams struct {
	// Aspect ratios in floats, representing the ratio of the width to the height
	// of the image. For example, if the desired aspect ratio is 4/3, the
	// corresponding float value should be 1.33333.  If not specified, the
	// best possible crop is returned. The number of provided aspect ratios is
	// limited to a maximum of 16; any aspect ratios provided after the 16th are
	// ignored.
	AspectRatios []float32 `protobuf:"fixed32,1,rep,packed,name=aspect_ratios,json=aspectRatios" json:"aspect_ratios,omitempty"`
}

func (m *CropHintsParams) Reset()                    { *m = CropHintsParams{} }
func (m *CropHintsParams) String() string            { return proto.CompactTextString(m) }
func (*CropHintsParams) ProtoMessage()               {}
func (*CropHintsParams) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{14} }

func (m *CropHintsParams) GetAspectRatios() []float32 {
	if m != nil {
		return m.AspectRatios
	}
	return nil
}

// Image context and/or feature-specific parameters.
type ImageContext struct {
	// lat/long rectangle that specifies the location of the image.
	LatLongRect *LatLongRect `protobuf:"bytes,1,opt,name=lat_long_rect,json=latLongRect" json:"lat_long_rect,omitempty"`
	// List of languages to use for TEXT_DETECTION. In most cases, an empty value
	// yields the best results since it enables automatic language detection. For
	// languages based on the Latin alphabet, setting `language_hints` is not
	// needed. In rare cases, when the language of the text in the image is known,
	// setting a hint will help get better results (although it will be a
	// significant hindrance if the hint is wrong). Text detection returns an
	// error if one or more of the specified languages is not one of the
	// [supported languages](/vision/docs/languages).
	LanguageHints []string `protobuf:"bytes,2,rep,name=language_hints,json=languageHints" json:"language_hints,omitempty"`
	// Parameters for crop hints annotation request.
	CropHintsParams *CropHintsParams `protobuf:"bytes,4,opt,name=crop_hints_params,json=cropHintsParams" json:"crop_hints_params,omitempty"`
}

func (m *ImageContext) Reset()                    { *m = ImageContext{} }
func (m *ImageContext) String() string            { return proto.CompactTextString(m) }
func (*ImageContext) ProtoMessage()               {}
func (*ImageContext) Descriptor() ([]byte, []int) { return fileDescriptorImageAnnotator, []int{15} }

func (m *ImageContext) GetLatLongRect() *LatLongRect {
	if m != nil {
		return m.LatLongRect
	}
	return nil
}

func (m *ImageContext) GetLanguageHints() []string {
	if m != nil {
		return m.LanguageHints
	}
	return nil
}

func (m *ImageContext) GetCropHintsParams() *CropHintsParams {
	if m != nil {
		return m.CropHintsParams
	}
	return nil
}

// Request for performing Google Cloud Vision API tasks over a user-provided
// image, with user-requested features.
type AnnotateImageRequest struct {
	// The image to be processed.
	Image *Image `protobuf:"bytes,1,opt,name=image" json:"image,omitempty"`
	// Requested features.
	Features []*Feature `protobuf:"bytes,2,rep,name=features" json:"features,omitempty"`
	// Additional context that may accompany the image.
	ImageContext *ImageContext `protobuf:"bytes,3,opt,name=image_context,json=imageContext" json:"image_context,omitempty"`
}

func (m *AnnotateImageRequest) Reset()         { *m = AnnotateImageRequest{} }
func (m *AnnotateImageRequest) String() string { return proto.CompactTextString(m) }
func (*AnnotateImageRequest) ProtoMessage()    {}
func (*AnnotateImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorImageAnnotator, []int{16}
}

func (m *AnnotateImageRequest) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *AnnotateImageRequest) GetFeatures() []*Feature {
	if m != nil {
		return m.Features
	}
	return nil
}

func (m *AnnotateImageRequest) GetImageContext() *ImageContext {
	if m != nil {
		return m.ImageContext
	}
	return nil
}

// Response to an image annotation request.
type AnnotateImageResponse struct {
	// If present, face detection has completed successfully.
	FaceAnnotations []*FaceAnnotation `protobuf:"bytes,1,rep,name=face_annotations,json=faceAnnotations" json:"face_annotations,omitempty"`
	// If present, landmark detection has completed successfully.
	LandmarkAnnotations []*EntityAnnotation `protobuf:"bytes,2,rep,name=landmark_annotations,json=landmarkAnnotations" json:"landmark_annotations,omitempty"`
	// If present, logo detection has completed successfully.
	LogoAnnotations []*EntityAnnotation `protobuf:"bytes,3,rep,name=logo_annotations,json=logoAnnotations" json:"logo_annotations,omitempty"`
	// If present, label detection has completed successfully.
	LabelAnnotations []*EntityAnnotation `protobuf:"bytes,4,rep,name=label_annotations,json=labelAnnotations" json:"label_annotations,omitempty"`
	// If present, text (OCR) detection or document (OCR) text detection has
	// completed successfully.
	TextAnnotations []*EntityAnnotation `protobuf:"bytes,5,rep,name=text_annotations,json=textAnnotations" json:"text_annotations,omitempty"`
	// If present, text (OCR) detection or document (OCR) text detection has
	// completed successfully.
	// This annotation provides the structural hierarchy for the OCR detected
	// text.
	FullTextAnnotation *TextAnnotation `protobuf:"bytes,12,opt,name=full_text_annotation,json=fullTextAnnotation" json:"full_text_annotation,omitempty"`
	// If present, safe-search annotation has completed successfully.
	SafeSearchAnnotation *SafeSearchAnnotation `protobuf:"bytes,6,opt,name=safe_search_annotation,json=safeSearchAnnotation" json:"safe_search_annotation,omitempty"`
	// If present, image properties were extracted successfully.
	ImagePropertiesAnnotation *ImageProperties `protobuf:"bytes,8,opt,name=image_properties_annotation,json=imagePropertiesAnnotation" json:"image_properties_annotation,omitempty"`
	// If present, crop hints have completed successfully.
	CropHintsAnnotation *CropHintsAnnotation `protobuf:"bytes,11,opt,name=crop_hints_annotation,json=cropHintsAnnotation" json:"crop_hints_annotation,omitempty"`
	// If present, web detection has completed successfully.
	WebDetection *WebDetection `protobuf:"bytes,13,opt,name=web_detection,json=webDetection" json:"web_detection,omitempty"`
	// If set, represents the error message for the operation.
	// Note that filled-in image annotations are guaranteed to be
	// correct, even when `error` is set.
	Error *google_rpc.Status `protobuf:"bytes,9,opt,name=error" json:"error,omitempty"`
}

func (m *AnnotateImageResponse) Reset()         { *m = AnnotateImageResponse{} }
func (m *AnnotateImageResponse) String() string { return proto.CompactTextString(m) }
func (*AnnotateImageResponse) ProtoMessage()    {}
func (*AnnotateImageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorImageAnnotator, []int{17}
}

func (m *AnnotateImageResponse) GetFaceAnnotations() []*FaceAnnotation {
	if m != nil {
		return m.FaceAnnotations
	}
	return nil
}

func (m *AnnotateImageResponse) GetLandmarkAnnotations() []*EntityAnnotation {
	if m != nil {
		return m.LandmarkAnnotations
	}
	return nil
}

func (m *AnnotateImageResponse) GetLogoAnnotations() []*EntityAnnotation {
	if m != nil {
		return m.LogoAnnotations
	}
	return nil
}

func (m *AnnotateImageResponse) GetLabelAnnotations() []*EntityAnnotation {
	if m != nil {
		return m.LabelAnnotations
	}
	return nil
}

func (m *AnnotateImageResponse) GetTextAnnotations() []*EntityAnnotation {
	if m != nil {
		return m.TextAnnotations
	}
	return nil
}

func (m *AnnotateImageResponse) GetFullTextAnnotation() *TextAnnotation {
	if m != nil {
		return m.FullTextAnnotation
	}
	return nil
}

func (m *AnnotateImageResponse) GetSafeSearchAnnotation() *SafeSearchAnnotation {
	if m != nil {
		return m.SafeSearchAnnotation
	}
	return nil
}

func (m *AnnotateImageResponse) GetImagePropertiesAnnotation() *ImageProperties {
	if m != nil {
		return m.ImagePropertiesAnnotation
	}
	return nil
}

func (m *AnnotateImageResponse) GetCropHintsAnnotation() *CropHintsAnnotation {
	if m != nil {
		return m.CropHintsAnnotation
	}
	return nil
}

func (m *AnnotateImageResponse) GetWebDetection() *WebDetection {
	if m != nil {
		return m.WebDetection
	}
	return nil
}

func (m *AnnotateImageResponse) GetError() *google_rpc.Status {
	if m != nil {
		return m.Error
	}
	return nil
}

// Multiple image annotation requests are batched into a single service call.
type BatchAnnotateImagesRequest struct {
	// Individual image annotation requests for this batch.
	Requests []*AnnotateImageRequest `protobuf:"bytes,1,rep,name=requests" json:"requests,omitempty"`
}

func (m *BatchAnnotateImagesRequest) Reset()         { *m = BatchAnnotateImagesRequest{} }
func (m *BatchAnnotateImagesRequest) String() string { return proto.CompactTextString(m) }
func (*BatchAnnotateImagesRequest) ProtoMessage()    {}
func (*BatchAnnotateImagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorImageAnnotator, []int{18}
}

func (m *BatchAnnotateImagesRequest) GetRequests() []*AnnotateImageRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

// Response to a batch image annotation request.
type BatchAnnotateImagesResponse struct {
	// Individual responses to image annotation requests within the batch.
	Responses []*AnnotateImageResponse `protobuf:"bytes,1,rep,name=responses" json:"responses,omitempty"`
}

func (m *BatchAnnotateImagesResponse) Reset()         { *m = BatchAnnotateImagesResponse{} }
func (m *BatchAnnotateImagesResponse) String() string { return proto.CompactTextString(m) }
func (*BatchAnnotateImagesResponse) ProtoMessage()    {}
func (*BatchAnnotateImagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorImageAnnotator, []int{19}
}

func (m *BatchAnnotateImagesResponse) GetResponses() []*AnnotateImageResponse {
	if m != nil {
		return m.Responses
	}
	return nil
}

func init() {
	proto.RegisterType((*Feature)(nil), "google.cloud.vision.v1.Feature")
	proto.RegisterType((*ImageSource)(nil), "google.cloud.vision.v1.ImageSource")
	proto.RegisterType((*Image)(nil), "google.cloud.vision.v1.Image")
	proto.RegisterType((*FaceAnnotation)(nil), "google.cloud.vision.v1.FaceAnnotation")
	proto.RegisterType((*FaceAnnotation_Landmark)(nil), "google.cloud.vision.v1.FaceAnnotation.Landmark")
	proto.RegisterType((*LocationInfo)(nil), "google.cloud.vision.v1.LocationInfo")
	proto.RegisterType((*Property)(nil), "google.cloud.vision.v1.Property")
	proto.RegisterType((*EntityAnnotation)(nil), "google.cloud.vision.v1.EntityAnnotation")
	proto.RegisterType((*SafeSearchAnnotation)(nil), "google.cloud.vision.v1.SafeSearchAnnotation")
	proto.RegisterType((*LatLongRect)(nil), "google.cloud.vision.v1.LatLongRect")
	proto.RegisterType((*ColorInfo)(nil), "google.cloud.vision.v1.ColorInfo")
	proto.RegisterType((*DominantColorsAnnotation)(nil), "google.cloud.vision.v1.DominantColorsAnnotation")
	proto.RegisterType((*ImageProperties)(nil), "google.cloud.vision.v1.ImageProperties")
	proto.RegisterType((*CropHint)(nil), "google.cloud.vision.v1.CropHint")
	proto.RegisterType((*CropHintsAnnotation)(nil), "google.cloud.vision.v1.CropHintsAnnotation")
	proto.RegisterType((*CropHintsParams)(nil), "google.cloud.vision.v1.CropHintsParams")
	proto.RegisterType((*ImageContext)(nil), "google.cloud.vision.v1.ImageContext")
	proto.RegisterType((*AnnotateImageRequest)(nil), "google.cloud.vision.v1.AnnotateImageRequest")
	proto.RegisterType((*AnnotateImageResponse)(nil), "google.cloud.vision.v1.AnnotateImageResponse")
	proto.RegisterType((*BatchAnnotateImagesRequest)(nil), "google.cloud.vision.v1.BatchAnnotateImagesRequest")
	proto.RegisterType((*BatchAnnotateImagesResponse)(nil), "google.cloud.vision.v1.BatchAnnotateImagesResponse")
	proto.RegisterEnum("google.cloud.vision.v1.Likelihood", Likelihood_name, Likelihood_value)
	proto.RegisterEnum("google.cloud.vision.v1.Feature_Type", Feature_Type_name, Feature_Type_value)
	proto.RegisterEnum("google.cloud.vision.v1.FaceAnnotation_Landmark_Type", FaceAnnotation_Landmark_Type_name, FaceAnnotation_Landmark_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ImageAnnotator service

type ImageAnnotatorClient interface {
	// Run image detection and annotation for a batch of images.
	BatchAnnotateImages(ctx context.Context, in *BatchAnnotateImagesRequest, opts ...grpc.CallOption) (*BatchAnnotateImagesResponse, error)
}

type imageAnnotatorClient struct {
	cc *grpc.ClientConn
}

func NewImageAnnotatorClient(cc *grpc.ClientConn) ImageAnnotatorClient {
	return &imageAnnotatorClient{cc}
}

func (c *imageAnnotatorClient) BatchAnnotateImages(ctx context.Context, in *BatchAnnotateImagesRequest, opts ...grpc.CallOption) (*BatchAnnotateImagesResponse, error) {
	out := new(BatchAnnotateImagesResponse)
	err := grpc.Invoke(ctx, "/google.cloud.vision.v1.ImageAnnotator/BatchAnnotateImages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ImageAnnotator service

type ImageAnnotatorServer interface {
	// Run image detection and annotation for a batch of images.
	BatchAnnotateImages(context.Context, *BatchAnnotateImagesRequest) (*BatchAnnotateImagesResponse, error)
}

func RegisterImageAnnotatorServer(s *grpc.Server, srv ImageAnnotatorServer) {
	s.RegisterService(&_ImageAnnotator_serviceDesc, srv)
}

func _ImageAnnotator_BatchAnnotateImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchAnnotateImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageAnnotatorServer).BatchAnnotateImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.cloud.vision.v1.ImageAnnotator/BatchAnnotateImages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageAnnotatorServer).BatchAnnotateImages(ctx, req.(*BatchAnnotateImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImageAnnotator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.vision.v1.ImageAnnotator",
	HandlerType: (*ImageAnnotatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BatchAnnotateImages",
			Handler:    _ImageAnnotator_BatchAnnotateImages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/vision/v1/image_annotator.proto",
}

func (m *Feature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Feature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Type))
	}
	if m.MaxResults != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.MaxResults))
	}
	return i, nil
}

func (m *ImageSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GcsImageUri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(len(m.GcsImageUri)))
		i += copy(dAtA[i:], m.GcsImageUri)
	}
	if len(m.ImageUri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(len(m.ImageUri)))
		i += copy(dAtA[i:], m.ImageUri)
	}
	return i, nil
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Source != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Source.Size()))
		n1, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *FaceAnnotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FaceAnnotation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BoundingPoly != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.BoundingPoly.Size()))
		n2, err := m.BoundingPoly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.FdBoundingPoly != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.FdBoundingPoly.Size()))
		n3, err := m.FdBoundingPoly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Landmarks) > 0 {
		for _, msg := range m.Landmarks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RollAngle != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.RollAngle))))
	}
	if m.PanAngle != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.PanAngle))))
	}
	if m.TiltAngle != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.TiltAngle))))
	}
	if m.DetectionConfidence != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.DetectionConfidence))))
	}
	if m.LandmarkingConfidence != 0 {
		dAtA[i] = 0x45
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.LandmarkingConfidence))))
	}
	if m.JoyLikelihood != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.JoyLikelihood))
	}
	if m.SorrowLikelihood != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.SorrowLikelihood))
	}
	if m.AngerLikelihood != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.AngerLikelihood))
	}
	if m.SurpriseLikelihood != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.SurpriseLikelihood))
	}
	if m.UnderExposedLikelihood != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.UnderExposedLikelihood))
	}
	if m.BlurredLikelihood != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.BlurredLikelihood))
	}
	if m.HeadwearLikelihood != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.HeadwearLikelihood))
	}
	return i, nil
}

func (m *FaceAnnotation_Landmark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FaceAnnotation_Landmark) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Type))
	}
	if m.Position != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Position.Size()))
		n4, err := m.Position.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *LocationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LatLng != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.LatLng.Size()))
		n5, err := m.LatLng.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Property) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Property) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *EntityAnnotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityAnnotation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(len(m.Mid)))
		i += copy(dAtA[i:], m.Mid)
	}
	if len(m.Locale) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(len(m.Locale)))
		i += copy(dAtA[i:], m.Locale)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Score != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.Score))))
	}
	if m.Confidence != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.Confidence))))
	}
	if m.Topicality != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.Topicality))))
	}
	if m.BoundingPoly != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.BoundingPoly.Size()))
		n6, err := m.BoundingPoly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Locations) > 0 {
		for _, msg := range m.Locations {
			dAtA[i] = 0x42
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Properties) > 0 {
		for _, msg := range m.Properties {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SafeSearchAnnotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SafeSearchAnnotation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Adult != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Adult))
	}
	if m.Spoof != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Spoof))
	}
	if m.Medical != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Medical))
	}
	if m.Violence != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Violence))
	}
	return i, nil
}

func (m *LatLongRect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LatLongRect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinLatLng != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.MinLatLng.Size()))
		n7, err := m.MinLatLng.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.MaxLatLng != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.MaxLatLng.Size()))
		n8, err := m.MaxLatLng.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *ColorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColorInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Color != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Color.Size()))
		n9, err := m.Color.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Score != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.Score))))
	}
	if m.PixelFraction != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.PixelFraction))))
	}
	return i, nil
}

func (m *DominantColorsAnnotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DominantColorsAnnotation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Colors) > 0 {
		for _, msg := range m.Colors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ImageProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DominantColors != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.DominantColors.Size()))
		n10, err := m.DominantColors.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *CropHint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CropHint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BoundingPoly != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.BoundingPoly.Size()))
		n11, err := m.BoundingPoly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Confidence != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.Confidence))))
	}
	if m.ImportanceFraction != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32ImageAnnotator(dAtA, i, uint32(math.Float32bits(float32(m.ImportanceFraction))))
	}
	return i, nil
}

func (m *CropHintsAnnotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CropHintsAnnotation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CropHints) > 0 {
		for _, msg := range m.CropHints {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CropHintsParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CropHintsParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AspectRatios) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(len(m.AspectRatios)*4))
		for _, num := range m.AspectRatios {
			f12 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f12)
			i++
			dAtA[i] = uint8(f12 >> 8)
			i++
			dAtA[i] = uint8(f12 >> 16)
			i++
			dAtA[i] = uint8(f12 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *ImageContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LatLongRect != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.LatLongRect.Size()))
		n13, err := m.LatLongRect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.LanguageHints) > 0 {
		for _, s := range m.LanguageHints {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.CropHintsParams != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.CropHintsParams.Size()))
		n14, err := m.CropHintsParams.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *AnnotateImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnnotateImageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Image.Size()))
		n15, err := m.Image.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Features) > 0 {
		for _, msg := range m.Features {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ImageContext != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.ImageContext.Size()))
		n16, err := m.ImageContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *AnnotateImageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnnotateImageResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FaceAnnotations) > 0 {
		for _, msg := range m.FaceAnnotations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LandmarkAnnotations) > 0 {
		for _, msg := range m.LandmarkAnnotations {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LogoAnnotations) > 0 {
		for _, msg := range m.LogoAnnotations {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LabelAnnotations) > 0 {
		for _, msg := range m.LabelAnnotations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TextAnnotations) > 0 {
		for _, msg := range m.TextAnnotations {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SafeSearchAnnotation != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.SafeSearchAnnotation.Size()))
		n17, err := m.SafeSearchAnnotation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.ImagePropertiesAnnotation != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.ImagePropertiesAnnotation.Size()))
		n18, err := m.ImagePropertiesAnnotation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Error != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.Error.Size()))
		n19, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.CropHintsAnnotation != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.CropHintsAnnotation.Size()))
		n20, err := m.CropHintsAnnotation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.FullTextAnnotation != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.FullTextAnnotation.Size()))
		n21, err := m.FullTextAnnotation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.WebDetection != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintImageAnnotator(dAtA, i, uint64(m.WebDetection.Size()))
		n22, err := m.WebDetection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *BatchAnnotateImagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchAnnotateImagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BatchAnnotateImagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchAnnotateImagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Responses) > 0 {
		for _, msg := range m.Responses {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImageAnnotator(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64ImageAnnotator(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32ImageAnnotator(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintImageAnnotator(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Feature) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovImageAnnotator(uint64(m.Type))
	}
	if m.MaxResults != 0 {
		n += 1 + sovImageAnnotator(uint64(m.MaxResults))
	}
	return n
}

func (m *ImageSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.GcsImageUri)
	if l > 0 {
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	l = len(m.ImageUri)
	if l > 0 {
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *Image) Size() (n int) {
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *FaceAnnotation) Size() (n int) {
	var l int
	_ = l
	if m.BoundingPoly != nil {
		l = m.BoundingPoly.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.FdBoundingPoly != nil {
		l = m.FdBoundingPoly.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if len(m.Landmarks) > 0 {
		for _, e := range m.Landmarks {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	if m.RollAngle != 0 {
		n += 5
	}
	if m.PanAngle != 0 {
		n += 5
	}
	if m.TiltAngle != 0 {
		n += 5
	}
	if m.DetectionConfidence != 0 {
		n += 5
	}
	if m.LandmarkingConfidence != 0 {
		n += 5
	}
	if m.JoyLikelihood != 0 {
		n += 1 + sovImageAnnotator(uint64(m.JoyLikelihood))
	}
	if m.SorrowLikelihood != 0 {
		n += 1 + sovImageAnnotator(uint64(m.SorrowLikelihood))
	}
	if m.AngerLikelihood != 0 {
		n += 1 + sovImageAnnotator(uint64(m.AngerLikelihood))
	}
	if m.SurpriseLikelihood != 0 {
		n += 1 + sovImageAnnotator(uint64(m.SurpriseLikelihood))
	}
	if m.UnderExposedLikelihood != 0 {
		n += 1 + sovImageAnnotator(uint64(m.UnderExposedLikelihood))
	}
	if m.BlurredLikelihood != 0 {
		n += 1 + sovImageAnnotator(uint64(m.BlurredLikelihood))
	}
	if m.HeadwearLikelihood != 0 {
		n += 1 + sovImageAnnotator(uint64(m.HeadwearLikelihood))
	}
	return n
}

func (m *FaceAnnotation_Landmark) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovImageAnnotator(uint64(m.Type))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *LocationInfo) Size() (n int) {
	var l int
	_ = l
	if m.LatLng != nil {
		l = m.LatLng.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *Property) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *EntityAnnotation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mid)
	if l > 0 {
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	l = len(m.Locale)
	if l > 0 {
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.Score != 0 {
		n += 5
	}
	if m.Confidence != 0 {
		n += 5
	}
	if m.Topicality != 0 {
		n += 5
	}
	if m.BoundingPoly != nil {
		l = m.BoundingPoly.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	return n
}

func (m *SafeSearchAnnotation) Size() (n int) {
	var l int
	_ = l
	if m.Adult != 0 {
		n += 1 + sovImageAnnotator(uint64(m.Adult))
	}
	if m.Spoof != 0 {
		n += 1 + sovImageAnnotator(uint64(m.Spoof))
	}
	if m.Medical != 0 {
		n += 1 + sovImageAnnotator(uint64(m.Medical))
	}
	if m.Violence != 0 {
		n += 1 + sovImageAnnotator(uint64(m.Violence))
	}
	return n
}

func (m *LatLongRect) Size() (n int) {
	var l int
	_ = l
	if m.MinLatLng != nil {
		l = m.MinLatLng.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.MaxLatLng != nil {
		l = m.MaxLatLng.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *ColorInfo) Size() (n int) {
	var l int
	_ = l
	if m.Color != nil {
		l = m.Color.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.Score != 0 {
		n += 5
	}
	if m.PixelFraction != 0 {
		n += 5
	}
	return n
}

func (m *DominantColorsAnnotation) Size() (n int) {
	var l int
	_ = l
	if len(m.Colors) > 0 {
		for _, e := range m.Colors {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	return n
}

func (m *ImageProperties) Size() (n int) {
	var l int
	_ = l
	if m.DominantColors != nil {
		l = m.DominantColors.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *CropHint) Size() (n int) {
	var l int
	_ = l
	if m.BoundingPoly != nil {
		l = m.BoundingPoly.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.Confidence != 0 {
		n += 5
	}
	if m.ImportanceFraction != 0 {
		n += 5
	}
	return n
}

func (m *CropHintsAnnotation) Size() (n int) {
	var l int
	_ = l
	if len(m.CropHints) > 0 {
		for _, e := range m.CropHints {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	return n
}

func (m *CropHintsParams) Size() (n int) {
	var l int
	_ = l
	if len(m.AspectRatios) > 0 {
		n += 1 + sovImageAnnotator(uint64(len(m.AspectRatios)*4)) + len(m.AspectRatios)*4
	}
	return n
}

func (m *ImageContext) Size() (n int) {
	var l int
	_ = l
	if m.LatLongRect != nil {
		l = m.LatLongRect.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if len(m.LanguageHints) > 0 {
		for _, s := range m.LanguageHints {
			l = len(s)
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	if m.CropHintsParams != nil {
		l = m.CropHintsParams.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *AnnotateImageRequest) Size() (n int) {
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if len(m.Features) > 0 {
		for _, e := range m.Features {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	if m.ImageContext != nil {
		l = m.ImageContext.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *AnnotateImageResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.FaceAnnotations) > 0 {
		for _, e := range m.FaceAnnotations {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	if len(m.LandmarkAnnotations) > 0 {
		for _, e := range m.LandmarkAnnotations {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	if len(m.LogoAnnotations) > 0 {
		for _, e := range m.LogoAnnotations {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	if len(m.LabelAnnotations) > 0 {
		for _, e := range m.LabelAnnotations {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	if len(m.TextAnnotations) > 0 {
		for _, e := range m.TextAnnotations {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	if m.SafeSearchAnnotation != nil {
		l = m.SafeSearchAnnotation.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.ImagePropertiesAnnotation != nil {
		l = m.ImagePropertiesAnnotation.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.CropHintsAnnotation != nil {
		l = m.CropHintsAnnotation.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.FullTextAnnotation != nil {
		l = m.FullTextAnnotation.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	if m.WebDetection != nil {
		l = m.WebDetection.Size()
		n += 1 + l + sovImageAnnotator(uint64(l))
	}
	return n
}

func (m *BatchAnnotateImagesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	return n
}

func (m *BatchAnnotateImagesResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovImageAnnotator(uint64(l))
		}
	}
	return n
}

func sovImageAnnotator(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImageAnnotator(x uint64) (n int) {
	return sovImageAnnotator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Feature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Feature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Feature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Feature_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			m.MaxResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResults |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcsImageUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GcsImageUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &ImageSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FaceAnnotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FaceAnnotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FaceAnnotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundingPoly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoundingPoly == nil {
				m.BoundingPoly = &BoundingPoly{}
			}
			if err := m.BoundingPoly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FdBoundingPoly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FdBoundingPoly == nil {
				m.FdBoundingPoly = &BoundingPoly{}
			}
			if err := m.FdBoundingPoly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Landmarks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Landmarks = append(m.Landmarks, &FaceAnnotation_Landmark{})
			if err := m.Landmarks[len(m.Landmarks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollAngle", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.RollAngle = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PanAngle", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.PanAngle = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TiltAngle", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.TiltAngle = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionConfidence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DetectionConfidence = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LandmarkingConfidence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.LandmarkingConfidence = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoyLikelihood", wireType)
			}
			m.JoyLikelihood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoyLikelihood |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SorrowLikelihood", wireType)
			}
			m.SorrowLikelihood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SorrowLikelihood |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AngerLikelihood", wireType)
			}
			m.AngerLikelihood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AngerLikelihood |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SurpriseLikelihood", wireType)
			}
			m.SurpriseLikelihood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SurpriseLikelihood |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderExposedLikelihood", wireType)
			}
			m.UnderExposedLikelihood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnderExposedLikelihood |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlurredLikelihood", wireType)
			}
			m.BlurredLikelihood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlurredLikelihood |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadwearLikelihood", wireType)
			}
			m.HeadwearLikelihood = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadwearLikelihood |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FaceAnnotation_Landmark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Landmark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Landmark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (FaceAnnotation_Landmark_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatLng", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatLng == nil {
				m.LatLng = &google_type1.LatLng{}
			}
			if err := m.LatLng.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Property) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Property: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Property: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityAnnotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityAnnotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityAnnotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locale = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Score = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confidence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Confidence = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topicality", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Topicality = float32(math.Float32frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundingPoly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoundingPoly == nil {
				m.BoundingPoly = &BoundingPoly{}
			}
			if err := m.BoundingPoly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, &LocationInfo{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &Property{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SafeSearchAnnotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SafeSearchAnnotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SafeSearchAnnotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adult", wireType)
			}
			m.Adult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Adult |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spoof", wireType)
			}
			m.Spoof = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Spoof |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medical", wireType)
			}
			m.Medical = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Medical |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Violence", wireType)
			}
			m.Violence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Violence |= (Likelihood(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LatLongRect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LatLongRect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LatLongRect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLatLng", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinLatLng == nil {
				m.MinLatLng = &google_type1.LatLng{}
			}
			if err := m.MinLatLng.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLatLng", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxLatLng == nil {
				m.MaxLatLng = &google_type1.LatLng{}
			}
			if err := m.MaxLatLng.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Color == nil {
				m.Color = &google_type.Color{}
			}
			if err := m.Color.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Score = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PixelFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.PixelFraction = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DominantColorsAnnotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DominantColorsAnnotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DominantColorsAnnotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Colors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Colors = append(m.Colors, &ColorInfo{})
			if err := m.Colors[len(m.Colors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DominantColors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DominantColors == nil {
				m.DominantColors = &DominantColorsAnnotation{}
			}
			if err := m.DominantColors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CropHint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CropHint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CropHint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundingPoly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoundingPoly == nil {
				m.BoundingPoly = &BoundingPoly{}
			}
			if err := m.BoundingPoly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confidence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Confidence = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportanceFraction", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.ImportanceFraction = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CropHintsAnnotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CropHintsAnnotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CropHintsAnnotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CropHints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CropHints = append(m.CropHints, &CropHint{})
			if err := m.CropHints[len(m.CropHints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CropHintsParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CropHintsParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CropHintsParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.AspectRatios = append(m.AspectRatios, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImageAnnotator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImageAnnotator
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.AspectRatios = append(m.AspectRatios, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AspectRatios", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatLongRect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatLongRect == nil {
				m.LatLongRect = &LatLongRect{}
			}
			if err := m.LatLongRect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LanguageHints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LanguageHints = append(m.LanguageHints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CropHintsParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CropHintsParams == nil {
				m.CropHintsParams = &CropHintsParams{}
			}
			if err := m.CropHintsParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnotateImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotateImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotateImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &Image{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, &Feature{})
			if err := m.Features[len(m.Features)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageContext == nil {
				m.ImageContext = &ImageContext{}
			}
			if err := m.ImageContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnotateImageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotateImageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotateImageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceAnnotations = append(m.FaceAnnotations, &FaceAnnotation{})
			if err := m.FaceAnnotations[len(m.FaceAnnotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LandmarkAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LandmarkAnnotations = append(m.LandmarkAnnotations, &EntityAnnotation{})
			if err := m.LandmarkAnnotations[len(m.LandmarkAnnotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogoAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogoAnnotations = append(m.LogoAnnotations, &EntityAnnotation{})
			if err := m.LogoAnnotations[len(m.LogoAnnotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelAnnotations = append(m.LabelAnnotations, &EntityAnnotation{})
			if err := m.LabelAnnotations[len(m.LabelAnnotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TextAnnotations = append(m.TextAnnotations, &EntityAnnotation{})
			if err := m.TextAnnotations[len(m.TextAnnotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeSearchAnnotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SafeSearchAnnotation == nil {
				m.SafeSearchAnnotation = &SafeSearchAnnotation{}
			}
			if err := m.SafeSearchAnnotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePropertiesAnnotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImagePropertiesAnnotation == nil {
				m.ImagePropertiesAnnotation = &ImageProperties{}
			}
			if err := m.ImagePropertiesAnnotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &google_rpc.Status{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CropHintsAnnotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CropHintsAnnotation == nil {
				m.CropHintsAnnotation = &CropHintsAnnotation{}
			}
			if err := m.CropHintsAnnotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullTextAnnotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FullTextAnnotation == nil {
				m.FullTextAnnotation = &TextAnnotation{}
			}
			if err := m.FullTextAnnotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebDetection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebDetection == nil {
				m.WebDetection = &WebDetection{}
			}
			if err := m.WebDetection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchAnnotateImagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchAnnotateImagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchAnnotateImagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &AnnotateImageRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchAnnotateImagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchAnnotateImagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchAnnotateImagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, &AnnotateImageResponse{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageAnnotator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImageAnnotator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImageAnnotator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImageAnnotator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageAnnotator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImageAnnotator
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImageAnnotator
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImageAnnotator(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImageAnnotator = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImageAnnotator   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("google/cloud/vision/v1/image_annotator.proto", fileDescriptorImageAnnotator)
}

var fileDescriptorImageAnnotator = []byte{
	// 2302 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0x5f, 0x6f, 0x1b, 0x4b,
	0x15, 0xaf, 0x9d, 0x38, 0xb1, 0x8f, 0x1d, 0x7b, 0x33, 0xf9, 0x53, 0x37, 0x69, 0xd3, 0xdc, 0xbd,
	0x14, 0xa2, 0x52, 0x12, 0x9a, 0x5e, 0xd0, 0xe5, 0xb6, 0x02, 0x6c, 0x67, 0x93, 0x58, 0x75, 0x6c,
	0xdf, 0xb1, 0x73, 0x73, 0x03, 0x88, 0xd5, 0x66, 0x3d, 0x76, 0xb7, 0x77, 0xbd, 0xb3, 0xec, 0xae,
	0xdb, 0xe4, 0x0d, 0x21, 0x21, 0xf1, 0xce, 0x3b, 0x8f, 0xbc, 0x23, 0xf1, 0x15, 0x90, 0xe0, 0x0d,
	0x74, 0x9f, 0x91, 0x50, 0xc5, 0x67, 0x40, 0x3c, 0xa2, 0x99, 0x9d, 0x5d, 0xcf, 0xba, 0x71, 0xea,
	0xa0, 0xfb, 0xe4, 0x9d, 0x73, 0xce, 0xef, 0x77, 0x66, 0xce, 0xcc, 0x99, 0x33, 0x33, 0x86, 0x27,
	0x03, 0x4a, 0x07, 0x36, 0xd9, 0x33, 0x6d, 0x3a, 0xea, 0xed, 0xbd, 0xb1, 0x7c, 0x8b, 0x3a, 0x7b,
	0x6f, 0x9e, 0xee, 0x59, 0x43, 0x63, 0x40, 0x74, 0xc3, 0x71, 0x68, 0x60, 0x04, 0xd4, 0xdb, 0x75,
	0x3d, 0x1a, 0x50, 0xb4, 0x1e, 0x5a, 0xef, 0x72, 0xeb, 0xdd, 0xd0, 0x7a, 0xf7, 0xcd, 0xd3, 0x8d,
	0xfb, 0x82, 0xc5, 0x70, 0xad, 0x3d, 0x81, 0xb1, 0xa8, 0xe3, 0x87, 0xa8, 0x8d, 0x47, 0x53, 0x7c,
	0x0c, 0x08, 0x1d, 0x92, 0xc0, 0xbb, 0x12, 0x66, 0xd3, 0xba, 0x12, 0x90, 0xcb, 0x40, 0x1f, 0xb3,
	0x0a, 0xeb, 0xc7, 0x53, 0xac, 0xdf, 0x92, 0x0b, 0xbd, 0x47, 0x02, 0x62, 0x4a, 0xb6, 0x77, 0x85,
	0xad, 0xe7, 0x9a, 0x7b, 0x7e, 0x60, 0x04, 0x23, 0x7f, 0x42, 0x11, 0x5c, 0xb9, 0x64, 0xcf, 0xa4,
	0x76, 0x34, 0xd0, 0x8d, 0xb2, 0xac, 0xb0, 0x8d, 0xc0, 0x76, 0x06, 0xa1, 0x46, 0xfd, 0x67, 0x1a,
	0x16, 0x0f, 0x89, 0x11, 0x8c, 0x3c, 0x82, 0x3e, 0x85, 0x79, 0x66, 0x50, 0x4e, 0x6d, 0xa7, 0x76,
	0x8a, 0xfb, 0xdf, 0xda, 0xbd, 0x3e, 0x3a, 0xbb, 0xc2, 0x7c, 0xb7, 0x7b, 0xe5, 0x12, 0xcc, 0x11,
	0xe8, 0x21, 0xe4, 0x87, 0xc6, 0xa5, 0xee, 0x11, 0x7f, 0x64, 0x07, 0x7e, 0x39, 0xbd, 0x9d, 0xda,
	0xc9, 0x60, 0x18, 0x1a, 0x97, 0x38, 0x94, 0xa8, 0xff, 0x49, 0xc1, 0x3c, 0xb3, 0x47, 0xab, 0xa0,
	0x74, 0xcf, 0xdb, 0x9a, 0x7e, 0xda, 0xec, 0xb4, 0xb5, 0x5a, 0xfd, 0xb0, 0xae, 0x1d, 0x28, 0x77,
	0x10, 0x82, 0xe2, 0x61, 0xa5, 0xa6, 0xe9, 0x07, 0x5a, 0x57, 0xab, 0x75, 0xeb, 0xad, 0xa6, 0x92,
	0x42, 0xeb, 0x80, 0x1a, 0x95, 0xe6, 0xc1, 0x49, 0x05, 0xbf, 0x94, 0xe4, 0x69, 0x66, 0xdb, 0x68,
	0x1d, 0xb5, 0x24, 0xd9, 0x1c, 0x5a, 0x81, 0x52, 0xa3, 0x52, 0xd5, 0x1a, 0x92, 0x70, 0x9e, 0x19,
	0x76, 0xb5, 0x2f, 0xbb, 0x92, 0x2c, 0x83, 0x36, 0xe1, 0xee, 0x41, 0xab, 0x76, 0x7a, 0xa2, 0x35,
	0xbb, 0xfa, 0x84, 0x32, 0x8f, 0xee, 0xc1, 0x5a, 0xa7, 0x72, 0xa8, 0xe9, 0x1d, 0xad, 0x82, 0x6b,
	0xc7, 0x92, 0x6a, 0x81, 0x75, 0xbb, 0x7e, 0x52, 0x39, 0xd2, 0xf4, 0x36, 0x6e, 0xb5, 0x35, 0xdc,
	0xad, 0x6b, 0x1d, 0x65, 0x11, 0x15, 0x01, 0x6a, 0xb8, 0xd5, 0xd6, 0x8f, 0xeb, 0xcd, 0x6e, 0x47,
	0xc9, 0xa1, 0x65, 0x58, 0x3a, 0xd3, 0xaa, 0x12, 0x10, 0xd4, 0x26, 0xe4, 0xeb, 0x6c, 0xed, 0x75,
	0xe8, 0xc8, 0x33, 0x09, 0x52, 0x61, 0x69, 0x60, 0xfa, 0x7a, 0xb8, 0x1c, 0x47, 0x9e, 0xc5, 0x63,
	0x9d, 0xc3, 0xf9, 0x81, 0xe9, 0x73, 0xb3, 0x53, 0xcf, 0x42, 0x9b, 0x90, 0x1b, 0xeb, 0xd3, 0x5c,
	0x9f, 0xb5, 0x84, 0x52, 0xfd, 0x25, 0x64, 0xb8, 0x21, 0x2a, 0xc3, 0xa2, 0x49, 0x9d, 0x80, 0x38,
	0x01, 0xe7, 0x28, 0xe0, 0xa8, 0x89, 0x9e, 0xc3, 0x82, 0xcf, 0xbd, 0x71, 0x70, 0x7e, 0xff, 0xe3,
	0x69, 0x13, 0x29, 0x75, 0x0c, 0x0b, 0x88, 0xfa, 0x8f, 0x12, 0x14, 0x0f, 0x0d, 0x93, 0x54, 0xe2,
	0x05, 0x8a, 0xea, 0xb0, 0x74, 0x41, 0x47, 0x4e, 0xcf, 0x72, 0x06, 0xba, 0x4b, 0xed, 0x2b, 0xee,
	0x2f, 0x3f, 0x7d, 0x7d, 0x54, 0x85, 0x71, 0x9b, 0xda, 0x57, 0xb8, 0x70, 0x21, 0xb5, 0x50, 0x13,
	0x94, 0x7e, 0x4f, 0x4f, 0xb2, 0xa5, 0x6f, 0xc1, 0x56, 0xec, 0xf7, 0xe4, 0x36, 0x3a, 0x81, 0x9c,
	0x6d, 0x38, 0xbd, 0xa1, 0xe1, 0x7d, 0xe5, 0x97, 0xe7, 0xb6, 0xe7, 0x76, 0xf2, 0xfb, 0x7b, 0x53,
	0x97, 0x6d, 0x62, 0x54, 0xbb, 0x0d, 0x81, 0xc3, 0x63, 0x06, 0xf4, 0x00, 0xc0, 0xa3, 0xb6, 0xad,
	0x1b, 0xce, 0xc0, 0x26, 0xe5, 0xf9, 0xed, 0xd4, 0x4e, 0x1a, 0xe7, 0x98, 0xa4, 0xc2, 0x04, 0x6c,
	0x62, 0x5c, 0xc3, 0x11, 0xda, 0x0c, 0xd7, 0x66, 0x5d, 0xc3, 0x09, 0x95, 0x0f, 0x00, 0x02, 0xcb,
	0x0e, 0x84, 0x76, 0x21, 0xc4, 0x32, 0x49, 0xa8, 0x7e, 0x0a, 0xab, 0x71, 0x1a, 0xeb, 0x26, 0x75,
	0xfa, 0x56, 0x8f, 0x38, 0x26, 0x29, 0x2f, 0x72, 0xc3, 0x95, 0x58, 0x57, 0x8b, 0x55, 0xe8, 0x07,
	0xb0, 0x1e, 0x75, 0x8d, 0x05, 0x4b, 0x02, 0x65, 0x39, 0x68, 0x4d, 0xd2, 0x4a, 0xb0, 0x3a, 0x14,
	0x5f, 0xd3, 0x2b, 0xdd, 0xb6, 0xbe, 0x22, 0xb6, 0xf5, 0x8a, 0xd2, 0x5e, 0x39, 0xc7, 0xf3, 0x59,
	0x9d, 0x16, 0x98, 0x46, 0x6c, 0x89, 0x97, 0x5e, 0xd3, 0xab, 0x71, 0x13, 0xb5, 0x60, 0xd9, 0xa7,
	0x9e, 0x47, 0xdf, 0xca, 0x6c, 0x30, 0x33, 0x9b, 0x12, 0x82, 0x25, 0xc2, 0x13, 0x50, 0x0c, 0x67,
	0x40, 0x3c, 0x99, 0x2f, 0x3f, 0x33, 0x5f, 0x89, 0x63, 0x25, 0xba, 0x0e, 0xac, 0xf8, 0x23, 0xcf,
	0xf5, 0x2c, 0x9f, 0xc8, 0x8c, 0x85, 0x99, 0x19, 0x51, 0x04, 0x97, 0x48, 0x7f, 0x01, 0xe5, 0x91,
	0xd3, 0x23, 0x9e, 0x4e, 0x2e, 0x5d, 0xea, 0x93, 0x9e, 0xcc, 0xbc, 0x34, 0x33, 0xf3, 0x3a, 0xe7,
	0xd0, 0x42, 0x0a, 0x89, 0xfd, 0x73, 0x40, 0x17, 0xf6, 0xc8, 0xf3, 0x92, 0xbc, 0xc5, 0x99, 0x79,
	0x97, 0x05, 0x3a, 0x19, 0x85, 0x57, 0xc4, 0xe8, 0xbd, 0x25, 0x46, 0x22, 0xae, 0xa5, 0xd9, 0xa3,
	0x10, 0xc1, 0xc7, 0xb2, 0x8d, 0xbf, 0x2d, 0x42, 0x36, 0x4a, 0x11, 0x74, 0x2c, 0x0a, 0xc3, 0x1c,
	0xa7, 0xfc, 0xe4, 0x96, 0x19, 0x26, 0x17, 0x8a, 0x17, 0x90, 0x75, 0xa9, 0x6f, 0x31, 0x3d, 0xcf,
	0xaf, 0xfc, 0xfe, 0xf6, 0x34, 0xb6, 0xb6, 0xb0, 0xc3, 0x31, 0x42, 0xfd, 0xf3, 0xc2, 0xb8, 0x8a,
	0x9c, 0x36, 0x5f, 0x36, 0x5b, 0x67, 0x4d, 0x3d, 0xaa, 0x11, 0xca, 0x1d, 0x54, 0x80, 0x6c, 0x43,
	0x3b, 0xec, 0xea, 0xda, 0xb9, 0xa6, 0xa4, 0xd0, 0x12, 0xe4, 0x70, 0xfd, 0xe8, 0x38, 0x6c, 0xa6,
	0x51, 0x19, 0x56, 0xb9, 0xb2, 0x75, 0xa8, 0x47, 0x46, 0x55, 0xdc, 0x3a, 0x53, 0xe6, 0xd8, 0xb6,
	0x1f, 0x1a, 0x4e, 0xaa, 0xe6, 0x99, 0x2a, 0x02, 0xc5, 0x5c, 0x5c, 0x95, 0x41, 0x1b, 0xb0, 0x1e,
	0xa3, 0x92, 0xba, 0x05, 0x06, 0x3b, 0xa9, 0x1f, 0xb4, 0x5b, 0xf5, 0x66, 0x57, 0xaf, 0x6a, 0xdd,
	0x33, 0x4d, 0x6b, 0x32, 0x2d, 0x2b, 0x19, 0x05, 0xc8, 0x36, 0x5b, 0x1d, 0x4d, 0xef, 0xd6, 0xdb,
	0x4a, 0x96, 0xf5, 0xf1, 0xb4, 0xdd, 0xd6, 0xb0, 0xde, 0xa8, 0xb7, 0x95, 0x1c, 0x6b, 0x36, 0x5a,
	0x67, 0xa2, 0x09, 0xac, 0xbc, 0x9c, 0xb4, 0x4e, 0xbb, 0xc7, 0xbc, 0x57, 0x4a, 0x1e, 0x95, 0x20,
	0x1f, 0xb6, 0xb9, 0x3f, 0xa5, 0x80, 0x14, 0x28, 0x84, 0x82, 0x9a, 0xd6, 0xec, 0x6a, 0x58, 0x59,
	0x42, 0x6b, 0xb0, 0xcc, 0xe9, 0xab, 0xad, 0x6e, 0xb7, 0x75, 0x22, 0x0c, 0x8b, 0x2c, 0x5e, 0xb2,
	0x98, 0xf3, 0x95, 0x58, 0x85, 0x95, 0xa5, 0x82, 0x44, 0x89, 0x47, 0xad, 0x9d, 0x6b, 0x7a, 0xb7,
	0xd5, 0xd6, 0xab, 0xad, 0xd3, 0xe6, 0x41, 0x05, 0x9f, 0x2b, 0xcb, 0x09, 0x55, 0x38, 0xea, 0x5a,
	0x0b, 0x37, 0x35, 0xac, 0x20, 0x74, 0x1f, 0xca, 0xb1, 0x4a, 0x30, 0xc6, 0xc0, 0x95, 0x38, 0xfc,
	0x4c, 0xcb, 0x3f, 0x04, 0x6e, 0x75, 0x1c, 0xc8, 0xf7, 0xdc, 0xad, 0x25, 0x75, 0x09, 0x7f, 0xeb,
	0xe8, 0x01, 0xdc, 0x1b, 0xeb, 0x26, 0x1d, 0xde, 0x1d, 0xcf, 0xea, 0xa4, 0xc7, 0x32, 0x7a, 0x08,
	0x9b, 0xf2, 0x3c, 0xeb, 0xe1, 0x14, 0x44, 0x33, 0xa6, 0xdc, 0x43, 0xdb, 0x70, 0x3f, 0x31, 0xa5,
	0x93, 0x16, 0x1b, 0x2c, 0xa0, 0x21, 0x45, 0x05, 0xeb, 0x5d, 0x5c, 0x39, 0x62, 0xc5, 0x7e, 0x93,
	0x45, 0x5f, 0xe0, 0x24, 0xf1, 0x7d, 0x7e, 0x62, 0x89, 0xc6, 0xde, 0x3e, 0x6d, 0xd7, 0x1b, 0xca,
	0x03, 0x76, 0x62, 0x19, 0x77, 0x2f, 0x14, 0x6e, 0x31, 0xfc, 0x61, 0x0b, 0x6b, 0xc7, 0x5a, 0xe5,
	0x40, 0x3f, 0xe2, 0x07, 0x9a, 0x46, 0x45, 0x79, 0xc8, 0x8e, 0x15, 0xb5, 0xe3, 0x7a, 0x53, 0x3f,
	0x6a, 0x56, 0xba, 0xc7, 0x8c, 0x72, 0x9b, 0xf9, 0xe7, 0x22, 0xce, 0x7b, 0xd4, 0x6a, 0x32, 0xe9,
	0x47, 0x0c, 0xcf, 0xa5, 0x21, 0xb3, 0x10, 0xab, 0xea, 0x0b, 0x28, 0x34, 0xa8, 0xc9, 0x93, 0xb2,
	0xee, 0xf4, 0x29, 0x7a, 0x02, 0x8b, 0xb6, 0x11, 0xe8, 0xb6, 0x33, 0x10, 0xa5, 0x7c, 0x25, 0xca,
	0x41, 0x96, 0xa3, 0xbb, 0x0d, 0x23, 0x68, 0x38, 0x03, 0xbc, 0x60, 0xf3, 0x5f, 0xf5, 0x13, 0xc8,
	0xb6, 0x3d, 0xea, 0x12, 0x2f, 0xb8, 0x42, 0x08, 0xe6, 0x1d, 0x63, 0x48, 0xc4, 0xa9, 0x85, 0x7f,
	0xa3, 0x55, 0xc8, 0xbc, 0x31, 0xec, 0x11, 0x11, 0x47, 0x95, 0xb0, 0xa1, 0xfe, 0x76, 0x0e, 0x14,
	0xcd, 0x09, 0xac, 0xe0, 0x4a, 0x3a, 0x49, 0x28, 0x30, 0x37, 0xb4, 0x7a, 0x02, 0xcd, 0x3e, 0xd1,
	0x3a, 0x2c, 0xd8, 0xd4, 0x34, 0xec, 0x08, 0x2d, 0x5a, 0x68, 0x1b, 0xf2, 0x3d, 0xe2, 0x9b, 0x9e,
	0xe5, 0xf2, 0xad, 0x62, 0x2e, 0x3c, 0x25, 0x49, 0x22, 0xe6, 0xd6, 0x37, 0xa9, 0x17, 0x95, 0xe9,
	0xb0, 0x81, 0xb6, 0x00, 0xa4, 0x3a, 0x19, 0xd6, 0x68, 0x49, 0xc2, 0xf4, 0x01, 0x75, 0x2d, 0xd3,
	0xb0, 0xad, 0xe0, 0x4a, 0x54, 0x69, 0x49, 0xf2, 0xfe, 0x59, 0x67, 0xf1, 0xff, 0x3e, 0xeb, 0x54,
	0x21, 0x67, 0x8b, 0xa8, 0xfb, 0xe5, 0x2c, 0x3f, 0x9b, 0x4c, 0xa5, 0x91, 0xa7, 0x07, 0x8f, 0x61,
	0xe8, 0xa7, 0x00, 0x6e, 0x18, 0x7b, 0x8b, 0xf8, 0xe5, 0x1c, 0x27, 0x99, 0xbe, 0x61, 0x8a, 0x59,
	0xc2, 0x12, 0x46, 0xfd, 0x5d, 0x1a, 0x56, 0x3b, 0x46, 0x9f, 0x74, 0x88, 0xe1, 0x99, 0xaf, 0xa4,
	0xb9, 0xf8, 0x14, 0x32, 0x46, 0x6f, 0x64, 0x07, 0xe2, 0xb4, 0x3f, 0x4b, 0x9d, 0x08, 0x01, 0x0c,
	0xe9, 0xbb, 0x94, 0xf6, 0xf9, 0x94, 0xcd, 0x88, 0xe4, 0x00, 0xf4, 0x02, 0x16, 0x87, 0xa4, 0xc7,
	0x62, 0x2d, 0x4a, 0xc9, 0x2c, 0xd8, 0x08, 0x82, 0x7e, 0x0c, 0xd9, 0x37, 0x16, 0xb5, 0xf9, 0xcc,
	0xce, 0xcf, 0x0c, 0x8f, 0x31, 0xea, 0x5b, 0xc8, 0xb3, 0xa5, 0x4d, 0x9d, 0x01, 0x26, 0x66, 0x80,
	0x9e, 0x41, 0x7e, 0x68, 0x39, 0xfa, 0x0c, 0x99, 0x90, 0x1b, 0x5a, 0x4e, 0xf8, 0xc9, 0x41, 0xc6,
	0x65, 0x0c, 0x4a, 0xdf, 0x04, 0x32, 0x2e, 0xc3, 0x4f, 0xd5, 0x83, 0x5c, 0x8d, 0x5d, 0xc6, 0x78,
	0xf2, 0xed, 0x40, 0x86, 0xdf, 0xcc, 0x84, 0x43, 0x94, 0xc0, 0x72, 0x33, 0x1c, 0x1a, 0x8c, 0x57,
	0x78, 0x5a, 0x5e, 0xe1, 0x8f, 0xa0, 0xe8, 0x5a, 0x97, 0xc4, 0xd6, 0xfb, 0x9e, 0x61, 0xc6, 0xc9,
	0x91, 0xc6, 0x4b, 0x5c, 0x7a, 0x28, 0x84, 0xea, 0x29, 0x94, 0x0f, 0xe8, 0xd0, 0x72, 0x0c, 0x27,
	0xe0, 0xa4, 0xbe, 0x34, 0xf5, 0x3f, 0x82, 0x05, 0xee, 0xc1, 0x2f, 0xa7, 0xf8, 0x8a, 0xfa, 0x68,
	0x5a, 0x18, 0xe3, 0x5e, 0x63, 0x01, 0x50, 0x6d, 0x28, 0xf1, 0x5b, 0x43, 0x3b, 0x5e, 0x61, 0xe8,
	0x1c, 0x4a, 0x3d, 0xe1, 0x49, 0x8f, 0x69, 0xd9, 0xd0, 0xbe, 0x3f, 0x8d, 0x76, 0x5a, 0xc7, 0x70,
	0xb1, 0x97, 0xd0, 0xa8, 0x7f, 0x4c, 0x41, 0xb6, 0xe6, 0x51, 0xf7, 0xd8, 0x72, 0x82, 0x6f, 0xf2,
	0x1a, 0x92, 0xdc, 0x25, 0xd2, 0xef, 0xed, 0x12, 0x7b, 0xb0, 0x62, 0x0d, 0x5d, 0xea, 0x05, 0x86,
	0x63, 0x92, 0xc9, 0x40, 0xa3, 0xb1, 0x2a, 0x8e, 0xf6, 0x17, 0xb0, 0x12, 0xf5, 0x53, 0x0e, 0xf4,
	0x4f, 0x00, 0x4c, 0x8f, 0xba, 0xfa, 0x2b, 0x26, 0x17, 0xc1, 0x9e, 0x9a, 0xbe, 0x11, 0x01, 0xce,
	0x99, 0x11, 0x95, 0xfa, 0x43, 0x28, 0xc5, 0xbc, 0x6d, 0xc3, 0x33, 0x86, 0x3e, 0xfa, 0x18, 0x96,
	0x0c, 0xdf, 0x25, 0x66, 0xa0, 0x7b, 0xcc, 0x49, 0x48, 0x9b, 0xc6, 0x85, 0x50, 0x88, 0xb9, 0x4c,
	0xfd, 0x3a, 0x05, 0x05, 0x3e, 0x4f, 0x35, 0x76, 0x27, 0xbc, 0x0c, 0xd0, 0x11, 0x2c, 0xf1, 0x35,
	0x4b, 0x9d, 0x81, 0xee, 0x11, 0x33, 0x10, 0xc1, 0x9b, 0x7a, 0x35, 0x94, 0x12, 0x05, 0xe7, 0x6d,
	0x29, 0x6b, 0x1e, 0x41, 0xd1, 0x36, 0x9c, 0xc1, 0x88, 0xdd, 0x4f, 0xc3, 0x61, 0xa5, 0xb7, 0xe7,
	0x76, 0x72, 0x78, 0x29, 0x92, 0xf2, 0xbe, 0xa2, 0x0e, 0x2c, 0x8f, 0x47, 0xae, 0xbb, 0xbc, 0xeb,
	0xe2, 0xc0, 0xf7, 0x9d, 0x0f, 0x05, 0x40, 0x8c, 0x14, 0x97, 0xcc, 0xa4, 0x80, 0x8d, 0x6a, 0x55,
	0x44, 0x97, 0xf0, 0xd1, 0x61, 0xf2, 0xab, 0x11, 0xf1, 0x59, 0x2a, 0x67, 0xf8, 0x05, 0x59, 0x8c,
	0xea, 0xc1, 0x8d, 0x17, 0x5e, 0x1c, 0xda, 0xa2, 0xe7, 0x90, 0xed, 0x87, 0x2f, 0x19, 0xe1, 0x18,
	0xf2, 0xfb, 0x0f, 0x3f, 0xf0, 0xe2, 0x81, 0x63, 0x00, 0x5b, 0x8c, 0xe1, 0x1d, 0xdd, 0x0c, 0x03,
	0xcc, 0xd7, 0xc6, 0x0d, 0x8b, 0x51, 0x9e, 0x0c, 0x5c, 0xb0, 0xa4, 0x96, 0xfa, 0x97, 0x45, 0x58,
	0x9b, 0x18, 0x95, 0xef, 0x52, 0xc7, 0x27, 0xe8, 0x73, 0x50, 0xfa, 0x86, 0x49, 0xa4, 0xc7, 0xa2,
	0x68, 0x11, 0x7d, 0x7b, 0xb6, 0x23, 0x38, 0x2e, 0xf5, 0x13, 0x6d, 0x1f, 0xfd, 0x1c, 0x56, 0xa3,
	0x5b, 0x63, 0x82, 0x36, 0x0c, 0xc0, 0xce, 0x34, 0xda, 0xc9, 0x4a, 0x8e, 0x57, 0x22, 0x16, 0x99,
	0xbc, 0x03, 0x8a, 0x4d, 0x07, 0x34, 0x41, 0x3c, 0x77, 0x4b, 0xe2, 0x12, 0x63, 0x90, 0x49, 0x4f,
	0x61, 0xd9, 0x36, 0x2e, 0x88, 0x9d, 0x60, 0x9d, 0xbf, 0x25, 0xab, 0xc2, 0x29, 0x26, 0xfa, 0x3a,
	0xf1, 0x10, 0xe7, 0x97, 0x33, 0xb7, 0xed, 0x2b, 0x63, 0x90, 0x49, 0x2f, 0x60, 0xdd, 0x37, 0xfa,
	0x44, 0xf7, 0x79, 0xb1, 0x95, 0xb8, 0xf9, 0x49, 0x23, 0xbf, 0xff, 0x64, 0x1a, 0xf5, 0x75, 0x15,
	0x1a, 0xaf, 0xfa, 0xd7, 0xd5, 0xed, 0x01, 0x6c, 0x86, 0x2b, 0x6f, 0x5c, 0xe4, 0x65, 0x47, 0xd9,
	0x9b, 0x73, 0x6c, 0x62, 0xf3, 0xc6, 0xf7, 0xac, 0xa4, 0x40, 0x72, 0xb4, 0x03, 0x19, 0xe2, 0x79,
	0xd4, 0xe3, 0xcf, 0x07, 0x52, 0xa1, 0xf2, 0x5c, 0x73, 0xb7, 0xc3, 0x5f, 0x1d, 0x71, 0x68, 0x80,
	0x74, 0x58, 0x93, 0x92, 0x5d, 0xea, 0x4c, 0x9e, 0x23, 0xbf, 0xfb, 0xc1, 0x84, 0x97, 0x17, 0x96,
	0x79, 0xcd, 0x3e, 0xfa, 0x25, 0xac, 0xf6, 0x47, 0xb6, 0xad, 0x4f, 0xcc, 0x18, 0xbf, 0xe8, 0xdf,
	0x90, 0x0c, 0xdd, 0xc4, 0xf4, 0x60, 0xc4, 0x38, 0x92, 0x32, 0x96, 0xc7, 0x89, 0x17, 0x56, 0x7e,
	0xc3, 0xbf, 0x21, 0x8f, 0xcf, 0xc8, 0xc5, 0x41, 0x64, 0x8b, 0x0b, 0x6f, 0xa5, 0x96, 0xda, 0x87,
	0x8d, 0xaa, 0x11, 0xc4, 0x73, 0x15, 0xe6, 0xb2, 0x1f, 0x6d, 0x51, 0xc7, 0x90, 0xf5, 0xc2, 0xcf,
	0x28, 0x87, 0xa7, 0x2e, 0x86, 0xeb, 0xb6, 0x38, 0x1c, 0xa3, 0xd5, 0xd7, 0xb0, 0x79, 0xad, 0x1f,
	0xb1, 0x69, 0xbc, 0x84, 0x9c, 0x27, 0xbe, 0x23, 0x4f, 0xdf, 0x9b, 0xd1, 0x53, 0x88, 0xc2, 0x63,
	0xfc, 0x63, 0x02, 0x20, 0x3d, 0x34, 0xe4, 0x61, 0x51, 0xdc, 0xba, 0x95, 0x3b, 0xec, 0x52, 0xf2,
	0x85, 0x86, 0xcf, 0xf5, 0xd3, 0x66, 0xa3, 0xfe, 0x52, 0x6b, 0x9c, 0x2b, 0x29, 0x76, 0xb7, 0x8d,
	0x5b, 0x69, 0xd6, 0x6a, 0xb7, 0x3a, 0x9d, 0x7a, 0xb5, 0xa1, 0x29, 0x73, 0x08, 0x60, 0x41, 0x68,
	0xe6, 0xd9, 0x3d, 0x96, 0x43, 0x85, 0x20, 0xb3, 0xff, 0xa7, 0x14, 0x14, 0x79, 0x1f, 0x2a, 0xd1,
	0x03, 0x3d, 0xfa, 0x43, 0x0a, 0x56, 0xae, 0x19, 0x26, 0xda, 0x9f, 0x5a, 0xee, 0xa7, 0xc6, 0x7e,
	0xe3, 0xd9, 0xad, 0x30, 0xe1, 0xd8, 0xd5, 0xad, 0xdf, 0x7c, 0xfd, 0xef, 0xdf, 0xa7, 0xcb, 0xea,
	0x4a, 0xfc, 0xf7, 0x81, 0xff, 0x99, 0x58, 0x7a, 0xe4, 0xb3, 0xd4, 0xe3, 0xea, 0xaf, 0x53, 0x7f,
	0x7d, 0xb7, 0x95, 0xfa, 0xfb, 0xbb, 0xad, 0xd4, 0xbf, 0xde, 0x6d, 0xa5, 0x60, 0xc3, 0xa4, 0xc3,
	0x29, 0x6e, 0xaa, 0x2b, 0xc9, 0xb1, 0xb5, 0x3d, 0x1a, 0xd0, 0x76, 0xea, 0x67, 0x2f, 0x84, 0xf9,
	0x80, 0xb2, 0xda, 0xb9, 0x4b, 0xbd, 0xc1, 0xde, 0x80, 0x38, 0xfc, 0x59, 0x7e, 0x2f, 0x54, 0x19,
	0xae, 0xe5, 0x4f, 0xfe, 0x23, 0xf0, 0x3c, 0xfc, 0xfa, 0x6f, 0x2a, 0x75, 0xb1, 0xc0, 0x6d, 0x9f,
	0xfd, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xad, 0xee, 0x96, 0x5a, 0xf5, 0x18, 0x00, 0x00,
}
