// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/bigtable/v2/bigtable.proto

/*
	Package bigtable is a generated protocol buffer package.

	It is generated from these files:
		google/bigtable/v2/bigtable.proto
		google/bigtable/v2/data.proto

	It has these top-level messages:
		ReadRowsRequest
		ReadRowsResponse
		SampleRowKeysRequest
		SampleRowKeysResponse
		MutateRowRequest
		MutateRowResponse
		MutateRowsRequest
		MutateRowsResponse
		CheckAndMutateRowRequest
		CheckAndMutateRowResponse
		ReadModifyWriteRowRequest
		ReadModifyWriteRowResponse
		Row
		Family
		Column
		Cell
		RowRange
		RowSet
		ColumnRange
		TimestampRange
		ValueRange
		RowFilter
		Mutation
		ReadModifyWriteRule
*/
package bigtable

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Request message for Bigtable.ReadRows.
type ReadRowsRequest struct {
	// The unique name of the table from which to read.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The row keys and/or ranges to read. If not specified, reads from all rows.
	Rows *RowSet `protobuf:"bytes,2,opt,name=rows" json:"rows,omitempty"`
	// The filter to apply to the contents of the specified row(s). If unset,
	// reads the entirety of each row.
	Filter *RowFilter `protobuf:"bytes,3,opt,name=filter" json:"filter,omitempty"`
	// The read will terminate after committing to N rows' worth of results. The
	// default (zero) is to return all results.
	RowsLimit int64 `protobuf:"varint,4,opt,name=rows_limit,json=rowsLimit,proto3" json:"rows_limit,omitempty"`
}

func (m *ReadRowsRequest) Reset()                    { *m = ReadRowsRequest{} }
func (m *ReadRowsRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRowsRequest) ProtoMessage()               {}
func (*ReadRowsRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{0} }

func (m *ReadRowsRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *ReadRowsRequest) GetRows() *RowSet {
	if m != nil {
		return m.Rows
	}
	return nil
}

func (m *ReadRowsRequest) GetFilter() *RowFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *ReadRowsRequest) GetRowsLimit() int64 {
	if m != nil {
		return m.RowsLimit
	}
	return 0
}

// Response message for Bigtable.ReadRows.
type ReadRowsResponse struct {
	Chunks []*ReadRowsResponse_CellChunk `protobuf:"bytes,1,rep,name=chunks" json:"chunks,omitempty"`
	// Optionally the server might return the row key of the last row it
	// has scanned.  The client can use this to construct a more
	// efficient retry request if needed: any row keys or portions of
	// ranges less than this row key can be dropped from the request.
	// This is primarily useful for cases where the server has read a
	// lot of data that was filtered out since the last committed row
	// key, allowing the client to skip that work on a retry.
	LastScannedRowKey []byte `protobuf:"bytes,2,opt,name=last_scanned_row_key,json=lastScannedRowKey,proto3" json:"last_scanned_row_key,omitempty"`
}

func (m *ReadRowsResponse) Reset()                    { *m = ReadRowsResponse{} }
func (m *ReadRowsResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadRowsResponse) ProtoMessage()               {}
func (*ReadRowsResponse) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{1} }

func (m *ReadRowsResponse) GetChunks() []*ReadRowsResponse_CellChunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *ReadRowsResponse) GetLastScannedRowKey() []byte {
	if m != nil {
		return m.LastScannedRowKey
	}
	return nil
}

// Specifies a piece of a row's contents returned as part of the read
// response stream.
type ReadRowsResponse_CellChunk struct {
	// The row key for this chunk of data.  If the row key is empty,
	// this CellChunk is a continuation of the same row as the previous
	// CellChunk in the response stream, even if that CellChunk was in a
	// previous ReadRowsResponse message.
	RowKey []byte `protobuf:"bytes,1,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// The column family name for this chunk of data.  If this message
	// is not present this CellChunk is a continuation of the same column
	// family as the previous CellChunk.  The empty string can occur as a
	// column family name in a response so clients must check
	// explicitly for the presence of this message, not just for
	// `family_name.value` being non-empty.
	FamilyName *google_protobuf1.StringValue `protobuf:"bytes,2,opt,name=family_name,json=familyName" json:"family_name,omitempty"`
	// The column qualifier for this chunk of data.  If this message
	// is not present, this CellChunk is a continuation of the same column
	// as the previous CellChunk.  Column qualifiers may be empty so
	// clients must check for the presence of this message, not just
	// for `qualifier.value` being non-empty.
	Qualifier *google_protobuf1.BytesValue `protobuf:"bytes,3,opt,name=qualifier" json:"qualifier,omitempty"`
	// The cell's stored timestamp, which also uniquely identifies it
	// within its column.  Values are always expressed in
	// microseconds, but individual tables may set a coarser
	// granularity to further restrict the allowed values. For
	// example, a table which specifies millisecond granularity will
	// only allow values of `timestamp_micros` which are multiples of
	// 1000.  Timestamps are only set in the first CellChunk per cell
	// (for cells split into multiple chunks).
	TimestampMicros int64 `protobuf:"varint,4,opt,name=timestamp_micros,json=timestampMicros,proto3" json:"timestamp_micros,omitempty"`
	// Labels applied to the cell by a
	// [RowFilter][google.bigtable.v2.RowFilter].  Labels are only set
	// on the first CellChunk per cell.
	Labels []string `protobuf:"bytes,5,rep,name=labels" json:"labels,omitempty"`
	// The value stored in the cell.  Cell values can be split across
	// multiple CellChunks.  In that case only the value field will be
	// set in CellChunks after the first: the timestamp and labels
	// will only be present in the first CellChunk, even if the first
	// CellChunk came in a previous ReadRowsResponse.
	Value []byte `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	// If this CellChunk is part of a chunked cell value and this is
	// not the final chunk of that cell, value_size will be set to the
	// total length of the cell value.  The client can use this size
	// to pre-allocate memory to hold the full cell value.
	ValueSize int32 `protobuf:"varint,7,opt,name=value_size,json=valueSize,proto3" json:"value_size,omitempty"`
	// Types that are valid to be assigned to RowStatus:
	//	*ReadRowsResponse_CellChunk_ResetRow
	//	*ReadRowsResponse_CellChunk_CommitRow
	RowStatus isReadRowsResponse_CellChunk_RowStatus `protobuf_oneof:"row_status"`
}

func (m *ReadRowsResponse_CellChunk) Reset()         { *m = ReadRowsResponse_CellChunk{} }
func (m *ReadRowsResponse_CellChunk) String() string { return proto.CompactTextString(m) }
func (*ReadRowsResponse_CellChunk) ProtoMessage()    {}
func (*ReadRowsResponse_CellChunk) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{1, 0}
}

type isReadRowsResponse_CellChunk_RowStatus interface {
	isReadRowsResponse_CellChunk_RowStatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReadRowsResponse_CellChunk_ResetRow struct {
	ResetRow bool `protobuf:"varint,8,opt,name=reset_row,json=resetRow,proto3,oneof"`
}
type ReadRowsResponse_CellChunk_CommitRow struct {
	CommitRow bool `protobuf:"varint,9,opt,name=commit_row,json=commitRow,proto3,oneof"`
}

func (*ReadRowsResponse_CellChunk_ResetRow) isReadRowsResponse_CellChunk_RowStatus()  {}
func (*ReadRowsResponse_CellChunk_CommitRow) isReadRowsResponse_CellChunk_RowStatus() {}

func (m *ReadRowsResponse_CellChunk) GetRowStatus() isReadRowsResponse_CellChunk_RowStatus {
	if m != nil {
		return m.RowStatus
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetFamilyName() *google_protobuf1.StringValue {
	if m != nil {
		return m.FamilyName
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetQualifier() *google_protobuf1.BytesValue {
	if m != nil {
		return m.Qualifier
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetTimestampMicros() int64 {
	if m != nil {
		return m.TimestampMicros
	}
	return 0
}

func (m *ReadRowsResponse_CellChunk) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *ReadRowsResponse_CellChunk) GetValueSize() int32 {
	if m != nil {
		return m.ValueSize
	}
	return 0
}

func (m *ReadRowsResponse_CellChunk) GetResetRow() bool {
	if x, ok := m.GetRowStatus().(*ReadRowsResponse_CellChunk_ResetRow); ok {
		return x.ResetRow
	}
	return false
}

func (m *ReadRowsResponse_CellChunk) GetCommitRow() bool {
	if x, ok := m.GetRowStatus().(*ReadRowsResponse_CellChunk_CommitRow); ok {
		return x.CommitRow
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReadRowsResponse_CellChunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReadRowsResponse_CellChunk_OneofMarshaler, _ReadRowsResponse_CellChunk_OneofUnmarshaler, _ReadRowsResponse_CellChunk_OneofSizer, []interface{}{
		(*ReadRowsResponse_CellChunk_ResetRow)(nil),
		(*ReadRowsResponse_CellChunk_CommitRow)(nil),
	}
}

func _ReadRowsResponse_CellChunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReadRowsResponse_CellChunk)
	// row_status
	switch x := m.RowStatus.(type) {
	case *ReadRowsResponse_CellChunk_ResetRow:
		t := uint64(0)
		if x.ResetRow {
			t = 1
		}
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *ReadRowsResponse_CellChunk_CommitRow:
		t := uint64(0)
		if x.CommitRow {
			t = 1
		}
		_ = b.EncodeVarint(9<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ReadRowsResponse_CellChunk.RowStatus has unexpected type %T", x)
	}
	return nil
}

func _ReadRowsResponse_CellChunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReadRowsResponse_CellChunk)
	switch tag {
	case 8: // row_status.reset_row
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.RowStatus = &ReadRowsResponse_CellChunk_ResetRow{x != 0}
		return true, err
	case 9: // row_status.commit_row
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.RowStatus = &ReadRowsResponse_CellChunk_CommitRow{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ReadRowsResponse_CellChunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReadRowsResponse_CellChunk)
	// row_status
	switch x := m.RowStatus.(type) {
	case *ReadRowsResponse_CellChunk_ResetRow:
		n += proto.SizeVarint(8<<3 | proto.WireVarint)
		n += 1
	case *ReadRowsResponse_CellChunk_CommitRow:
		n += proto.SizeVarint(9<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request message for Bigtable.SampleRowKeys.
type SampleRowKeysRequest struct {
	// The unique name of the table from which to sample row keys.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
}

func (m *SampleRowKeysRequest) Reset()                    { *m = SampleRowKeysRequest{} }
func (m *SampleRowKeysRequest) String() string            { return proto.CompactTextString(m) }
func (*SampleRowKeysRequest) ProtoMessage()               {}
func (*SampleRowKeysRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{2} }

func (m *SampleRowKeysRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

// Response message for Bigtable.SampleRowKeys.
type SampleRowKeysResponse struct {
	// Sorted streamed sequence of sample row keys in the table. The table might
	// have contents before the first row key in the list and after the last one,
	// but a key containing the empty string indicates "end of table" and will be
	// the last response given, if present.
	// Note that row keys in this list may not have ever been written to or read
	// from, and users should therefore not make any assumptions about the row key
	// structure that are specific to their use case.
	RowKey []byte `protobuf:"bytes,1,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// Approximate total storage space used by all rows in the table which precede
	// `row_key`. Buffering the contents of all rows between two subsequent
	// samples would require space roughly equal to the difference in their
	// `offset_bytes` fields.
	OffsetBytes int64 `protobuf:"varint,2,opt,name=offset_bytes,json=offsetBytes,proto3" json:"offset_bytes,omitempty"`
}

func (m *SampleRowKeysResponse) Reset()                    { *m = SampleRowKeysResponse{} }
func (m *SampleRowKeysResponse) String() string            { return proto.CompactTextString(m) }
func (*SampleRowKeysResponse) ProtoMessage()               {}
func (*SampleRowKeysResponse) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{3} }

func (m *SampleRowKeysResponse) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *SampleRowKeysResponse) GetOffsetBytes() int64 {
	if m != nil {
		return m.OffsetBytes
	}
	return 0
}

// Request message for Bigtable.MutateRow.
type MutateRowRequest struct {
	// The unique name of the table to which the mutation should be applied.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The key of the row to which the mutation should be applied.
	RowKey []byte `protobuf:"bytes,2,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// Changes to be atomically applied to the specified row. Entries are applied
	// in order, meaning that earlier mutations can be masked by later ones.
	// Must contain at least one entry and at most 100000.
	Mutations []*Mutation `protobuf:"bytes,3,rep,name=mutations" json:"mutations,omitempty"`
}

func (m *MutateRowRequest) Reset()                    { *m = MutateRowRequest{} }
func (m *MutateRowRequest) String() string            { return proto.CompactTextString(m) }
func (*MutateRowRequest) ProtoMessage()               {}
func (*MutateRowRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{4} }

func (m *MutateRowRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *MutateRowRequest) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *MutateRowRequest) GetMutations() []*Mutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

// Response message for Bigtable.MutateRow.
type MutateRowResponse struct {
}

func (m *MutateRowResponse) Reset()                    { *m = MutateRowResponse{} }
func (m *MutateRowResponse) String() string            { return proto.CompactTextString(m) }
func (*MutateRowResponse) ProtoMessage()               {}
func (*MutateRowResponse) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{5} }

// Request message for BigtableService.MutateRows.
type MutateRowsRequest struct {
	// The unique name of the table to which the mutations should be applied.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The row keys and corresponding mutations to be applied in bulk.
	// Each entry is applied as an atomic mutation, but the entries may be
	// applied in arbitrary order (even between entries for the same row).
	// At least one entry must be specified, and in total the entries can
	// contain at most 100000 mutations.
	Entries []*MutateRowsRequest_Entry `protobuf:"bytes,2,rep,name=entries" json:"entries,omitempty"`
}

func (m *MutateRowsRequest) Reset()                    { *m = MutateRowsRequest{} }
func (m *MutateRowsRequest) String() string            { return proto.CompactTextString(m) }
func (*MutateRowsRequest) ProtoMessage()               {}
func (*MutateRowsRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{6} }

func (m *MutateRowsRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *MutateRowsRequest) GetEntries() []*MutateRowsRequest_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type MutateRowsRequest_Entry struct {
	// The key of the row to which the `mutations` should be applied.
	RowKey []byte `protobuf:"bytes,1,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// Changes to be atomically applied to the specified row. Mutations are
	// applied in order, meaning that earlier mutations can be masked by
	// later ones.
	// You must specify at least one mutation.
	Mutations []*Mutation `protobuf:"bytes,2,rep,name=mutations" json:"mutations,omitempty"`
}

func (m *MutateRowsRequest_Entry) Reset()         { *m = MutateRowsRequest_Entry{} }
func (m *MutateRowsRequest_Entry) String() string { return proto.CompactTextString(m) }
func (*MutateRowsRequest_Entry) ProtoMessage()    {}
func (*MutateRowsRequest_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{6, 0}
}

func (m *MutateRowsRequest_Entry) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *MutateRowsRequest_Entry) GetMutations() []*Mutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

// Response message for BigtableService.MutateRows.
type MutateRowsResponse struct {
	// One or more results for Entries from the batch request.
	Entries []*MutateRowsResponse_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *MutateRowsResponse) Reset()                    { *m = MutateRowsResponse{} }
func (m *MutateRowsResponse) String() string            { return proto.CompactTextString(m) }
func (*MutateRowsResponse) ProtoMessage()               {}
func (*MutateRowsResponse) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{7} }

func (m *MutateRowsResponse) GetEntries() []*MutateRowsResponse_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type MutateRowsResponse_Entry struct {
	// The index into the original request's `entries` list of the Entry
	// for which a result is being reported.
	Index int64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// The result of the request Entry identified by `index`.
	// Depending on how requests are batched during execution, it is possible
	// for one Entry to fail due to an error with another Entry. In the event
	// that this occurs, the same error will be reported for both entries.
	Status *google_rpc.Status `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *MutateRowsResponse_Entry) Reset()         { *m = MutateRowsResponse_Entry{} }
func (m *MutateRowsResponse_Entry) String() string { return proto.CompactTextString(m) }
func (*MutateRowsResponse_Entry) ProtoMessage()    {}
func (*MutateRowsResponse_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{7, 0}
}

func (m *MutateRowsResponse_Entry) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MutateRowsResponse_Entry) GetStatus() *google_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Request message for Bigtable.CheckAndMutateRow.
type CheckAndMutateRowRequest struct {
	// The unique name of the table to which the conditional mutation should be
	// applied.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The key of the row to which the conditional mutation should be applied.
	RowKey []byte `protobuf:"bytes,2,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// The filter to be applied to the contents of the specified row. Depending
	// on whether or not any results are yielded, either `true_mutations` or
	// `false_mutations` will be executed. If unset, checks that the row contains
	// any values at all.
	PredicateFilter *RowFilter `protobuf:"bytes,6,opt,name=predicate_filter,json=predicateFilter" json:"predicate_filter,omitempty"`
	// Changes to be atomically applied to the specified row if `predicate_filter`
	// yields at least one cell when applied to `row_key`. Entries are applied in
	// order, meaning that earlier mutations can be masked by later ones.
	// Must contain at least one entry if `false_mutations` is empty, and at most
	// 100000.
	TrueMutations []*Mutation `protobuf:"bytes,4,rep,name=true_mutations,json=trueMutations" json:"true_mutations,omitempty"`
	// Changes to be atomically applied to the specified row if `predicate_filter`
	// does not yield any cells when applied to `row_key`. Entries are applied in
	// order, meaning that earlier mutations can be masked by later ones.
	// Must contain at least one entry if `true_mutations` is empty, and at most
	// 100000.
	FalseMutations []*Mutation `protobuf:"bytes,5,rep,name=false_mutations,json=falseMutations" json:"false_mutations,omitempty"`
}

func (m *CheckAndMutateRowRequest) Reset()                    { *m = CheckAndMutateRowRequest{} }
func (m *CheckAndMutateRowRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckAndMutateRowRequest) ProtoMessage()               {}
func (*CheckAndMutateRowRequest) Descriptor() ([]byte, []int) { return fileDescriptorBigtable, []int{8} }

func (m *CheckAndMutateRowRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *CheckAndMutateRowRequest) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *CheckAndMutateRowRequest) GetPredicateFilter() *RowFilter {
	if m != nil {
		return m.PredicateFilter
	}
	return nil
}

func (m *CheckAndMutateRowRequest) GetTrueMutations() []*Mutation {
	if m != nil {
		return m.TrueMutations
	}
	return nil
}

func (m *CheckAndMutateRowRequest) GetFalseMutations() []*Mutation {
	if m != nil {
		return m.FalseMutations
	}
	return nil
}

// Response message for Bigtable.CheckAndMutateRow.
type CheckAndMutateRowResponse struct {
	// Whether or not the request's `predicate_filter` yielded any results for
	// the specified row.
	PredicateMatched bool `protobuf:"varint,1,opt,name=predicate_matched,json=predicateMatched,proto3" json:"predicate_matched,omitempty"`
}

func (m *CheckAndMutateRowResponse) Reset()         { *m = CheckAndMutateRowResponse{} }
func (m *CheckAndMutateRowResponse) String() string { return proto.CompactTextString(m) }
func (*CheckAndMutateRowResponse) ProtoMessage()    {}
func (*CheckAndMutateRowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{9}
}

func (m *CheckAndMutateRowResponse) GetPredicateMatched() bool {
	if m != nil {
		return m.PredicateMatched
	}
	return false
}

// Request message for Bigtable.ReadModifyWriteRow.
type ReadModifyWriteRowRequest struct {
	// The unique name of the table to which the read/modify/write rules should be
	// applied.
	// Values are of the form
	// `projects/<project>/instances/<instance>/tables/<table>`.
	TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// The key of the row to which the read/modify/write rules should be applied.
	RowKey []byte `protobuf:"bytes,2,opt,name=row_key,json=rowKey,proto3" json:"row_key,omitempty"`
	// Rules specifying how the specified row's contents are to be transformed
	// into writes. Entries are applied in order, meaning that earlier rules will
	// affect the results of later ones.
	Rules []*ReadModifyWriteRule `protobuf:"bytes,3,rep,name=rules" json:"rules,omitempty"`
}

func (m *ReadModifyWriteRowRequest) Reset()         { *m = ReadModifyWriteRowRequest{} }
func (m *ReadModifyWriteRowRequest) String() string { return proto.CompactTextString(m) }
func (*ReadModifyWriteRowRequest) ProtoMessage()    {}
func (*ReadModifyWriteRowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{10}
}

func (m *ReadModifyWriteRowRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *ReadModifyWriteRowRequest) GetRowKey() []byte {
	if m != nil {
		return m.RowKey
	}
	return nil
}

func (m *ReadModifyWriteRowRequest) GetRules() []*ReadModifyWriteRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// Response message for Bigtable.ReadModifyWriteRow.
type ReadModifyWriteRowResponse struct {
	// A Row containing the new contents of all cells modified by the request.
	Row *Row `protobuf:"bytes,1,opt,name=row" json:"row,omitempty"`
}

func (m *ReadModifyWriteRowResponse) Reset()         { *m = ReadModifyWriteRowResponse{} }
func (m *ReadModifyWriteRowResponse) String() string { return proto.CompactTextString(m) }
func (*ReadModifyWriteRowResponse) ProtoMessage()    {}
func (*ReadModifyWriteRowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorBigtable, []int{11}
}

func (m *ReadModifyWriteRowResponse) GetRow() *Row {
	if m != nil {
		return m.Row
	}
	return nil
}

func init() {
	proto.RegisterType((*ReadRowsRequest)(nil), "google.bigtable.v2.ReadRowsRequest")
	proto.RegisterType((*ReadRowsResponse)(nil), "google.bigtable.v2.ReadRowsResponse")
	proto.RegisterType((*ReadRowsResponse_CellChunk)(nil), "google.bigtable.v2.ReadRowsResponse.CellChunk")
	proto.RegisterType((*SampleRowKeysRequest)(nil), "google.bigtable.v2.SampleRowKeysRequest")
	proto.RegisterType((*SampleRowKeysResponse)(nil), "google.bigtable.v2.SampleRowKeysResponse")
	proto.RegisterType((*MutateRowRequest)(nil), "google.bigtable.v2.MutateRowRequest")
	proto.RegisterType((*MutateRowResponse)(nil), "google.bigtable.v2.MutateRowResponse")
	proto.RegisterType((*MutateRowsRequest)(nil), "google.bigtable.v2.MutateRowsRequest")
	proto.RegisterType((*MutateRowsRequest_Entry)(nil), "google.bigtable.v2.MutateRowsRequest.Entry")
	proto.RegisterType((*MutateRowsResponse)(nil), "google.bigtable.v2.MutateRowsResponse")
	proto.RegisterType((*MutateRowsResponse_Entry)(nil), "google.bigtable.v2.MutateRowsResponse.Entry")
	proto.RegisterType((*CheckAndMutateRowRequest)(nil), "google.bigtable.v2.CheckAndMutateRowRequest")
	proto.RegisterType((*CheckAndMutateRowResponse)(nil), "google.bigtable.v2.CheckAndMutateRowResponse")
	proto.RegisterType((*ReadModifyWriteRowRequest)(nil), "google.bigtable.v2.ReadModifyWriteRowRequest")
	proto.RegisterType((*ReadModifyWriteRowResponse)(nil), "google.bigtable.v2.ReadModifyWriteRowResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Bigtable service

type BigtableClient interface {
	// Streams back the contents of all requested rows in key order, optionally
	// applying the same Reader filter to each. Depending on their size,
	// rows and cells may be broken up across multiple responses, but
	// atomicity of each row will still be preserved. See the
	// ReadRowsResponse documentation for details.
	ReadRows(ctx context.Context, in *ReadRowsRequest, opts ...grpc.CallOption) (Bigtable_ReadRowsClient, error)
	// Returns a sample of row keys in the table. The returned row keys will
	// delimit contiguous sections of the table of approximately equal size,
	// which can be used to break up the data for distributed tasks like
	// mapreduces.
	SampleRowKeys(ctx context.Context, in *SampleRowKeysRequest, opts ...grpc.CallOption) (Bigtable_SampleRowKeysClient, error)
	// Mutates a row atomically. Cells already present in the row are left
	// unchanged unless explicitly changed by `mutation`.
	MutateRow(ctx context.Context, in *MutateRowRequest, opts ...grpc.CallOption) (*MutateRowResponse, error)
	// Mutates multiple rows in a batch. Each individual row is mutated
	// atomically as in MutateRow, but the entire batch is not executed
	// atomically.
	MutateRows(ctx context.Context, in *MutateRowsRequest, opts ...grpc.CallOption) (Bigtable_MutateRowsClient, error)
	// Mutates a row atomically based on the output of a predicate Reader filter.
	CheckAndMutateRow(ctx context.Context, in *CheckAndMutateRowRequest, opts ...grpc.CallOption) (*CheckAndMutateRowResponse, error)
	// Modifies a row atomically. The method reads the latest existing timestamp
	// and value from the specified columns and writes a new entry based on
	// pre-defined read/modify/write rules. The new value for the timestamp is the
	// greater of the existing timestamp or the current server time. The method
	// returns the new contents of all modified cells.
	ReadModifyWriteRow(ctx context.Context, in *ReadModifyWriteRowRequest, opts ...grpc.CallOption) (*ReadModifyWriteRowResponse, error)
}

type bigtableClient struct {
	cc *grpc.ClientConn
}

func NewBigtableClient(cc *grpc.ClientConn) BigtableClient {
	return &bigtableClient{cc}
}

func (c *bigtableClient) ReadRows(ctx context.Context, in *ReadRowsRequest, opts ...grpc.CallOption) (Bigtable_ReadRowsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Bigtable_serviceDesc.Streams[0], c.cc, "/google.bigtable.v2.Bigtable/ReadRows", opts...)
	if err != nil {
		return nil, err
	}
	x := &bigtableReadRowsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Bigtable_ReadRowsClient interface {
	Recv() (*ReadRowsResponse, error)
	grpc.ClientStream
}

type bigtableReadRowsClient struct {
	grpc.ClientStream
}

func (x *bigtableReadRowsClient) Recv() (*ReadRowsResponse, error) {
	m := new(ReadRowsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bigtableClient) SampleRowKeys(ctx context.Context, in *SampleRowKeysRequest, opts ...grpc.CallOption) (Bigtable_SampleRowKeysClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Bigtable_serviceDesc.Streams[1], c.cc, "/google.bigtable.v2.Bigtable/SampleRowKeys", opts...)
	if err != nil {
		return nil, err
	}
	x := &bigtableSampleRowKeysClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Bigtable_SampleRowKeysClient interface {
	Recv() (*SampleRowKeysResponse, error)
	grpc.ClientStream
}

type bigtableSampleRowKeysClient struct {
	grpc.ClientStream
}

func (x *bigtableSampleRowKeysClient) Recv() (*SampleRowKeysResponse, error) {
	m := new(SampleRowKeysResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bigtableClient) MutateRow(ctx context.Context, in *MutateRowRequest, opts ...grpc.CallOption) (*MutateRowResponse, error) {
	out := new(MutateRowResponse)
	err := grpc.Invoke(ctx, "/google.bigtable.v2.Bigtable/MutateRow", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigtableClient) MutateRows(ctx context.Context, in *MutateRowsRequest, opts ...grpc.CallOption) (Bigtable_MutateRowsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Bigtable_serviceDesc.Streams[2], c.cc, "/google.bigtable.v2.Bigtable/MutateRows", opts...)
	if err != nil {
		return nil, err
	}
	x := &bigtableMutateRowsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Bigtable_MutateRowsClient interface {
	Recv() (*MutateRowsResponse, error)
	grpc.ClientStream
}

type bigtableMutateRowsClient struct {
	grpc.ClientStream
}

func (x *bigtableMutateRowsClient) Recv() (*MutateRowsResponse, error) {
	m := new(MutateRowsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bigtableClient) CheckAndMutateRow(ctx context.Context, in *CheckAndMutateRowRequest, opts ...grpc.CallOption) (*CheckAndMutateRowResponse, error) {
	out := new(CheckAndMutateRowResponse)
	err := grpc.Invoke(ctx, "/google.bigtable.v2.Bigtable/CheckAndMutateRow", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bigtableClient) ReadModifyWriteRow(ctx context.Context, in *ReadModifyWriteRowRequest, opts ...grpc.CallOption) (*ReadModifyWriteRowResponse, error) {
	out := new(ReadModifyWriteRowResponse)
	err := grpc.Invoke(ctx, "/google.bigtable.v2.Bigtable/ReadModifyWriteRow", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Bigtable service

type BigtableServer interface {
	// Streams back the contents of all requested rows in key order, optionally
	// applying the same Reader filter to each. Depending on their size,
	// rows and cells may be broken up across multiple responses, but
	// atomicity of each row will still be preserved. See the
	// ReadRowsResponse documentation for details.
	ReadRows(*ReadRowsRequest, Bigtable_ReadRowsServer) error
	// Returns a sample of row keys in the table. The returned row keys will
	// delimit contiguous sections of the table of approximately equal size,
	// which can be used to break up the data for distributed tasks like
	// mapreduces.
	SampleRowKeys(*SampleRowKeysRequest, Bigtable_SampleRowKeysServer) error
	// Mutates a row atomically. Cells already present in the row are left
	// unchanged unless explicitly changed by `mutation`.
	MutateRow(context.Context, *MutateRowRequest) (*MutateRowResponse, error)
	// Mutates multiple rows in a batch. Each individual row is mutated
	// atomically as in MutateRow, but the entire batch is not executed
	// atomically.
	MutateRows(*MutateRowsRequest, Bigtable_MutateRowsServer) error
	// Mutates a row atomically based on the output of a predicate Reader filter.
	CheckAndMutateRow(context.Context, *CheckAndMutateRowRequest) (*CheckAndMutateRowResponse, error)
	// Modifies a row atomically. The method reads the latest existing timestamp
	// and value from the specified columns and writes a new entry based on
	// pre-defined read/modify/write rules. The new value for the timestamp is the
	// greater of the existing timestamp or the current server time. The method
	// returns the new contents of all modified cells.
	ReadModifyWriteRow(context.Context, *ReadModifyWriteRowRequest) (*ReadModifyWriteRowResponse, error)
}

func RegisterBigtableServer(s *grpc.Server, srv BigtableServer) {
	s.RegisterService(&_Bigtable_serviceDesc, srv)
}

func _Bigtable_ReadRows_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRowsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BigtableServer).ReadRows(m, &bigtableReadRowsServer{stream})
}

type Bigtable_ReadRowsServer interface {
	Send(*ReadRowsResponse) error
	grpc.ServerStream
}

type bigtableReadRowsServer struct {
	grpc.ServerStream
}

func (x *bigtableReadRowsServer) Send(m *ReadRowsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Bigtable_SampleRowKeys_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SampleRowKeysRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BigtableServer).SampleRowKeys(m, &bigtableSampleRowKeysServer{stream})
}

type Bigtable_SampleRowKeysServer interface {
	Send(*SampleRowKeysResponse) error
	grpc.ServerStream
}

type bigtableSampleRowKeysServer struct {
	grpc.ServerStream
}

func (x *bigtableSampleRowKeysServer) Send(m *SampleRowKeysResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Bigtable_MutateRow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MutateRowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigtableServer).MutateRow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.bigtable.v2.Bigtable/MutateRow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigtableServer).MutateRow(ctx, req.(*MutateRowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bigtable_MutateRows_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MutateRowsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BigtableServer).MutateRows(m, &bigtableMutateRowsServer{stream})
}

type Bigtable_MutateRowsServer interface {
	Send(*MutateRowsResponse) error
	grpc.ServerStream
}

type bigtableMutateRowsServer struct {
	grpc.ServerStream
}

func (x *bigtableMutateRowsServer) Send(m *MutateRowsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Bigtable_CheckAndMutateRow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAndMutateRowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigtableServer).CheckAndMutateRow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.bigtable.v2.Bigtable/CheckAndMutateRow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigtableServer).CheckAndMutateRow(ctx, req.(*CheckAndMutateRowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bigtable_ReadModifyWriteRow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadModifyWriteRowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BigtableServer).ReadModifyWriteRow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.bigtable.v2.Bigtable/ReadModifyWriteRow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BigtableServer).ReadModifyWriteRow(ctx, req.(*ReadModifyWriteRowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Bigtable_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.bigtable.v2.Bigtable",
	HandlerType: (*BigtableServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MutateRow",
			Handler:    _Bigtable_MutateRow_Handler,
		},
		{
			MethodName: "CheckAndMutateRow",
			Handler:    _Bigtable_CheckAndMutateRow_Handler,
		},
		{
			MethodName: "ReadModifyWriteRow",
			Handler:    _Bigtable_ReadModifyWriteRow_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadRows",
			Handler:       _Bigtable_ReadRows_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SampleRowKeys",
			Handler:       _Bigtable_SampleRowKeys_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MutateRows",
			Handler:       _Bigtable_MutateRows_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "google/bigtable/v2/bigtable.proto",
}

func (m *ReadRowsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRowsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if m.Rows != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.Rows.Size()))
		n1, err := m.Rows.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Filter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.Filter.Size()))
		n2, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.RowsLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.RowsLimit))
	}
	return i, nil
}

func (m *ReadRowsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRowsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBigtable(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LastScannedRowKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.LastScannedRowKey)))
		i += copy(dAtA[i:], m.LastScannedRowKey)
	}
	return i, nil
}

func (m *ReadRowsResponse_CellChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRowsResponse_CellChunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RowKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.RowKey)))
		i += copy(dAtA[i:], m.RowKey)
	}
	if m.FamilyName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.FamilyName.Size()))
		n3, err := m.FamilyName.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Qualifier != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.Qualifier.Size()))
		n4, err := m.Qualifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.TimestampMicros != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.TimestampMicros))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.ValueSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.ValueSize))
	}
	if m.RowStatus != nil {
		nn5, err := m.RowStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *ReadRowsResponse_CellChunk_ResetRow) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x40
	i++
	if m.ResetRow {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ReadRowsResponse_CellChunk_CommitRow) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x48
	i++
	if m.CommitRow {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *SampleRowKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleRowKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	return i, nil
}

func (m *SampleRowKeysResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleRowKeysResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RowKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.RowKey)))
		i += copy(dAtA[i:], m.RowKey)
	}
	if m.OffsetBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.OffsetBytes))
	}
	return i, nil
}

func (m *MutateRowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MutateRowRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if len(m.RowKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.RowKey)))
		i += copy(dAtA[i:], m.RowKey)
	}
	if len(m.Mutations) > 0 {
		for _, msg := range m.Mutations {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBigtable(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MutateRowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MutateRowResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MutateRowsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MutateRowsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBigtable(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MutateRowsRequest_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MutateRowsRequest_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RowKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.RowKey)))
		i += copy(dAtA[i:], m.RowKey)
	}
	if len(m.Mutations) > 0 {
		for _, msg := range m.Mutations {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBigtable(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MutateRowsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MutateRowsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBigtable(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MutateRowsResponse_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MutateRowsResponse_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.Index))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.Status.Size()))
		n6, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *CheckAndMutateRowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckAndMutateRowRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if len(m.RowKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.RowKey)))
		i += copy(dAtA[i:], m.RowKey)
	}
	if len(m.TrueMutations) > 0 {
		for _, msg := range m.TrueMutations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBigtable(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FalseMutations) > 0 {
		for _, msg := range m.FalseMutations {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintBigtable(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PredicateFilter != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.PredicateFilter.Size()))
		n7, err := m.PredicateFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *CheckAndMutateRowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckAndMutateRowResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PredicateMatched {
		dAtA[i] = 0x8
		i++
		if m.PredicateMatched {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReadModifyWriteRowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadModifyWriteRowRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if len(m.RowKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(len(m.RowKey)))
		i += copy(dAtA[i:], m.RowKey)
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBigtable(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReadModifyWriteRowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadModifyWriteRowResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Row != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBigtable(dAtA, i, uint64(m.Row.Size()))
		n8, err := m.Row.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func encodeFixed64Bigtable(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Bigtable(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintBigtable(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ReadRowsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	if m.Rows != nil {
		l = m.Rows.Size()
		n += 1 + l + sovBigtable(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovBigtable(uint64(l))
	}
	if m.RowsLimit != 0 {
		n += 1 + sovBigtable(uint64(m.RowsLimit))
	}
	return n
}

func (m *ReadRowsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovBigtable(uint64(l))
		}
	}
	l = len(m.LastScannedRowKey)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	return n
}

func (m *ReadRowsResponse_CellChunk) Size() (n int) {
	var l int
	_ = l
	l = len(m.RowKey)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	if m.FamilyName != nil {
		l = m.FamilyName.Size()
		n += 1 + l + sovBigtable(uint64(l))
	}
	if m.Qualifier != nil {
		l = m.Qualifier.Size()
		n += 1 + l + sovBigtable(uint64(l))
	}
	if m.TimestampMicros != 0 {
		n += 1 + sovBigtable(uint64(m.TimestampMicros))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovBigtable(uint64(l))
		}
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	if m.ValueSize != 0 {
		n += 1 + sovBigtable(uint64(m.ValueSize))
	}
	if m.RowStatus != nil {
		n += m.RowStatus.Size()
	}
	return n
}

func (m *ReadRowsResponse_CellChunk_ResetRow) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *ReadRowsResponse_CellChunk_CommitRow) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *SampleRowKeysRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	return n
}

func (m *SampleRowKeysResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.RowKey)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	if m.OffsetBytes != 0 {
		n += 1 + sovBigtable(uint64(m.OffsetBytes))
	}
	return n
}

func (m *MutateRowRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	l = len(m.RowKey)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovBigtable(uint64(l))
		}
	}
	return n
}

func (m *MutateRowResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MutateRowsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovBigtable(uint64(l))
		}
	}
	return n
}

func (m *MutateRowsRequest_Entry) Size() (n int) {
	var l int
	_ = l
	l = len(m.RowKey)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovBigtable(uint64(l))
		}
	}
	return n
}

func (m *MutateRowsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovBigtable(uint64(l))
		}
	}
	return n
}

func (m *MutateRowsResponse_Entry) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovBigtable(uint64(m.Index))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBigtable(uint64(l))
	}
	return n
}

func (m *CheckAndMutateRowRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	l = len(m.RowKey)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	if len(m.TrueMutations) > 0 {
		for _, e := range m.TrueMutations {
			l = e.Size()
			n += 1 + l + sovBigtable(uint64(l))
		}
	}
	if len(m.FalseMutations) > 0 {
		for _, e := range m.FalseMutations {
			l = e.Size()
			n += 1 + l + sovBigtable(uint64(l))
		}
	}
	if m.PredicateFilter != nil {
		l = m.PredicateFilter.Size()
		n += 1 + l + sovBigtable(uint64(l))
	}
	return n
}

func (m *CheckAndMutateRowResponse) Size() (n int) {
	var l int
	_ = l
	if m.PredicateMatched {
		n += 2
	}
	return n
}

func (m *ReadModifyWriteRowRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	l = len(m.RowKey)
	if l > 0 {
		n += 1 + l + sovBigtable(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovBigtable(uint64(l))
		}
	}
	return n
}

func (m *ReadModifyWriteRowResponse) Size() (n int) {
	var l int
	_ = l
	if m.Row != nil {
		l = m.Row.Size()
		n += 1 + l + sovBigtable(uint64(l))
	}
	return n
}

func sovBigtable(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBigtable(x uint64) (n int) {
	return sovBigtable(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReadRowsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRowsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRowsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rows == nil {
				m.Rows = &RowSet{}
			}
			if err := m.Rows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &RowFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsLimit", wireType)
			}
			m.RowsLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRowsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &ReadRowsResponse_CellChunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastScannedRowKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastScannedRowKey = append(m.LastScannedRowKey[:0], dAtA[iNdEx:postIndex]...)
			if m.LastScannedRowKey == nil {
				m.LastScannedRowKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRowsResponse_CellChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowKey = append(m.RowKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RowKey == nil {
				m.RowKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FamilyName == nil {
				m.FamilyName = &google_protobuf1.StringValue{}
			}
			if err := m.FamilyName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qualifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qualifier == nil {
				m.Qualifier = &google_protobuf1.BytesValue{}
			}
			if err := m.Qualifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicros", wireType)
			}
			m.TimestampMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueSize", wireType)
			}
			m.ValueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValueSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetRow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RowStatus = &ReadRowsResponse_CellChunk_ResetRow{b}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitRow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RowStatus = &ReadRowsResponse_CellChunk_CommitRow{b}
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleRowKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleRowKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleRowKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleRowKeysResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleRowKeysResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleRowKeysResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowKey = append(m.RowKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RowKey == nil {
				m.RowKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetBytes", wireType)
			}
			m.OffsetBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MutateRowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MutateRowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MutateRowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowKey = append(m.RowKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RowKey == nil {
				m.RowKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, &Mutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MutateRowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MutateRowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MutateRowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MutateRowsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MutateRowsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MutateRowsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &MutateRowsRequest_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MutateRowsRequest_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowKey = append(m.RowKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RowKey == nil {
				m.RowKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, &Mutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MutateRowsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MutateRowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MutateRowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &MutateRowsResponse_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MutateRowsResponse_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &google_rpc.Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckAndMutateRowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckAndMutateRowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckAndMutateRowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowKey = append(m.RowKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RowKey == nil {
				m.RowKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrueMutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrueMutations = append(m.TrueMutations, &Mutation{})
			if err := m.TrueMutations[len(m.TrueMutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FalseMutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FalseMutations = append(m.FalseMutations, &Mutation{})
			if err := m.FalseMutations[len(m.FalseMutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PredicateFilter == nil {
				m.PredicateFilter = &RowFilter{}
			}
			if err := m.PredicateFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckAndMutateRowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckAndMutateRowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckAndMutateRowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateMatched", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PredicateMatched = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadModifyWriteRowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadModifyWriteRowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadModifyWriteRowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowKey = append(m.RowKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RowKey == nil {
				m.RowKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &ReadModifyWriteRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadModifyWriteRowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadModifyWriteRowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadModifyWriteRowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Row", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBigtable
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Row == nil {
				m.Row = &Row{}
			}
			if err := m.Row.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBigtable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBigtable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBigtable(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBigtable
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBigtable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBigtable
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBigtable
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBigtable(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBigtable = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBigtable   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/bigtable/v2/bigtable.proto", fileDescriptorBigtable) }

var fileDescriptorBigtable = []byte{
	// 1171 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xff, 0x8e, 0x5d, 0xbb, 0xde, 0x97, 0xb6, 0x49, 0xe6, 0x1b, 0x9a, 0xad, 0x49, 0x82, 0xbb,
	0xb4, 0xe0, 0xb8, 0x74, 0x5d, 0x19, 0xf5, 0x50, 0x57, 0x29, 0x60, 0x93, 0x1f, 0x08, 0x5c, 0x55,
	0x63, 0xa9, 0x48, 0x08, 0xc9, 0x1a, 0xaf, 0xc7, 0xce, 0x92, 0xfd, 0xd5, 0xdd, 0xd9, 0x18, 0x17,
	0x71, 0xe1, 0xc0, 0x89, 0x13, 0x9c, 0x11, 0x27, 0x04, 0x42, 0x82, 0x23, 0x57, 0x0e, 0x5c, 0x38,
	0x22, 0x71, 0xe0, 0x8a, 0xa2, 0xfe, 0x05, 0xfc, 0x05, 0x68, 0x67, 0x67, 0x6d, 0x27, 0xb1, 0xdb,
	0x4d, 0xd5, 0xdb, 0xee, 0x7b, 0xef, 0xf3, 0xe6, 0xf3, 0x3e, 0xf3, 0xde, 0x5b, 0x1b, 0xae, 0x0e,
	0x5c, 0x77, 0x60, 0xb1, 0x6a, 0xd7, 0x1c, 0x70, 0xda, 0xb5, 0x58, 0xf5, 0xb0, 0x36, 0x7e, 0xd6,
	0x3d, 0xdf, 0xe5, 0x2e, 0xc6, 0x71, 0x88, 0x3e, 0x36, 0x1f, 0xd6, 0x8a, 0x6b, 0x12, 0x46, 0x3d,
	0xb3, 0x4a, 0x1d, 0xc7, 0xe5, 0x94, 0x9b, 0xae, 0x13, 0xc4, 0x88, 0xe2, 0xfa, 0x8c, 0xa4, 0x3d,
	0xca, 0xa9, 0x74, 0x6f, 0x48, 0xb7, 0x78, 0xeb, 0x86, 0xfd, 0xea, 0xd0, 0xa7, 0x9e, 0xc7, 0xfc,
	0x04, 0xbe, 0x2a, 0xfd, 0xbe, 0x67, 0x54, 0x03, 0x4e, 0x79, 0x28, 0x1d, 0xda, 0xaf, 0x08, 0x16,
	0x09, 0xa3, 0x3d, 0xe2, 0x0e, 0x03, 0xc2, 0x1e, 0x85, 0x2c, 0xe0, 0x78, 0x1d, 0x40, 0x9c, 0xd1,
	0x71, 0xa8, 0xcd, 0x54, 0x54, 0x42, 0x65, 0x85, 0x28, 0xc2, 0x72, 0x9f, 0xda, 0x0c, 0xeb, 0x70,
	0xce, 0x77, 0x87, 0x81, 0x9a, 0x29, 0xa1, 0xf2, 0x42, 0xad, 0xa8, 0x9f, 0xae, 0x45, 0x27, 0xee,
	0xb0, 0xcd, 0x38, 0x11, 0x71, 0xf8, 0x36, 0xe4, 0xfb, 0xa6, 0xc5, 0x99, 0xaf, 0x66, 0x05, 0x62,
	0x7d, 0x0e, 0x62, 0x47, 0x04, 0x11, 0x19, 0x1c, 0xb1, 0x88, 0xe0, 0x1d, 0xcb, 0xb4, 0x4d, 0xae,
	0x9e, 0x2b, 0xa1, 0x72, 0x96, 0x28, 0x91, 0xe5, 0x83, 0xc8, 0xa0, 0xfd, 0x9b, 0x85, 0xa5, 0x09,
	0xf1, 0xc0, 0x73, 0x9d, 0x80, 0xe1, 0x1d, 0xc8, 0x1b, 0xfb, 0xa1, 0x73, 0x10, 0xa8, 0xa8, 0x94,
	0x2d, 0x2f, 0xd4, 0xf4, 0x99, 0x47, 0x9d, 0x40, 0xe9, 0x4d, 0x66, 0x59, 0xcd, 0x08, 0x46, 0x24,
	0x1a, 0x57, 0x61, 0xc5, 0xa2, 0x01, 0xef, 0x04, 0x06, 0x75, 0x1c, 0xd6, 0xeb, 0xf8, 0xee, 0xb0,
	0x73, 0xc0, 0x46, 0xa2, 0xe4, 0x0b, 0x64, 0x39, 0xf2, 0xb5, 0x63, 0x17, 0x71, 0x87, 0xef, 0xb3,
	0x51, 0xf1, 0x49, 0x06, 0x94, 0x71, 0x1a, 0xbc, 0x0a, 0xe7, 0x13, 0x04, 0x12, 0x88, 0xbc, 0x2f,
	0xc2, 0xf0, 0x16, 0x2c, 0xf4, 0xa9, 0x6d, 0x5a, 0xa3, 0x58, 0xda, 0x58, 0xc1, 0xb5, 0x84, 0x64,
	0x72, 0x79, 0x7a, 0x9b, 0xfb, 0xa6, 0x33, 0x78, 0x48, 0xad, 0x90, 0x11, 0x88, 0x01, 0x42, 0xf9,
	0x3b, 0xa0, 0x3c, 0x0a, 0xa9, 0x65, 0xf6, 0xcd, 0xb1, 0x98, 0x2f, 0x9f, 0x02, 0x37, 0x46, 0x9c,
	0x05, 0x31, 0x76, 0x12, 0x8d, 0x37, 0x61, 0x89, 0x9b, 0x36, 0x0b, 0x38, 0xb5, 0xbd, 0x8e, 0x6d,
	0x1a, 0xbe, 0x1b, 0x48, 0x4d, 0x17, 0xc7, 0xf6, 0x96, 0x30, 0xe3, 0xcb, 0x90, 0xb7, 0x68, 0x97,
	0x59, 0x81, 0x9a, 0x2b, 0x65, 0xcb, 0x0a, 0x91, 0x6f, 0x78, 0x05, 0x72, 0x87, 0x51, 0x5a, 0x35,
	0x2f, 0x6a, 0x8a, 0x5f, 0xa2, 0x6b, 0x12, 0x0f, 0x9d, 0xc0, 0x7c, 0xcc, 0xd4, 0xf3, 0x25, 0x54,
	0xce, 0x11, 0x45, 0x58, 0xda, 0xe6, 0xe3, 0xc8, 0xad, 0xf8, 0x2c, 0x60, 0x3c, 0x92, 0x50, 0x2d,
	0x94, 0x50, 0xb9, 0xb0, 0xf7, 0x3f, 0x52, 0x10, 0x26, 0xe2, 0x0e, 0xf1, 0x2b, 0x00, 0x86, 0x6b,
	0xdb, 0x66, 0xec, 0x57, 0xa4, 0x5f, 0x89, 0x6d, 0xc4, 0x1d, 0x36, 0x2e, 0x88, 0x2e, 0xe8, 0xc4,
	0x3d, 0xab, 0xdd, 0x86, 0x95, 0x36, 0xb5, 0x3d, 0x8b, 0xc5, 0xb2, 0xa7, 0xec, 0x58, 0xad, 0x0d,
	0x2f, 0x9d, 0x80, 0xc9, 0x7e, 0x99, 0x7b, 0x51, 0x57, 0xe1, 0x82, 0xdb, 0xef, 0x47, 0xbc, 0xbb,
	0x91, 0x9c, 0xe2, 0xa6, 0xb2, 0x64, 0x21, 0xb6, 0x09, 0x85, 0xb5, 0x2f, 0x11, 0x2c, 0xb5, 0x42,
	0x4e, 0x79, 0x94, 0x35, 0xe5, 0xe8, 0x4c, 0x9d, 0x97, 0x39, 0x76, 0x5e, 0x1d, 0x14, 0x3b, 0x94,
	0x13, 0xaf, 0x66, 0x45, 0xef, 0xae, 0xcd, 0xea, 0xdd, 0x96, 0x0c, 0x22, 0x93, 0x70, 0xed, 0xff,
	0xb0, 0x3c, 0xc5, 0x23, 0xae, 0x4c, 0xfb, 0x1b, 0x4d, 0x59, 0xd3, 0x4e, 0xf6, 0x36, 0x9c, 0x67,
	0x0e, 0xf7, 0x4d, 0x51, 0x70, 0xc4, 0xe1, 0xc6, 0x5c, 0x0e, 0xd3, 0x69, 0xf5, 0x6d, 0x87, 0xfb,
	0x23, 0x92, 0x60, 0x8b, 0x1f, 0x43, 0x4e, 0x58, 0xe6, 0xcb, 0x7b, 0xac, 0xdc, 0xcc, 0xd9, 0xca,
	0xfd, 0x01, 0x01, 0x9e, 0xa6, 0x30, 0x1e, 0xfd, 0x31, 0xf7, 0x78, 0xf6, 0xdf, 0x78, 0x16, 0x77,
	0x39, 0xfd, 0x27, 0xc8, 0xbf, 0x97, 0x90, 0x5f, 0x81, 0x9c, 0xe9, 0xf4, 0xd8, 0xa7, 0x82, 0x7a,
	0x96, 0xc4, 0x2f, 0xb8, 0x02, 0xf9, 0xb8, 0x17, 0xe5, 0xf0, 0xe2, 0xe4, 0x14, 0xdf, 0x33, 0xf4,
	0xb6, 0xf0, 0x10, 0x19, 0xa1, 0xfd, 0x98, 0x01, 0xb5, 0xb9, 0xcf, 0x8c, 0x83, 0x77, 0x9c, 0xde,
	0x0b, 0xeb, 0x94, 0x26, 0x5c, 0xe2, 0x7e, 0xc8, 0x3a, 0x13, 0xfd, 0xce, 0xa5, 0xd0, 0xef, 0x62,
	0x84, 0x49, 0xde, 0x02, 0xbc, 0x0d, 0x8b, 0x7d, 0x6a, 0x05, 0xd3, 0x59, 0x72, 0x29, 0xb2, 0x5c,
	0x12, 0xa0, 0x49, 0x9a, 0x3d, 0x58, 0xf2, 0x7c, 0xd6, 0x33, 0x0d, 0xca, 0x59, 0x47, 0xee, 0xf8,
	0x7c, 0x9a, 0x1d, 0xbf, 0x38, 0x86, 0xc5, 0x06, 0x6d, 0x0f, 0xae, 0xcc, 0x50, 0x4a, 0x5e, 0xed,
	0x0d, 0x58, 0x9e, 0x1c, 0x63, 0x53, 0x6e, 0xec, 0xb3, 0x9e, 0x50, 0xac, 0x40, 0x26, 0xe7, 0xb7,
	0x62, 0xbb, 0xf6, 0x35, 0x82, 0x2b, 0xd1, 0x86, 0x6f, 0xb9, 0x3d, 0xb3, 0x3f, 0xfa, 0xd0, 0x37,
	0x5f, 0x88, 0xea, 0x5b, 0x90, 0xf3, 0x43, 0x8b, 0x25, 0xb3, 0xf9, 0xfa, 0xbc, 0xef, 0xca, 0xf4,
	0xa9, 0xa1, 0xc5, 0x48, 0x8c, 0xd2, 0x76, 0xa1, 0x38, 0x8b, 0x93, 0xac, 0x6f, 0x13, 0xb2, 0xd1,
	0xf6, 0x43, 0x42, 0xb9, 0xd5, 0x39, 0xca, 0x91, 0x28, 0xa6, 0xf6, 0x73, 0x01, 0x0a, 0x0d, 0xe9,
	0xc0, 0xdf, 0x22, 0x28, 0x24, 0x1f, 0x33, 0xfc, 0xea, 0xd3, 0x3f, 0x75, 0xa2, 0xfc, 0xe2, 0xb5,
	0x34, 0xdf, 0x43, 0xed, 0xdd, 0x2f, 0xfe, 0x7a, 0xf2, 0x4d, 0xe6, 0x9e, 0x76, 0x27, 0xfa, 0x91,
	0xf1, 0xd9, 0x44, 0xaf, 0x2d, 0xcf, 0x77, 0x3f, 0x61, 0x06, 0x0f, 0xaa, 0x95, 0xaa, 0xe9, 0x04,
	0x9c, 0x3a, 0x06, 0x8b, 0x9e, 0x45, 0x44, 0x50, 0xad, 0x7c, 0x5e, 0xf7, 0x65, 0xaa, 0x3a, 0xaa,
	0xdc, 0x42, 0xf8, 0x17, 0x04, 0x17, 0x8f, 0xed, 0x5d, 0x5c, 0x9e, 0x75, 0xfe, 0xac, 0x8d, 0x5e,
	0xdc, 0x4c, 0x11, 0x29, 0xe9, 0xee, 0x08, 0xba, 0x6f, 0xe3, 0x7b, 0x67, 0xa6, 0x1b, 0x4c, 0xe7,
	0xbb, 0x85, 0xf0, 0x77, 0x08, 0x94, 0x71, 0xfb, 0xe1, 0x6b, 0x4f, 0x5d, 0x20, 0x09, 0xd1, 0xeb,
	0xcf, 0x88, 0x92, 0x24, 0xb7, 0x05, 0xc9, 0xb7, 0xb4, 0xfa, 0x99, 0x49, 0xda, 0x49, 0xae, 0x3a,
	0xaa, 0xe0, 0xef, 0x11, 0xc0, 0x64, 0x87, 0xe1, 0xeb, 0xa9, 0xf6, 0x73, 0xf1, 0xb5, 0x74, 0xab,
	0x30, 0x51, 0x52, 0xbb, 0xfb, 0xfc, 0x24, 0xe5, 0xd5, 0xff, 0x86, 0x60, 0xf9, 0xd4, 0x40, 0xe3,
	0x99, 0x2b, 0x79, 0xde, 0x86, 0x2c, 0xde, 0x4c, 0x19, 0x2d, 0xc9, 0xb7, 0x04, 0xf9, 0x5d, 0xad,
	0x71, 0x66, 0xf2, 0xc6, 0xc9, 0x9c, 0x91, 0xd2, 0xbf, 0x23, 0xc0, 0xa7, 0x67, 0x16, 0xdf, 0x4c,
	0x33, 0xf9, 0x93, 0x1a, 0xf4, 0xb4, 0xe1, 0xb2, 0x88, 0xfb, 0xa2, 0x88, 0x3d, 0xad, 0xf9, 0x5c,
	0xa3, 0x77, 0x3c, 0x69, 0x1d, 0x55, 0x1a, 0x5f, 0xa1, 0x3f, 0x8e, 0x36, 0xd0, 0x9f, 0x47, 0x1b,
	0xe8, 0x9f, 0xa3, 0x0d, 0x04, 0x97, 0x0d, 0xd7, 0x9e, 0xc1, 0xa8, 0x71, 0x31, 0xd9, 0x29, 0x0f,
	0xa2, 0x5f, 0x91, 0x0f, 0xd0, 0x47, 0x75, 0x19, 0x34, 0x70, 0x2d, 0xea, 0x0c, 0x74, 0xd7, 0x1f,
	0x54, 0x07, 0xcc, 0x11, 0xbf, 0x31, 0xab, 0xb1, 0x8b, 0x7a, 0x66, 0x30, 0xfd, 0x6f, 0xe4, 0x6e,
	0xf2, 0xfc, 0x53, 0x46, 0xdd, 0x8d, 0xc1, 0x4d, 0xcb, 0x0d, 0x7b, 0x7a, 0x92, 0x5a, 0x7f, 0x58,
	0xeb, 0xe6, 0x45, 0x86, 0x37, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x7d, 0xc8, 0xbc, 0xa6, 0x23,
	0x0d, 0x00, 0x00,
}
