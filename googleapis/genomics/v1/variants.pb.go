// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/genomics/v1/variants.proto

package genomics

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_longrunning "google.golang.org/genproto/googleapis/longrunning"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "google.golang.org/genproto/protobuf/field_mask"
import google_protobuf3 "github.com/gogo/protobuf/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Operations to be performed during import on Variant info fields.
// These operations are set for each info field in the info_merge_config
// map of ImportVariantsRequest, which is plumbed down to the
// MergeVariantRequests generated by the import job.
type InfoMergeOperation int32

const (
	InfoMergeOperation_INFO_MERGE_OPERATION_UNSPECIFIED InfoMergeOperation = 0
	// By default, Variant info fields are persisted if the Variant doesn't
	// already exist in the variantset.  If the Variant is equivalent to a
	// Variant already in the variantset, the incoming Variant's info field
	// is ignored in favor of that of the already persisted Variant.
	InfoMergeOperation_IGNORE_NEW InfoMergeOperation = 1
	// This operation removes an info field from the incoming Variant
	// and persists this info field in each of the incoming Variant's Calls.
	InfoMergeOperation_MOVE_TO_CALLS InfoMergeOperation = 2
)

var InfoMergeOperation_name = map[int32]string{
	0: "INFO_MERGE_OPERATION_UNSPECIFIED",
	1: "IGNORE_NEW",
	2: "MOVE_TO_CALLS",
}
var InfoMergeOperation_value = map[string]int32{
	"INFO_MERGE_OPERATION_UNSPECIFIED": 0,
	"IGNORE_NEW":                       1,
	"MOVE_TO_CALLS":                    2,
}

func (x InfoMergeOperation) String() string {
	return proto.EnumName(InfoMergeOperation_name, int32(x))
}
func (InfoMergeOperation) EnumDescriptor() ([]byte, []int) { return fileDescriptorVariants, []int{0} }

type VariantSetMetadata_Type int32

const (
	VariantSetMetadata_TYPE_UNSPECIFIED VariantSetMetadata_Type = 0
	VariantSetMetadata_INTEGER          VariantSetMetadata_Type = 1
	VariantSetMetadata_FLOAT            VariantSetMetadata_Type = 2
	VariantSetMetadata_FLAG             VariantSetMetadata_Type = 3
	VariantSetMetadata_CHARACTER        VariantSetMetadata_Type = 4
	VariantSetMetadata_STRING           VariantSetMetadata_Type = 5
)

var VariantSetMetadata_Type_name = map[int32]string{
	0: "TYPE_UNSPECIFIED",
	1: "INTEGER",
	2: "FLOAT",
	3: "FLAG",
	4: "CHARACTER",
	5: "STRING",
}
var VariantSetMetadata_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED": 0,
	"INTEGER":          1,
	"FLOAT":            2,
	"FLAG":             3,
	"CHARACTER":        4,
	"STRING":           5,
}

func (x VariantSetMetadata_Type) String() string {
	return proto.EnumName(VariantSetMetadata_Type_name, int32(x))
}
func (VariantSetMetadata_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorVariants, []int{0, 0}
}

type ImportVariantsRequest_Format int32

const (
	ImportVariantsRequest_FORMAT_UNSPECIFIED ImportVariantsRequest_Format = 0
	// VCF (Variant Call Format). The VCF files may be gzip compressed. gVCF is
	// also supported.
	ImportVariantsRequest_FORMAT_VCF ImportVariantsRequest_Format = 1
	// Complete Genomics masterVarBeta format. The masterVarBeta files may
	// be bzip2 compressed.
	ImportVariantsRequest_FORMAT_COMPLETE_GENOMICS ImportVariantsRequest_Format = 2
)

var ImportVariantsRequest_Format_name = map[int32]string{
	0: "FORMAT_UNSPECIFIED",
	1: "FORMAT_VCF",
	2: "FORMAT_COMPLETE_GENOMICS",
}
var ImportVariantsRequest_Format_value = map[string]int32{
	"FORMAT_UNSPECIFIED":       0,
	"FORMAT_VCF":               1,
	"FORMAT_COMPLETE_GENOMICS": 2,
}

func (x ImportVariantsRequest_Format) String() string {
	return proto.EnumName(ImportVariantsRequest_Format_name, int32(x))
}
func (ImportVariantsRequest_Format) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorVariants, []int{6, 0}
}

type ExportVariantSetRequest_Format int32

const (
	ExportVariantSetRequest_FORMAT_UNSPECIFIED ExportVariantSetRequest_Format = 0
	// Export the data to Google BigQuery.
	ExportVariantSetRequest_FORMAT_BIGQUERY ExportVariantSetRequest_Format = 1
)

var ExportVariantSetRequest_Format_name = map[int32]string{
	0: "FORMAT_UNSPECIFIED",
	1: "FORMAT_BIGQUERY",
}
var ExportVariantSetRequest_Format_value = map[string]int32{
	"FORMAT_UNSPECIFIED": 0,
	"FORMAT_BIGQUERY":    1,
}

func (x ExportVariantSetRequest_Format) String() string {
	return proto.EnumName(ExportVariantSetRequest_Format_name, int32(x))
}
func (ExportVariantSetRequest_Format) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorVariants, []int{9, 0}
}

// Metadata describes a single piece of variant call metadata.
// These data include a top level key and either a single value string (value)
// or a list of key-value pairs (info.)
// Value and info are mutually exclusive.
type VariantSetMetadata struct {
	// The top-level key.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The value field for simple metadata
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// User-provided ID field, not enforced by this API.
	// Two or more pieces of structured metadata with identical
	// id and key fields are considered equivalent.
	Id string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	// The type of data. Possible types include: Integer, Float,
	// Flag, Character, and String.
	Type VariantSetMetadata_Type `protobuf:"varint,5,opt,name=type,proto3,enum=google.genomics.v1.VariantSetMetadata_Type" json:"type,omitempty"`
	// The number of values that can be included in a field described by this
	// metadata.
	Number string `protobuf:"bytes,8,opt,name=number,proto3" json:"number,omitempty"`
	// A textual description of this metadata.
	Description string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	// Remaining structured metadata key-value pairs. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,3,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VariantSetMetadata) Reset()                    { *m = VariantSetMetadata{} }
func (m *VariantSetMetadata) String() string            { return proto.CompactTextString(m) }
func (*VariantSetMetadata) ProtoMessage()               {}
func (*VariantSetMetadata) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{0} }

func (m *VariantSetMetadata) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *VariantSetMetadata) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *VariantSetMetadata) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VariantSetMetadata) GetType() VariantSetMetadata_Type {
	if m != nil {
		return m.Type
	}
	return VariantSetMetadata_TYPE_UNSPECIFIED
}

func (m *VariantSetMetadata) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *VariantSetMetadata) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *VariantSetMetadata) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

// A variant set is a collection of call sets and variants. It contains summary
// statistics of those contents. A variant set belongs to a dataset.
//
// For more genomics resource definitions, see [Fundamentals of Google
// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
type VariantSet struct {
	// The dataset to which this variant set belongs.
	DatasetId string `protobuf:"bytes,1,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
	// The server-generated variant set ID, unique across all variant sets.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// The reference set to which the variant set is mapped. The reference set
	// describes the alignment provenance of the variant set, while the
	// `referenceBounds` describe the shape of the actual variant data. The
	// reference set's reference names are a superset of those found in the
	// `referenceBounds`.
	//
	// For example, given a variant set that is mapped to the GRCh38 reference set
	// and contains a single variant on reference 'X', `referenceBounds` would
	// contain only an entry for 'X', while the associated reference set
	// enumerates all possible references: '1', '2', 'X', 'Y', 'MT', etc.
	ReferenceSetId string `protobuf:"bytes,6,opt,name=reference_set_id,json=referenceSetId,proto3" json:"reference_set_id,omitempty"`
	// A list of all references used by the variants in a variant set
	// with associated coordinate upper bounds for each one.
	ReferenceBounds []*ReferenceBound `protobuf:"bytes,5,rep,name=reference_bounds,json=referenceBounds" json:"reference_bounds,omitempty"`
	// The metadata associated with this variant set.
	Metadata []*VariantSetMetadata `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty"`
	// User-specified, mutable name.
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	// A textual description of this variant set.
	Description string `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *VariantSet) Reset()                    { *m = VariantSet{} }
func (m *VariantSet) String() string            { return proto.CompactTextString(m) }
func (*VariantSet) ProtoMessage()               {}
func (*VariantSet) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{1} }

func (m *VariantSet) GetDatasetId() string {
	if m != nil {
		return m.DatasetId
	}
	return ""
}

func (m *VariantSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VariantSet) GetReferenceSetId() string {
	if m != nil {
		return m.ReferenceSetId
	}
	return ""
}

func (m *VariantSet) GetReferenceBounds() []*ReferenceBound {
	if m != nil {
		return m.ReferenceBounds
	}
	return nil
}

func (m *VariantSet) GetMetadata() []*VariantSetMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *VariantSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VariantSet) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// A variant represents a change in DNA sequence relative to a reference
// sequence. For example, a variant could represent a SNP or an insertion.
// Variants belong to a variant set.
//
// For more genomics resource definitions, see [Fundamentals of Google
// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
//
// Each of the calls on a variant represent a determination of genotype with
// respect to that variant. For example, a call might assign probability of 0.32
// to the occurrence of a SNP named rs1234 in a sample named NA12345. A call
// belongs to a call set, which contains related calls typically from one
// sample.
type Variant struct {
	// The ID of the variant set this variant belongs to.
	VariantSetId string `protobuf:"bytes,15,opt,name=variant_set_id,json=variantSetId,proto3" json:"variant_set_id,omitempty"`
	// The server-generated variant ID, unique across all variants.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Names for the variant, for example a RefSNP ID.
	Names []string `protobuf:"bytes,3,rep,name=names" json:"names,omitempty"`
	// The date this variant was created, in milliseconds from the epoch.
	Created int64 `protobuf:"varint,12,opt,name=created,proto3" json:"created,omitempty"`
	// The reference on which this variant occurs.
	// (such as `chr20` or `X`)
	ReferenceName string `protobuf:"bytes,14,opt,name=reference_name,json=referenceName,proto3" json:"reference_name,omitempty"`
	// The position at which this variant occurs (0-based).
	// This corresponds to the first base of the string of reference bases.
	Start int64 `protobuf:"varint,16,opt,name=start,proto3" json:"start,omitempty"`
	// The end position (0-based) of this variant. This corresponds to the first
	// base after the last base in the reference allele. So, the length of
	// the reference allele is (end - start). This is useful for variants
	// that don't explicitly give alternate bases, for example large deletions.
	End int64 `protobuf:"varint,13,opt,name=end,proto3" json:"end,omitempty"`
	// The reference bases for this variant. They start at the given
	// position.
	ReferenceBases string `protobuf:"bytes,6,opt,name=reference_bases,json=referenceBases,proto3" json:"reference_bases,omitempty"`
	// The bases that appear instead of the reference bases.
	AlternateBases []string `protobuf:"bytes,7,rep,name=alternate_bases,json=alternateBases" json:"alternate_bases,omitempty"`
	// A measure of how likely this variant is to be real.
	// A higher value is better.
	Quality float64 `protobuf:"fixed64,8,opt,name=quality,proto3" json:"quality,omitempty"`
	// A list of filters (normally quality filters) this variant has failed.
	// `PASS` indicates this variant has passed all filters.
	Filter []string `protobuf:"bytes,9,rep,name=filter" json:"filter,omitempty"`
	// A map of additional variant information. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,10,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// The variant calls for this particular variant. Each one represents the
	// determination of genotype with respect to this variant.
	Calls []*VariantCall `protobuf:"bytes,11,rep,name=calls" json:"calls,omitempty"`
}

func (m *Variant) Reset()                    { *m = Variant{} }
func (m *Variant) String() string            { return proto.CompactTextString(m) }
func (*Variant) ProtoMessage()               {}
func (*Variant) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{2} }

func (m *Variant) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *Variant) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Variant) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *Variant) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Variant) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *Variant) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Variant) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Variant) GetReferenceBases() string {
	if m != nil {
		return m.ReferenceBases
	}
	return ""
}

func (m *Variant) GetAlternateBases() []string {
	if m != nil {
		return m.AlternateBases
	}
	return nil
}

func (m *Variant) GetQuality() float64 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *Variant) GetFilter() []string {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *Variant) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Variant) GetCalls() []*VariantCall {
	if m != nil {
		return m.Calls
	}
	return nil
}

// A call represents the determination of genotype with respect to a particular
// variant. It may include associated information such as quality and phasing.
// For example, a call might assign a probability of 0.32 to the occurrence of
// a SNP named rs1234 in a call set with the name NA12345.
type VariantCall struct {
	// The ID of the call set this variant call belongs to.
	CallSetId string `protobuf:"bytes,8,opt,name=call_set_id,json=callSetId,proto3" json:"call_set_id,omitempty"`
	// The name of the call set this variant call belongs to.
	CallSetName string `protobuf:"bytes,9,opt,name=call_set_name,json=callSetName,proto3" json:"call_set_name,omitempty"`
	// The genotype of this variant call. Each value represents either the value
	// of the `referenceBases` field or a 1-based index into
	// `alternateBases`. If a variant had a `referenceBases`
	// value of `T` and an `alternateBases`
	// value of `["A", "C"]`, and the `genotype` was
	// `[2, 1]`, that would mean the call
	// represented the heterozygous value `CA` for this variant.
	// If the `genotype` was instead `[0, 1]`, the
	// represented value would be `TA`. Ordering of the
	// genotype values is important if the `phaseset` is present.
	// If a genotype is not called (that is, a `.` is present in the
	// GT string) -1 is returned.
	Genotype []int32 `protobuf:"varint,7,rep,packed,name=genotype" json:"genotype,omitempty"`
	// If this field is present, this variant call's genotype ordering implies
	// the phase of the bases and is consistent with any other variant calls in
	// the same reference sequence which have the same phaseset value.
	// When importing data from VCF, if the genotype data was phased but no
	// phase set was specified this field will be set to `*`.
	Phaseset string `protobuf:"bytes,5,opt,name=phaseset,proto3" json:"phaseset,omitempty"`
	// The genotype likelihoods for this variant call. Each array entry
	// represents how likely a specific genotype is for this call. The value
	// ordering is defined by the GL tag in the VCF spec.
	// If Phred-scaled genotype likelihood scores (PL) are available and
	// log10(P) genotype likelihood scores (GL) are not, PL scores are converted
	// to GL scores.  If both are available, PL scores are stored in `info`.
	GenotypeLikelihood []float64 `protobuf:"fixed64,6,rep,packed,name=genotype_likelihood,json=genotypeLikelihood" json:"genotype_likelihood,omitempty"`
	// A map of additional variant call information. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,2,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VariantCall) Reset()                    { *m = VariantCall{} }
func (m *VariantCall) String() string            { return proto.CompactTextString(m) }
func (*VariantCall) ProtoMessage()               {}
func (*VariantCall) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{3} }

func (m *VariantCall) GetCallSetId() string {
	if m != nil {
		return m.CallSetId
	}
	return ""
}

func (m *VariantCall) GetCallSetName() string {
	if m != nil {
		return m.CallSetName
	}
	return ""
}

func (m *VariantCall) GetGenotype() []int32 {
	if m != nil {
		return m.Genotype
	}
	return nil
}

func (m *VariantCall) GetPhaseset() string {
	if m != nil {
		return m.Phaseset
	}
	return ""
}

func (m *VariantCall) GetGenotypeLikelihood() []float64 {
	if m != nil {
		return m.GenotypeLikelihood
	}
	return nil
}

func (m *VariantCall) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

// A call set is a collection of variant calls, typically for one sample. It
// belongs to a variant set.
//
// For more genomics resource definitions, see [Fundamentals of Google
// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
type CallSet struct {
	// The server-generated call set ID, unique across all call sets.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The call set name.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The sample ID this call set corresponds to.
	SampleId string `protobuf:"bytes,7,opt,name=sample_id,json=sampleId,proto3" json:"sample_id,omitempty"`
	// The IDs of the variant sets this call set belongs to. This field must
	// have exactly length one, as a call set belongs to a single variant set.
	// This field is repeated for compatibility with the
	// [GA4GH 0.5.1
	// API](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variants.avdl#L76).
	VariantSetIds []string `protobuf:"bytes,6,rep,name=variant_set_ids,json=variantSetIds" json:"variant_set_ids,omitempty"`
	// The date this call set was created in milliseconds from the epoch.
	Created int64 `protobuf:"varint,5,opt,name=created,proto3" json:"created,omitempty"`
	// A map of additional call set information. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,4,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CallSet) Reset()                    { *m = CallSet{} }
func (m *CallSet) String() string            { return proto.CompactTextString(m) }
func (*CallSet) ProtoMessage()               {}
func (*CallSet) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{4} }

func (m *CallSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CallSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CallSet) GetSampleId() string {
	if m != nil {
		return m.SampleId
	}
	return ""
}

func (m *CallSet) GetVariantSetIds() []string {
	if m != nil {
		return m.VariantSetIds
	}
	return nil
}

func (m *CallSet) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *CallSet) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

// ReferenceBound records an upper bound for the starting coordinate of
// variants in a particular reference.
type ReferenceBound struct {
	// The name of the reference associated with this reference bound.
	ReferenceName string `protobuf:"bytes,1,opt,name=reference_name,json=referenceName,proto3" json:"reference_name,omitempty"`
	// An upper bound (inclusive) on the starting coordinate of any
	// variant in the reference sequence.
	UpperBound int64 `protobuf:"varint,2,opt,name=upper_bound,json=upperBound,proto3" json:"upper_bound,omitempty"`
}

func (m *ReferenceBound) Reset()                    { *m = ReferenceBound{} }
func (m *ReferenceBound) String() string            { return proto.CompactTextString(m) }
func (*ReferenceBound) ProtoMessage()               {}
func (*ReferenceBound) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{5} }

func (m *ReferenceBound) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *ReferenceBound) GetUpperBound() int64 {
	if m != nil {
		return m.UpperBound
	}
	return 0
}

// The variant data import request.
type ImportVariantsRequest struct {
	// Required. The variant set to which variant data should be imported.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId,proto3" json:"variant_set_id,omitempty"`
	// A list of URIs referencing variant files in Google Cloud Storage. URIs can
	// include wildcards [as described
	// here](https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames).
	// Note that recursive wildcards ('**') are not supported.
	SourceUris []string `protobuf:"bytes,2,rep,name=source_uris,json=sourceUris" json:"source_uris,omitempty"`
	// The format of the variant data being imported. If unspecified, defaults to
	// to `VCF`.
	Format ImportVariantsRequest_Format `protobuf:"varint,3,opt,name=format,proto3,enum=google.genomics.v1.ImportVariantsRequest_Format" json:"format,omitempty"`
	// Convert reference names to the canonical representation.
	// hg19 haploytypes (those reference names containing "_hap")
	// are not modified in any way.
	// All other reference names are modified according to the following rules:
	// The reference name is capitalized.
	// The "chr" prefix is dropped for all autosomes and sex chromsomes.
	// For example "chr17" becomes "17" and "chrX" becomes "X".
	// All mitochondrial chromosomes ("chrM", "chrMT", etc) become "MT".
	NormalizeReferenceNames bool `protobuf:"varint,5,opt,name=normalize_reference_names,json=normalizeReferenceNames,proto3" json:"normalize_reference_names,omitempty"`
	// A mapping between info field keys and the InfoMergeOperations to
	// be performed on them. This is plumbed down to the MergeVariantRequests
	// generated by the resulting import job.
	InfoMergeConfig map[string]InfoMergeOperation `protobuf:"bytes,6,rep,name=info_merge_config,json=infoMergeConfig" json:"info_merge_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=google.genomics.v1.InfoMergeOperation"`
}

func (m *ImportVariantsRequest) Reset()                    { *m = ImportVariantsRequest{} }
func (m *ImportVariantsRequest) String() string            { return proto.CompactTextString(m) }
func (*ImportVariantsRequest) ProtoMessage()               {}
func (*ImportVariantsRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{6} }

func (m *ImportVariantsRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *ImportVariantsRequest) GetSourceUris() []string {
	if m != nil {
		return m.SourceUris
	}
	return nil
}

func (m *ImportVariantsRequest) GetFormat() ImportVariantsRequest_Format {
	if m != nil {
		return m.Format
	}
	return ImportVariantsRequest_FORMAT_UNSPECIFIED
}

func (m *ImportVariantsRequest) GetNormalizeReferenceNames() bool {
	if m != nil {
		return m.NormalizeReferenceNames
	}
	return false
}

func (m *ImportVariantsRequest) GetInfoMergeConfig() map[string]InfoMergeOperation {
	if m != nil {
		return m.InfoMergeConfig
	}
	return nil
}

// The variant data import response.
type ImportVariantsResponse struct {
	// IDs of the call sets created during the import.
	CallSetIds []string `protobuf:"bytes,1,rep,name=call_set_ids,json=callSetIds" json:"call_set_ids,omitempty"`
}

func (m *ImportVariantsResponse) Reset()                    { *m = ImportVariantsResponse{} }
func (m *ImportVariantsResponse) String() string            { return proto.CompactTextString(m) }
func (*ImportVariantsResponse) ProtoMessage()               {}
func (*ImportVariantsResponse) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{7} }

func (m *ImportVariantsResponse) GetCallSetIds() []string {
	if m != nil {
		return m.CallSetIds
	}
	return nil
}

// The CreateVariantSet request
type CreateVariantSetRequest struct {
	// Required. The variant set to be created. Must have a valid `datasetId`.
	VariantSet *VariantSet `protobuf:"bytes,1,opt,name=variant_set,json=variantSet" json:"variant_set,omitempty"`
}

func (m *CreateVariantSetRequest) Reset()                    { *m = CreateVariantSetRequest{} }
func (m *CreateVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateVariantSetRequest) ProtoMessage()               {}
func (*CreateVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{8} }

func (m *CreateVariantSetRequest) GetVariantSet() *VariantSet {
	if m != nil {
		return m.VariantSet
	}
	return nil
}

// The variant data export request.
type ExportVariantSetRequest struct {
	// Required. The ID of the variant set that contains variant data which
	// should be exported. The caller must have READ access to this variant set.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId,proto3" json:"variant_set_id,omitempty"`
	// If provided, only variant call information from the specified call sets
	// will be exported. By default all variant calls are exported.
	CallSetIds []string `protobuf:"bytes,2,rep,name=call_set_ids,json=callSetIds" json:"call_set_ids,omitempty"`
	// Required. The Google Cloud project ID that owns the destination
	// BigQuery dataset. The caller must have WRITE access to this project.  This
	// project will also own the resulting export job.
	ProjectId string `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// The format for the exported data.
	Format ExportVariantSetRequest_Format `protobuf:"varint,4,opt,name=format,proto3,enum=google.genomics.v1.ExportVariantSetRequest_Format" json:"format,omitempty"`
	// Required. The BigQuery dataset to export data to. This dataset must already
	// exist. Note that this is distinct from the Genomics concept of "dataset".
	BigqueryDataset string `protobuf:"bytes,5,opt,name=bigquery_dataset,json=bigqueryDataset,proto3" json:"bigquery_dataset,omitempty"`
	// Required. The BigQuery table to export data to.
	// If the table doesn't exist, it will be created. If it already exists, it
	// will be overwritten.
	BigqueryTable string `protobuf:"bytes,6,opt,name=bigquery_table,json=bigqueryTable,proto3" json:"bigquery_table,omitempty"`
}

func (m *ExportVariantSetRequest) Reset()                    { *m = ExportVariantSetRequest{} }
func (m *ExportVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*ExportVariantSetRequest) ProtoMessage()               {}
func (*ExportVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{9} }

func (m *ExportVariantSetRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *ExportVariantSetRequest) GetCallSetIds() []string {
	if m != nil {
		return m.CallSetIds
	}
	return nil
}

func (m *ExportVariantSetRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *ExportVariantSetRequest) GetFormat() ExportVariantSetRequest_Format {
	if m != nil {
		return m.Format
	}
	return ExportVariantSetRequest_FORMAT_UNSPECIFIED
}

func (m *ExportVariantSetRequest) GetBigqueryDataset() string {
	if m != nil {
		return m.BigqueryDataset
	}
	return ""
}

func (m *ExportVariantSetRequest) GetBigqueryTable() string {
	if m != nil {
		return m.BigqueryTable
	}
	return ""
}

// The variant set request.
type GetVariantSetRequest struct {
	// Required. The ID of the variant set.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId,proto3" json:"variant_set_id,omitempty"`
}

func (m *GetVariantSetRequest) Reset()                    { *m = GetVariantSetRequest{} }
func (m *GetVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVariantSetRequest) ProtoMessage()               {}
func (*GetVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{10} }

func (m *GetVariantSetRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

// The search variant sets request.
type SearchVariantSetsRequest struct {
	// Exactly one dataset ID must be provided here. Only variant sets which
	// belong to this dataset will be returned.
	DatasetIds []string `protobuf:"bytes,1,rep,name=dataset_ids,json=datasetIds" json:"dataset_ids,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,2,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The maximum number of results to return in a single page. If unspecified,
	// defaults to 1024.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *SearchVariantSetsRequest) Reset()         { *m = SearchVariantSetsRequest{} }
func (m *SearchVariantSetsRequest) String() string { return proto.CompactTextString(m) }
func (*SearchVariantSetsRequest) ProtoMessage()    {}
func (*SearchVariantSetsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorVariants, []int{11}
}

func (m *SearchVariantSetsRequest) GetDatasetIds() []string {
	if m != nil {
		return m.DatasetIds
	}
	return nil
}

func (m *SearchVariantSetsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchVariantSetsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// The search variant sets response.
type SearchVariantSetsResponse struct {
	// The variant sets belonging to the requested dataset.
	VariantSets []*VariantSet `protobuf:"bytes,1,rep,name=variant_sets,json=variantSets" json:"variant_sets,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *SearchVariantSetsResponse) Reset()         { *m = SearchVariantSetsResponse{} }
func (m *SearchVariantSetsResponse) String() string { return proto.CompactTextString(m) }
func (*SearchVariantSetsResponse) ProtoMessage()    {}
func (*SearchVariantSetsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorVariants, []int{12}
}

func (m *SearchVariantSetsResponse) GetVariantSets() []*VariantSet {
	if m != nil {
		return m.VariantSets
	}
	return nil
}

func (m *SearchVariantSetsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// The delete variant set request.
type DeleteVariantSetRequest struct {
	// The ID of the variant set to be deleted.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId,proto3" json:"variant_set_id,omitempty"`
}

func (m *DeleteVariantSetRequest) Reset()                    { *m = DeleteVariantSetRequest{} }
func (m *DeleteVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteVariantSetRequest) ProtoMessage()               {}
func (*DeleteVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{13} }

func (m *DeleteVariantSetRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

type UpdateVariantSetRequest struct {
	// The ID of the variant to be updated (must already exist).
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId,proto3" json:"variant_set_id,omitempty"`
	// The new variant data. Only the variant_set.metadata will be considered
	// for update.
	VariantSet *VariantSet `protobuf:"bytes,2,opt,name=variant_set,json=variantSet" json:"variant_set,omitempty"`
	// An optional mask specifying which fields to update. Supported fields:
	//
	// * [metadata][google.genomics.v1.VariantSet.metadata].
	// * [name][google.genomics.v1.VariantSet.name].
	// * [description][google.genomics.v1.VariantSet.description].
	//
	// Leaving `updateMask` unset is equivalent to specifying all mutable
	// fields.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,5,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateVariantSetRequest) Reset()                    { *m = UpdateVariantSetRequest{} }
func (m *UpdateVariantSetRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateVariantSetRequest) ProtoMessage()               {}
func (*UpdateVariantSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{14} }

func (m *UpdateVariantSetRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *UpdateVariantSetRequest) GetVariantSet() *VariantSet {
	if m != nil {
		return m.VariantSet
	}
	return nil
}

func (m *UpdateVariantSetRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// The variant search request.
type SearchVariantsRequest struct {
	// At most one variant set ID must be provided. Only variants from this
	// variant set will be returned. If omitted, a call set id must be included in
	// the request.
	VariantSetIds []string `protobuf:"bytes,1,rep,name=variant_set_ids,json=variantSetIds" json:"variant_set_ids,omitempty"`
	// Only return variants which have exactly this name.
	VariantName string `protobuf:"bytes,2,opt,name=variant_name,json=variantName,proto3" json:"variant_name,omitempty"`
	// Only return variant calls which belong to call sets with these ids.
	// Leaving this blank returns all variant calls. If a variant has no
	// calls belonging to any of these call sets, it won't be returned at all.
	CallSetIds []string `protobuf:"bytes,3,rep,name=call_set_ids,json=callSetIds" json:"call_set_ids,omitempty"`
	// Required. Only return variants in this reference sequence.
	ReferenceName string `protobuf:"bytes,4,opt,name=reference_name,json=referenceName,proto3" json:"reference_name,omitempty"`
	// The beginning of the window (0-based, inclusive) for which
	// overlapping variants should be returned. If unspecified, defaults to 0.
	Start int64 `protobuf:"varint,5,opt,name=start,proto3" json:"start,omitempty"`
	// The end of the window, 0-based exclusive. If unspecified or 0, defaults to
	// the length of the reference.
	End int64 `protobuf:"varint,6,opt,name=end,proto3" json:"end,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,7,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The maximum number of variants to return in a single page. If unspecified,
	// defaults to 5000. The maximum value is 10000.
	PageSize int32 `protobuf:"varint,8,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// The maximum number of calls to return in a single page. Note that this
	// limit may be exceeded in the event that a matching variant contains more
	// calls than the requested maximum. If unspecified, defaults to 5000. The
	// maximum value is 10000.
	MaxCalls int32 `protobuf:"varint,9,opt,name=max_calls,json=maxCalls,proto3" json:"max_calls,omitempty"`
}

func (m *SearchVariantsRequest) Reset()                    { *m = SearchVariantsRequest{} }
func (m *SearchVariantsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchVariantsRequest) ProtoMessage()               {}
func (*SearchVariantsRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{15} }

func (m *SearchVariantsRequest) GetVariantSetIds() []string {
	if m != nil {
		return m.VariantSetIds
	}
	return nil
}

func (m *SearchVariantsRequest) GetVariantName() string {
	if m != nil {
		return m.VariantName
	}
	return ""
}

func (m *SearchVariantsRequest) GetCallSetIds() []string {
	if m != nil {
		return m.CallSetIds
	}
	return nil
}

func (m *SearchVariantsRequest) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *SearchVariantsRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchVariantsRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchVariantsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchVariantsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *SearchVariantsRequest) GetMaxCalls() int32 {
	if m != nil {
		return m.MaxCalls
	}
	return 0
}

// The variant search response.
type SearchVariantsResponse struct {
	// The list of matching Variants.
	Variants []*Variant `protobuf:"bytes,1,rep,name=variants" json:"variants,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *SearchVariantsResponse) Reset()                    { *m = SearchVariantsResponse{} }
func (m *SearchVariantsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchVariantsResponse) ProtoMessage()               {}
func (*SearchVariantsResponse) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{16} }

func (m *SearchVariantsResponse) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

func (m *SearchVariantsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type CreateVariantRequest struct {
	// The variant to be created.
	Variant *Variant `protobuf:"bytes,1,opt,name=variant" json:"variant,omitempty"`
}

func (m *CreateVariantRequest) Reset()                    { *m = CreateVariantRequest{} }
func (m *CreateVariantRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateVariantRequest) ProtoMessage()               {}
func (*CreateVariantRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{17} }

func (m *CreateVariantRequest) GetVariant() *Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

type UpdateVariantRequest struct {
	// The ID of the variant to be updated.
	VariantId string `protobuf:"bytes,1,opt,name=variant_id,json=variantId,proto3" json:"variant_id,omitempty"`
	// The new variant data.
	Variant *Variant `protobuf:"bytes,2,opt,name=variant" json:"variant,omitempty"`
	// An optional mask specifying which fields to update. At this time, mutable
	// fields are [names][google.genomics.v1.Variant.names] and
	// [info][google.genomics.v1.Variant.info]. Acceptable values are "names" and
	// "info". If unspecified, all mutable fields will be updated.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateVariantRequest) Reset()                    { *m = UpdateVariantRequest{} }
func (m *UpdateVariantRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateVariantRequest) ProtoMessage()               {}
func (*UpdateVariantRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{18} }

func (m *UpdateVariantRequest) GetVariantId() string {
	if m != nil {
		return m.VariantId
	}
	return ""
}

func (m *UpdateVariantRequest) GetVariant() *Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (m *UpdateVariantRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type DeleteVariantRequest struct {
	// The ID of the variant to be deleted.
	VariantId string `protobuf:"bytes,1,opt,name=variant_id,json=variantId,proto3" json:"variant_id,omitempty"`
}

func (m *DeleteVariantRequest) Reset()                    { *m = DeleteVariantRequest{} }
func (m *DeleteVariantRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteVariantRequest) ProtoMessage()               {}
func (*DeleteVariantRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{19} }

func (m *DeleteVariantRequest) GetVariantId() string {
	if m != nil {
		return m.VariantId
	}
	return ""
}

type GetVariantRequest struct {
	// The ID of the variant.
	VariantId string `protobuf:"bytes,1,opt,name=variant_id,json=variantId,proto3" json:"variant_id,omitempty"`
}

func (m *GetVariantRequest) Reset()                    { *m = GetVariantRequest{} }
func (m *GetVariantRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVariantRequest) ProtoMessage()               {}
func (*GetVariantRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{20} }

func (m *GetVariantRequest) GetVariantId() string {
	if m != nil {
		return m.VariantId
	}
	return ""
}

type MergeVariantsRequest struct {
	// The destination variant set.
	VariantSetId string `protobuf:"bytes,1,opt,name=variant_set_id,json=variantSetId,proto3" json:"variant_set_id,omitempty"`
	// The variants to be merged with existing variants.
	Variants []*Variant `protobuf:"bytes,2,rep,name=variants" json:"variants,omitempty"`
	// A mapping between info field keys and the InfoMergeOperations to
	// be performed on them.
	InfoMergeConfig map[string]InfoMergeOperation `protobuf:"bytes,3,rep,name=info_merge_config,json=infoMergeConfig" json:"info_merge_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=google.genomics.v1.InfoMergeOperation"`
}

func (m *MergeVariantsRequest) Reset()                    { *m = MergeVariantsRequest{} }
func (m *MergeVariantsRequest) String() string            { return proto.CompactTextString(m) }
func (*MergeVariantsRequest) ProtoMessage()               {}
func (*MergeVariantsRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{21} }

func (m *MergeVariantsRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *MergeVariantsRequest) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

func (m *MergeVariantsRequest) GetInfoMergeConfig() map[string]InfoMergeOperation {
	if m != nil {
		return m.InfoMergeConfig
	}
	return nil
}

// The call set search request.
type SearchCallSetsRequest struct {
	// Restrict the query to call sets within the given variant sets. At least one
	// ID must be provided.
	VariantSetIds []string `protobuf:"bytes,1,rep,name=variant_set_ids,json=variantSetIds" json:"variant_set_ids,omitempty"`
	// Only return call sets for which a substring of the name matches this
	// string.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The maximum number of results to return in a single page. If unspecified,
	// defaults to 1024.
	PageSize int32 `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *SearchCallSetsRequest) Reset()                    { *m = SearchCallSetsRequest{} }
func (m *SearchCallSetsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchCallSetsRequest) ProtoMessage()               {}
func (*SearchCallSetsRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{22} }

func (m *SearchCallSetsRequest) GetVariantSetIds() []string {
	if m != nil {
		return m.VariantSetIds
	}
	return nil
}

func (m *SearchCallSetsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SearchCallSetsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchCallSetsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// The call set search response.
type SearchCallSetsResponse struct {
	// The list of matching call sets.
	CallSets []*CallSet `protobuf:"bytes,1,rep,name=call_sets,json=callSets" json:"call_sets,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *SearchCallSetsResponse) Reset()                    { *m = SearchCallSetsResponse{} }
func (m *SearchCallSetsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchCallSetsResponse) ProtoMessage()               {}
func (*SearchCallSetsResponse) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{23} }

func (m *SearchCallSetsResponse) GetCallSets() []*CallSet {
	if m != nil {
		return m.CallSets
	}
	return nil
}

func (m *SearchCallSetsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type CreateCallSetRequest struct {
	// The call set to be created.
	CallSet *CallSet `protobuf:"bytes,1,opt,name=call_set,json=callSet" json:"call_set,omitempty"`
}

func (m *CreateCallSetRequest) Reset()                    { *m = CreateCallSetRequest{} }
func (m *CreateCallSetRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateCallSetRequest) ProtoMessage()               {}
func (*CreateCallSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{24} }

func (m *CreateCallSetRequest) GetCallSet() *CallSet {
	if m != nil {
		return m.CallSet
	}
	return nil
}

type UpdateCallSetRequest struct {
	// The ID of the call set to be updated.
	CallSetId string `protobuf:"bytes,1,opt,name=call_set_id,json=callSetId,proto3" json:"call_set_id,omitempty"`
	// The new call set data.
	CallSet *CallSet `protobuf:"bytes,2,opt,name=call_set,json=callSet" json:"call_set,omitempty"`
	// An optional mask specifying which fields to update. At this time, the only
	// mutable field is [name][google.genomics.v1.CallSet.name]. The only
	// acceptable value is "name". If unspecified, all mutable fields will be
	// updated.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateCallSetRequest) Reset()                    { *m = UpdateCallSetRequest{} }
func (m *UpdateCallSetRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateCallSetRequest) ProtoMessage()               {}
func (*UpdateCallSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{25} }

func (m *UpdateCallSetRequest) GetCallSetId() string {
	if m != nil {
		return m.CallSetId
	}
	return ""
}

func (m *UpdateCallSetRequest) GetCallSet() *CallSet {
	if m != nil {
		return m.CallSet
	}
	return nil
}

func (m *UpdateCallSetRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type DeleteCallSetRequest struct {
	// The ID of the call set to be deleted.
	CallSetId string `protobuf:"bytes,1,opt,name=call_set_id,json=callSetId,proto3" json:"call_set_id,omitempty"`
}

func (m *DeleteCallSetRequest) Reset()                    { *m = DeleteCallSetRequest{} }
func (m *DeleteCallSetRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteCallSetRequest) ProtoMessage()               {}
func (*DeleteCallSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{26} }

func (m *DeleteCallSetRequest) GetCallSetId() string {
	if m != nil {
		return m.CallSetId
	}
	return ""
}

type GetCallSetRequest struct {
	// The ID of the call set.
	CallSetId string `protobuf:"bytes,1,opt,name=call_set_id,json=callSetId,proto3" json:"call_set_id,omitempty"`
}

func (m *GetCallSetRequest) Reset()                    { *m = GetCallSetRequest{} }
func (m *GetCallSetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCallSetRequest) ProtoMessage()               {}
func (*GetCallSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{27} }

func (m *GetCallSetRequest) GetCallSetId() string {
	if m != nil {
		return m.CallSetId
	}
	return ""
}

// The stream variants request.
type StreamVariantsRequest struct {
	// The Google Cloud project ID which will be billed
	// for this access. The caller must have WRITE access to this project.
	// Required.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// The variant set ID from which to stream variants.
	VariantSetId string `protobuf:"bytes,2,opt,name=variant_set_id,json=variantSetId,proto3" json:"variant_set_id,omitempty"`
	// Only return variant calls which belong to call sets with these IDs.
	// Leaving this blank returns all variant calls.
	CallSetIds []string `protobuf:"bytes,3,rep,name=call_set_ids,json=callSetIds" json:"call_set_ids,omitempty"`
	// Required. Only return variants in this reference sequence.
	ReferenceName string `protobuf:"bytes,4,opt,name=reference_name,json=referenceName,proto3" json:"reference_name,omitempty"`
	// The beginning of the window (0-based, inclusive) for which
	// overlapping variants should be returned.
	Start int64 `protobuf:"varint,5,opt,name=start,proto3" json:"start,omitempty"`
	// The end of the window (0-based, exclusive) for which overlapping
	// variants should be returned.
	End int64 `protobuf:"varint,6,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *StreamVariantsRequest) Reset()                    { *m = StreamVariantsRequest{} }
func (m *StreamVariantsRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamVariantsRequest) ProtoMessage()               {}
func (*StreamVariantsRequest) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{28} }

func (m *StreamVariantsRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *StreamVariantsRequest) GetVariantSetId() string {
	if m != nil {
		return m.VariantSetId
	}
	return ""
}

func (m *StreamVariantsRequest) GetCallSetIds() []string {
	if m != nil {
		return m.CallSetIds
	}
	return nil
}

func (m *StreamVariantsRequest) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *StreamVariantsRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *StreamVariantsRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type StreamVariantsResponse struct {
	Variants []*Variant `protobuf:"bytes,1,rep,name=variants" json:"variants,omitempty"`
}

func (m *StreamVariantsResponse) Reset()                    { *m = StreamVariantsResponse{} }
func (m *StreamVariantsResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamVariantsResponse) ProtoMessage()               {}
func (*StreamVariantsResponse) Descriptor() ([]byte, []int) { return fileDescriptorVariants, []int{29} }

func (m *StreamVariantsResponse) GetVariants() []*Variant {
	if m != nil {
		return m.Variants
	}
	return nil
}

func init() {
	proto.RegisterType((*VariantSetMetadata)(nil), "google.genomics.v1.VariantSetMetadata")
	proto.RegisterType((*VariantSet)(nil), "google.genomics.v1.VariantSet")
	proto.RegisterType((*Variant)(nil), "google.genomics.v1.Variant")
	proto.RegisterType((*VariantCall)(nil), "google.genomics.v1.VariantCall")
	proto.RegisterType((*CallSet)(nil), "google.genomics.v1.CallSet")
	proto.RegisterType((*ReferenceBound)(nil), "google.genomics.v1.ReferenceBound")
	proto.RegisterType((*ImportVariantsRequest)(nil), "google.genomics.v1.ImportVariantsRequest")
	proto.RegisterType((*ImportVariantsResponse)(nil), "google.genomics.v1.ImportVariantsResponse")
	proto.RegisterType((*CreateVariantSetRequest)(nil), "google.genomics.v1.CreateVariantSetRequest")
	proto.RegisterType((*ExportVariantSetRequest)(nil), "google.genomics.v1.ExportVariantSetRequest")
	proto.RegisterType((*GetVariantSetRequest)(nil), "google.genomics.v1.GetVariantSetRequest")
	proto.RegisterType((*SearchVariantSetsRequest)(nil), "google.genomics.v1.SearchVariantSetsRequest")
	proto.RegisterType((*SearchVariantSetsResponse)(nil), "google.genomics.v1.SearchVariantSetsResponse")
	proto.RegisterType((*DeleteVariantSetRequest)(nil), "google.genomics.v1.DeleteVariantSetRequest")
	proto.RegisterType((*UpdateVariantSetRequest)(nil), "google.genomics.v1.UpdateVariantSetRequest")
	proto.RegisterType((*SearchVariantsRequest)(nil), "google.genomics.v1.SearchVariantsRequest")
	proto.RegisterType((*SearchVariantsResponse)(nil), "google.genomics.v1.SearchVariantsResponse")
	proto.RegisterType((*CreateVariantRequest)(nil), "google.genomics.v1.CreateVariantRequest")
	proto.RegisterType((*UpdateVariantRequest)(nil), "google.genomics.v1.UpdateVariantRequest")
	proto.RegisterType((*DeleteVariantRequest)(nil), "google.genomics.v1.DeleteVariantRequest")
	proto.RegisterType((*GetVariantRequest)(nil), "google.genomics.v1.GetVariantRequest")
	proto.RegisterType((*MergeVariantsRequest)(nil), "google.genomics.v1.MergeVariantsRequest")
	proto.RegisterType((*SearchCallSetsRequest)(nil), "google.genomics.v1.SearchCallSetsRequest")
	proto.RegisterType((*SearchCallSetsResponse)(nil), "google.genomics.v1.SearchCallSetsResponse")
	proto.RegisterType((*CreateCallSetRequest)(nil), "google.genomics.v1.CreateCallSetRequest")
	proto.RegisterType((*UpdateCallSetRequest)(nil), "google.genomics.v1.UpdateCallSetRequest")
	proto.RegisterType((*DeleteCallSetRequest)(nil), "google.genomics.v1.DeleteCallSetRequest")
	proto.RegisterType((*GetCallSetRequest)(nil), "google.genomics.v1.GetCallSetRequest")
	proto.RegisterType((*StreamVariantsRequest)(nil), "google.genomics.v1.StreamVariantsRequest")
	proto.RegisterType((*StreamVariantsResponse)(nil), "google.genomics.v1.StreamVariantsResponse")
	proto.RegisterEnum("google.genomics.v1.InfoMergeOperation", InfoMergeOperation_name, InfoMergeOperation_value)
	proto.RegisterEnum("google.genomics.v1.VariantSetMetadata_Type", VariantSetMetadata_Type_name, VariantSetMetadata_Type_value)
	proto.RegisterEnum("google.genomics.v1.ImportVariantsRequest_Format", ImportVariantsRequest_Format_name, ImportVariantsRequest_Format_value)
	proto.RegisterEnum("google.genomics.v1.ExportVariantSetRequest_Format", ExportVariantSetRequest_Format_name, ExportVariantSetRequest_Format_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for StreamingVariantService service

type StreamingVariantServiceClient interface {
	// Returns a stream of all the variants matching the search request, ordered
	// by reference name, position, and ID.
	StreamVariants(ctx context.Context, in *StreamVariantsRequest, opts ...grpc.CallOption) (StreamingVariantService_StreamVariantsClient, error)
}

type streamingVariantServiceClient struct {
	cc *grpc.ClientConn
}

func NewStreamingVariantServiceClient(cc *grpc.ClientConn) StreamingVariantServiceClient {
	return &streamingVariantServiceClient{cc}
}

func (c *streamingVariantServiceClient) StreamVariants(ctx context.Context, in *StreamVariantsRequest, opts ...grpc.CallOption) (StreamingVariantService_StreamVariantsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StreamingVariantService_serviceDesc.Streams[0], c.cc, "/google.genomics.v1.StreamingVariantService/StreamVariants", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingVariantServiceStreamVariantsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingVariantService_StreamVariantsClient interface {
	Recv() (*StreamVariantsResponse, error)
	grpc.ClientStream
}

type streamingVariantServiceStreamVariantsClient struct {
	grpc.ClientStream
}

func (x *streamingVariantServiceStreamVariantsClient) Recv() (*StreamVariantsResponse, error) {
	m := new(StreamVariantsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for StreamingVariantService service

type StreamingVariantServiceServer interface {
	// Returns a stream of all the variants matching the search request, ordered
	// by reference name, position, and ID.
	StreamVariants(*StreamVariantsRequest, StreamingVariantService_StreamVariantsServer) error
}

func RegisterStreamingVariantServiceServer(s *grpc.Server, srv StreamingVariantServiceServer) {
	s.RegisterService(&_StreamingVariantService_serviceDesc, srv)
}

func _StreamingVariantService_StreamVariants_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamVariantsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingVariantServiceServer).StreamVariants(m, &streamingVariantServiceStreamVariantsServer{stream})
}

type StreamingVariantService_StreamVariantsServer interface {
	Send(*StreamVariantsResponse) error
	grpc.ServerStream
}

type streamingVariantServiceStreamVariantsServer struct {
	grpc.ServerStream
}

func (x *streamingVariantServiceStreamVariantsServer) Send(m *StreamVariantsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _StreamingVariantService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.genomics.v1.StreamingVariantService",
	HandlerType: (*StreamingVariantServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamVariants",
			Handler:       _StreamingVariantService_StreamVariants_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "google/genomics/v1/variants.proto",
}

// Client API for VariantServiceV1 service

type VariantServiceV1Client interface {
	// Creates variant data by asynchronously importing the provided information.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// The variants for import will be merged with any existing variant that
	// matches its reference sequence, start, end, reference bases, and
	// alternative bases. If no such variant exists, a new one will be created.
	//
	// When variants are merged, the call information from the new variant
	// is added to the existing variant, and Variant info fields are merged
	// as specified in
	// [infoMergeConfig][google.genomics.v1.ImportVariantsRequest.info_merge_config].
	// As a special case, for single-sample VCF files, QUAL and FILTER fields will
	// be moved to the call level; these are sometimes interpreted in a
	// call-specific context.
	// Imported VCF headers are appended to the metadata already in a variant set.
	ImportVariants(ctx context.Context, in *ImportVariantsRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error)
	// Creates a new variant set.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// The provided variant set must have a valid `datasetId` set - all other
	// fields are optional. Note that the `id` field will be ignored, as this is
	// assigned by the server.
	CreateVariantSet(ctx context.Context, in *CreateVariantSetRequest, opts ...grpc.CallOption) (*VariantSet, error)
	// Exports variant set data to an external destination.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	ExportVariantSet(ctx context.Context, in *ExportVariantSetRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error)
	// Gets a variant set by ID.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	GetVariantSet(ctx context.Context, in *GetVariantSetRequest, opts ...grpc.CallOption) (*VariantSet, error)
	// Returns a list of all variant sets matching search criteria.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Implements
	// [GlobalAllianceApi.searchVariantSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L49).
	SearchVariantSets(ctx context.Context, in *SearchVariantSetsRequest, opts ...grpc.CallOption) (*SearchVariantSetsResponse, error)
	// Deletes a variant set including all variants, call sets, and calls within.
	// This is not reversible.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	DeleteVariantSet(ctx context.Context, in *DeleteVariantSetRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	// Updates a variant set using patch semantics.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	UpdateVariantSet(ctx context.Context, in *UpdateVariantSetRequest, opts ...grpc.CallOption) (*VariantSet, error)
	// Gets a list of variants matching the criteria.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Implements
	// [GlobalAllianceApi.searchVariants](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L126).
	SearchVariants(ctx context.Context, in *SearchVariantsRequest, opts ...grpc.CallOption) (*SearchVariantsResponse, error)
	// Creates a new variant.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	CreateVariant(ctx context.Context, in *CreateVariantRequest, opts ...grpc.CallOption) (*Variant, error)
	// Updates a variant.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// This method supports patch semantics. Returns the modified variant without
	// its calls.
	UpdateVariant(ctx context.Context, in *UpdateVariantRequest, opts ...grpc.CallOption) (*Variant, error)
	// Deletes a variant.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	DeleteVariant(ctx context.Context, in *DeleteVariantRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	// Gets a variant by ID.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	GetVariant(ctx context.Context, in *GetVariantRequest, opts ...grpc.CallOption) (*Variant, error)
	// Merges the given variants with existing variants.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Each variant will be
	// merged with an existing variant that matches its reference sequence,
	// start, end, reference bases, and alternative bases. If no such variant
	// exists, a new one will be created.
	//
	// When variants are merged, the call information from the new variant
	// is added to the existing variant. Variant info fields are merged as
	// specified in the
	// [infoMergeConfig][google.genomics.v1.MergeVariantsRequest.info_merge_config]
	// field of the MergeVariantsRequest.
	//
	// Please exercise caution when using this method!  It is easy to introduce
	// mistakes in existing variants and difficult to back out of them.  For
	// example,
	// suppose you were trying to merge a new variant with an existing one and
	// both
	// variants contain calls that belong to callsets with the same callset ID.
	//
	//     // Existing variant - irrelevant fields trimmed for clarity
	//     {
	//         "variantSetId": "10473108253681171589",
	//         "referenceName": "1",
	//         "start": "10582",
	//         "referenceBases": "G",
	//         "alternateBases": [
	//             "A"
	//         ],
	//         "calls": [
	//             {
	//                 "callSetId": "10473108253681171589-0",
	//                 "callSetName": "CALLSET0",
	//                 "genotype": [
	//                     0,
	//                     1
	//                 ],
	//             }
	//         ]
	//     }
	//
	//     // New variant with conflicting call information
	//     {
	//         "variantSetId": "10473108253681171589",
	//         "referenceName": "1",
	//         "start": "10582",
	//         "referenceBases": "G",
	//         "alternateBases": [
	//             "A"
	//         ],
	//         "calls": [
	//             {
	//                 "callSetId": "10473108253681171589-0",
	//                 "callSetName": "CALLSET0",
	//                 "genotype": [
	//                     1,
	//                     1
	//                 ],
	//             }
	//         ]
	//     }
	//
	// The resulting merged variant would overwrite the existing calls with those
	// from the new variant:
	//
	//     {
	//         "variantSetId": "10473108253681171589",
	//         "referenceName": "1",
	//         "start": "10582",
	//         "referenceBases": "G",
	//         "alternateBases": [
	//             "A"
	//         ],
	//         "calls": [
	//             {
	//                 "callSetId": "10473108253681171589-0",
	//                 "callSetName": "CALLSET0",
	//                 "genotype": [
	//                     1,
	//                     1
	//                 ],
	//             }
	//         ]
	//     }
	//
	// This may be the desired outcome, but it is up to the user to determine if
	// if that is indeed the case.
	MergeVariants(ctx context.Context, in *MergeVariantsRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	// Gets a list of call sets matching the criteria.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Implements
	// [GlobalAllianceApi.searchCallSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L178).
	SearchCallSets(ctx context.Context, in *SearchCallSetsRequest, opts ...grpc.CallOption) (*SearchCallSetsResponse, error)
	// Creates a new call set.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	CreateCallSet(ctx context.Context, in *CreateCallSetRequest, opts ...grpc.CallOption) (*CallSet, error)
	// Updates a call set.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// This method supports patch semantics.
	UpdateCallSet(ctx context.Context, in *UpdateCallSetRequest, opts ...grpc.CallOption) (*CallSet, error)
	// Deletes a call set.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	DeleteCallSet(ctx context.Context, in *DeleteCallSetRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	// Gets a call set by ID.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	GetCallSet(ctx context.Context, in *GetCallSetRequest, opts ...grpc.CallOption) (*CallSet, error)
}

type variantServiceV1Client struct {
	cc *grpc.ClientConn
}

func NewVariantServiceV1Client(cc *grpc.ClientConn) VariantServiceV1Client {
	return &variantServiceV1Client{cc}
}

func (c *variantServiceV1Client) ImportVariants(ctx context.Context, in *ImportVariantsRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/ImportVariants", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) CreateVariantSet(ctx context.Context, in *CreateVariantSetRequest, opts ...grpc.CallOption) (*VariantSet, error) {
	out := new(VariantSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/CreateVariantSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) ExportVariantSet(ctx context.Context, in *ExportVariantSetRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/ExportVariantSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) GetVariantSet(ctx context.Context, in *GetVariantSetRequest, opts ...grpc.CallOption) (*VariantSet, error) {
	out := new(VariantSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/GetVariantSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) SearchVariantSets(ctx context.Context, in *SearchVariantSetsRequest, opts ...grpc.CallOption) (*SearchVariantSetsResponse, error) {
	out := new(SearchVariantSetsResponse)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/SearchVariantSets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) DeleteVariantSet(ctx context.Context, in *DeleteVariantSetRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/DeleteVariantSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) UpdateVariantSet(ctx context.Context, in *UpdateVariantSetRequest, opts ...grpc.CallOption) (*VariantSet, error) {
	out := new(VariantSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/UpdateVariantSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) SearchVariants(ctx context.Context, in *SearchVariantsRequest, opts ...grpc.CallOption) (*SearchVariantsResponse, error) {
	out := new(SearchVariantsResponse)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/SearchVariants", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) CreateVariant(ctx context.Context, in *CreateVariantRequest, opts ...grpc.CallOption) (*Variant, error) {
	out := new(Variant)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/CreateVariant", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) UpdateVariant(ctx context.Context, in *UpdateVariantRequest, opts ...grpc.CallOption) (*Variant, error) {
	out := new(Variant)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/UpdateVariant", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) DeleteVariant(ctx context.Context, in *DeleteVariantRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/DeleteVariant", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) GetVariant(ctx context.Context, in *GetVariantRequest, opts ...grpc.CallOption) (*Variant, error) {
	out := new(Variant)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/GetVariant", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) MergeVariants(ctx context.Context, in *MergeVariantsRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/MergeVariants", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) SearchCallSets(ctx context.Context, in *SearchCallSetsRequest, opts ...grpc.CallOption) (*SearchCallSetsResponse, error) {
	out := new(SearchCallSetsResponse)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/SearchCallSets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) CreateCallSet(ctx context.Context, in *CreateCallSetRequest, opts ...grpc.CallOption) (*CallSet, error) {
	out := new(CallSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/CreateCallSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) UpdateCallSet(ctx context.Context, in *UpdateCallSetRequest, opts ...grpc.CallOption) (*CallSet, error) {
	out := new(CallSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/UpdateCallSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) DeleteCallSet(ctx context.Context, in *DeleteCallSetRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/DeleteCallSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *variantServiceV1Client) GetCallSet(ctx context.Context, in *GetCallSetRequest, opts ...grpc.CallOption) (*CallSet, error) {
	out := new(CallSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.VariantServiceV1/GetCallSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VariantServiceV1 service

type VariantServiceV1Server interface {
	// Creates variant data by asynchronously importing the provided information.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// The variants for import will be merged with any existing variant that
	// matches its reference sequence, start, end, reference bases, and
	// alternative bases. If no such variant exists, a new one will be created.
	//
	// When variants are merged, the call information from the new variant
	// is added to the existing variant, and Variant info fields are merged
	// as specified in
	// [infoMergeConfig][google.genomics.v1.ImportVariantsRequest.info_merge_config].
	// As a special case, for single-sample VCF files, QUAL and FILTER fields will
	// be moved to the call level; these are sometimes interpreted in a
	// call-specific context.
	// Imported VCF headers are appended to the metadata already in a variant set.
	ImportVariants(context.Context, *ImportVariantsRequest) (*google_longrunning.Operation, error)
	// Creates a new variant set.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// The provided variant set must have a valid `datasetId` set - all other
	// fields are optional. Note that the `id` field will be ignored, as this is
	// assigned by the server.
	CreateVariantSet(context.Context, *CreateVariantSetRequest) (*VariantSet, error)
	// Exports variant set data to an external destination.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	ExportVariantSet(context.Context, *ExportVariantSetRequest) (*google_longrunning.Operation, error)
	// Gets a variant set by ID.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	GetVariantSet(context.Context, *GetVariantSetRequest) (*VariantSet, error)
	// Returns a list of all variant sets matching search criteria.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Implements
	// [GlobalAllianceApi.searchVariantSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L49).
	SearchVariantSets(context.Context, *SearchVariantSetsRequest) (*SearchVariantSetsResponse, error)
	// Deletes a variant set including all variants, call sets, and calls within.
	// This is not reversible.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	DeleteVariantSet(context.Context, *DeleteVariantSetRequest) (*google_protobuf1.Empty, error)
	// Updates a variant set using patch semantics.
	//
	// For the definitions of variant sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	UpdateVariantSet(context.Context, *UpdateVariantSetRequest) (*VariantSet, error)
	// Gets a list of variants matching the criteria.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Implements
	// [GlobalAllianceApi.searchVariants](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L126).
	SearchVariants(context.Context, *SearchVariantsRequest) (*SearchVariantsResponse, error)
	// Creates a new variant.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	CreateVariant(context.Context, *CreateVariantRequest) (*Variant, error)
	// Updates a variant.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// This method supports patch semantics. Returns the modified variant without
	// its calls.
	UpdateVariant(context.Context, *UpdateVariantRequest) (*Variant, error)
	// Deletes a variant.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	DeleteVariant(context.Context, *DeleteVariantRequest) (*google_protobuf1.Empty, error)
	// Gets a variant by ID.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	GetVariant(context.Context, *GetVariantRequest) (*Variant, error)
	// Merges the given variants with existing variants.
	//
	// For the definitions of variants and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Each variant will be
	// merged with an existing variant that matches its reference sequence,
	// start, end, reference bases, and alternative bases. If no such variant
	// exists, a new one will be created.
	//
	// When variants are merged, the call information from the new variant
	// is added to the existing variant. Variant info fields are merged as
	// specified in the
	// [infoMergeConfig][google.genomics.v1.MergeVariantsRequest.info_merge_config]
	// field of the MergeVariantsRequest.
	//
	// Please exercise caution when using this method!  It is easy to introduce
	// mistakes in existing variants and difficult to back out of them.  For
	// example,
	// suppose you were trying to merge a new variant with an existing one and
	// both
	// variants contain calls that belong to callsets with the same callset ID.
	//
	//     // Existing variant - irrelevant fields trimmed for clarity
	//     {
	//         "variantSetId": "10473108253681171589",
	//         "referenceName": "1",
	//         "start": "10582",
	//         "referenceBases": "G",
	//         "alternateBases": [
	//             "A"
	//         ],
	//         "calls": [
	//             {
	//                 "callSetId": "10473108253681171589-0",
	//                 "callSetName": "CALLSET0",
	//                 "genotype": [
	//                     0,
	//                     1
	//                 ],
	//             }
	//         ]
	//     }
	//
	//     // New variant with conflicting call information
	//     {
	//         "variantSetId": "10473108253681171589",
	//         "referenceName": "1",
	//         "start": "10582",
	//         "referenceBases": "G",
	//         "alternateBases": [
	//             "A"
	//         ],
	//         "calls": [
	//             {
	//                 "callSetId": "10473108253681171589-0",
	//                 "callSetName": "CALLSET0",
	//                 "genotype": [
	//                     1,
	//                     1
	//                 ],
	//             }
	//         ]
	//     }
	//
	// The resulting merged variant would overwrite the existing calls with those
	// from the new variant:
	//
	//     {
	//         "variantSetId": "10473108253681171589",
	//         "referenceName": "1",
	//         "start": "10582",
	//         "referenceBases": "G",
	//         "alternateBases": [
	//             "A"
	//         ],
	//         "calls": [
	//             {
	//                 "callSetId": "10473108253681171589-0",
	//                 "callSetName": "CALLSET0",
	//                 "genotype": [
	//                     1,
	//                     1
	//                 ],
	//             }
	//         ]
	//     }
	//
	// This may be the desired outcome, but it is up to the user to determine if
	// if that is indeed the case.
	MergeVariants(context.Context, *MergeVariantsRequest) (*google_protobuf1.Empty, error)
	// Gets a list of call sets matching the criteria.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Implements
	// [GlobalAllianceApi.searchCallSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L178).
	SearchCallSets(context.Context, *SearchCallSetsRequest) (*SearchCallSetsResponse, error)
	// Creates a new call set.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	CreateCallSet(context.Context, *CreateCallSetRequest) (*CallSet, error)
	// Updates a call set.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// This method supports patch semantics.
	UpdateCallSet(context.Context, *UpdateCallSetRequest) (*CallSet, error)
	// Deletes a call set.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	DeleteCallSet(context.Context, *DeleteCallSetRequest) (*google_protobuf1.Empty, error)
	// Gets a call set by ID.
	//
	// For the definitions of call sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	GetCallSet(context.Context, *GetCallSetRequest) (*CallSet, error)
}

func RegisterVariantServiceV1Server(s *grpc.Server, srv VariantServiceV1Server) {
	s.RegisterService(&_VariantServiceV1_serviceDesc, srv)
}

func _VariantServiceV1_ImportVariants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportVariantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).ImportVariants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/ImportVariants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).ImportVariants(ctx, req.(*ImportVariantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_CreateVariantSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVariantSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).CreateVariantSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/CreateVariantSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).CreateVariantSet(ctx, req.(*CreateVariantSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_ExportVariantSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportVariantSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).ExportVariantSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/ExportVariantSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).ExportVariantSet(ctx, req.(*ExportVariantSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_GetVariantSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVariantSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).GetVariantSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/GetVariantSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).GetVariantSet(ctx, req.(*GetVariantSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_SearchVariantSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchVariantSetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).SearchVariantSets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/SearchVariantSets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).SearchVariantSets(ctx, req.(*SearchVariantSetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_DeleteVariantSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVariantSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).DeleteVariantSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/DeleteVariantSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).DeleteVariantSet(ctx, req.(*DeleteVariantSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_UpdateVariantSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVariantSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).UpdateVariantSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/UpdateVariantSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).UpdateVariantSet(ctx, req.(*UpdateVariantSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_SearchVariants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchVariantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).SearchVariants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/SearchVariants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).SearchVariants(ctx, req.(*SearchVariantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_CreateVariant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVariantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).CreateVariant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/CreateVariant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).CreateVariant(ctx, req.(*CreateVariantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_UpdateVariant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVariantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).UpdateVariant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/UpdateVariant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).UpdateVariant(ctx, req.(*UpdateVariantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_DeleteVariant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVariantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).DeleteVariant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/DeleteVariant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).DeleteVariant(ctx, req.(*DeleteVariantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_GetVariant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVariantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).GetVariant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/GetVariant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).GetVariant(ctx, req.(*GetVariantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_MergeVariants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MergeVariantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).MergeVariants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/MergeVariants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).MergeVariants(ctx, req.(*MergeVariantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_SearchCallSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchCallSetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).SearchCallSets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/SearchCallSets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).SearchCallSets(ctx, req.(*SearchCallSetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_CreateCallSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCallSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).CreateCallSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/CreateCallSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).CreateCallSet(ctx, req.(*CreateCallSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_UpdateCallSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCallSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).UpdateCallSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/UpdateCallSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).UpdateCallSet(ctx, req.(*UpdateCallSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_DeleteCallSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCallSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).DeleteCallSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/DeleteCallSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).DeleteCallSet(ctx, req.(*DeleteCallSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VariantServiceV1_GetCallSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCallSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VariantServiceV1Server).GetCallSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.VariantServiceV1/GetCallSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VariantServiceV1Server).GetCallSet(ctx, req.(*GetCallSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VariantServiceV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.genomics.v1.VariantServiceV1",
	HandlerType: (*VariantServiceV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportVariants",
			Handler:    _VariantServiceV1_ImportVariants_Handler,
		},
		{
			MethodName: "CreateVariantSet",
			Handler:    _VariantServiceV1_CreateVariantSet_Handler,
		},
		{
			MethodName: "ExportVariantSet",
			Handler:    _VariantServiceV1_ExportVariantSet_Handler,
		},
		{
			MethodName: "GetVariantSet",
			Handler:    _VariantServiceV1_GetVariantSet_Handler,
		},
		{
			MethodName: "SearchVariantSets",
			Handler:    _VariantServiceV1_SearchVariantSets_Handler,
		},
		{
			MethodName: "DeleteVariantSet",
			Handler:    _VariantServiceV1_DeleteVariantSet_Handler,
		},
		{
			MethodName: "UpdateVariantSet",
			Handler:    _VariantServiceV1_UpdateVariantSet_Handler,
		},
		{
			MethodName: "SearchVariants",
			Handler:    _VariantServiceV1_SearchVariants_Handler,
		},
		{
			MethodName: "CreateVariant",
			Handler:    _VariantServiceV1_CreateVariant_Handler,
		},
		{
			MethodName: "UpdateVariant",
			Handler:    _VariantServiceV1_UpdateVariant_Handler,
		},
		{
			MethodName: "DeleteVariant",
			Handler:    _VariantServiceV1_DeleteVariant_Handler,
		},
		{
			MethodName: "GetVariant",
			Handler:    _VariantServiceV1_GetVariant_Handler,
		},
		{
			MethodName: "MergeVariants",
			Handler:    _VariantServiceV1_MergeVariants_Handler,
		},
		{
			MethodName: "SearchCallSets",
			Handler:    _VariantServiceV1_SearchCallSets_Handler,
		},
		{
			MethodName: "CreateCallSet",
			Handler:    _VariantServiceV1_CreateCallSet_Handler,
		},
		{
			MethodName: "UpdateCallSet",
			Handler:    _VariantServiceV1_UpdateCallSet_Handler,
		},
		{
			MethodName: "DeleteCallSet",
			Handler:    _VariantServiceV1_DeleteCallSet_Handler,
		},
		{
			MethodName: "GetCallSet",
			Handler:    _VariantServiceV1_GetCallSet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/genomics/v1/variants.proto",
}

func (m *VariantSetMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VariantSetMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x1a
			i++
			v := m.Info[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVariants(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVariants(uint64(len(k))) + msgSize
			i = encodeVarintVariants(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintVariants(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Type))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Number) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Number)))
		i += copy(dAtA[i:], m.Number)
	}
	return i, nil
}

func (m *VariantSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VariantSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatasetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.DatasetId)))
		i += copy(dAtA[i:], m.DatasetId)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			dAtA[i] = 0x22
			i++
			i = encodeVarintVariants(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ReferenceBounds) > 0 {
		for _, msg := range m.ReferenceBounds {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintVariants(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ReferenceSetId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.ReferenceSetId)))
		i += copy(dAtA[i:], m.ReferenceSetId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *Variant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Variant) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ReferenceBases) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.ReferenceBases)))
		i += copy(dAtA[i:], m.ReferenceBases)
	}
	if len(m.AlternateBases) > 0 {
		for _, s := range m.AlternateBases {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Quality != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Variants(dAtA, i, uint64(math.Float64bits(float64(m.Quality))))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x52
			i++
			v := m.Info[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVariants(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVariants(uint64(len(k))) + msgSize
			i = encodeVarintVariants(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintVariants(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if len(m.Calls) > 0 {
		for _, msg := range m.Calls {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintVariants(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Created != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Created))
	}
	if m.End != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.End))
	}
	if len(m.ReferenceName) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.ReferenceName)))
		i += copy(dAtA[i:], m.ReferenceName)
	}
	if len(m.VariantSetId) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantSetId)))
		i += copy(dAtA[i:], m.VariantSetId)
	}
	if m.Start != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Start))
	}
	return i, nil
}

func (m *VariantCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VariantCall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x12
			i++
			v := m.Info[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVariants(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVariants(uint64(len(k))) + msgSize
			i = encodeVarintVariants(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintVariants(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.Phaseset) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Phaseset)))
		i += copy(dAtA[i:], m.Phaseset)
	}
	if len(m.GenotypeLikelihood) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.GenotypeLikelihood)*8))
		for _, num := range m.GenotypeLikelihood {
			f4 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f4)
			i++
			dAtA[i] = uint8(f4 >> 8)
			i++
			dAtA[i] = uint8(f4 >> 16)
			i++
			dAtA[i] = uint8(f4 >> 24)
			i++
			dAtA[i] = uint8(f4 >> 32)
			i++
			dAtA[i] = uint8(f4 >> 40)
			i++
			dAtA[i] = uint8(f4 >> 48)
			i++
			dAtA[i] = uint8(f4 >> 56)
			i++
		}
	}
	if len(m.Genotype) > 0 {
		dAtA6 := make([]byte, len(m.Genotype)*10)
		var j5 int
		for _, num1 := range m.Genotype {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.CallSetId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.CallSetId)))
		i += copy(dAtA[i:], m.CallSetId)
	}
	if len(m.CallSetName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.CallSetName)))
		i += copy(dAtA[i:], m.CallSetName)
	}
	return i, nil
}

func (m *CallSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x22
			i++
			v := m.Info[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovVariants(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovVariants(uint64(len(k))) + msgSize
			i = encodeVarintVariants(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintVariants(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	if m.Created != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Created))
	}
	if len(m.VariantSetIds) > 0 {
		for _, s := range m.VariantSetIds {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SampleId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.SampleId)))
		i += copy(dAtA[i:], m.SampleId)
	}
	return i, nil
}

func (m *ReferenceBound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReferenceBound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReferenceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.ReferenceName)))
		i += copy(dAtA[i:], m.ReferenceName)
	}
	if m.UpperBound != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.UpperBound))
	}
	return i, nil
}

func (m *ImportVariantsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportVariantsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantSetId)))
		i += copy(dAtA[i:], m.VariantSetId)
	}
	if len(m.SourceUris) > 0 {
		for _, s := range m.SourceUris {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Format != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Format))
	}
	if m.NormalizeReferenceNames {
		dAtA[i] = 0x28
		i++
		if m.NormalizeReferenceNames {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.InfoMergeConfig) > 0 {
		for k, _ := range m.InfoMergeConfig {
			dAtA[i] = 0x32
			i++
			v := m.InfoMergeConfig[k]
			mapSize := 1 + len(k) + sovVariants(uint64(len(k))) + 1 + sovVariants(uint64(v))
			i = encodeVarintVariants(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintVariants(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ImportVariantsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportVariantsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallSetIds) > 0 {
		for _, s := range m.CallSetIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CreateVariantSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVariantSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VariantSet != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.VariantSet.Size()))
		n8, err := m.VariantSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *ExportVariantSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportVariantSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantSetId)))
		i += copy(dAtA[i:], m.VariantSetId)
	}
	if len(m.CallSetIds) > 0 {
		for _, s := range m.CallSetIds {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if m.Format != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Format))
	}
	if len(m.BigqueryDataset) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.BigqueryDataset)))
		i += copy(dAtA[i:], m.BigqueryDataset)
	}
	if len(m.BigqueryTable) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.BigqueryTable)))
		i += copy(dAtA[i:], m.BigqueryTable)
	}
	return i, nil
}

func (m *GetVariantSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVariantSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantSetId)))
		i += copy(dAtA[i:], m.VariantSetId)
	}
	return i, nil
}

func (m *SearchVariantSetsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchVariantSetsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatasetIds) > 0 {
		for _, s := range m.DatasetIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *SearchVariantSetsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchVariantSetsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantSets) > 0 {
		for _, msg := range m.VariantSets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *DeleteVariantSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVariantSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantSetId)))
		i += copy(dAtA[i:], m.VariantSetId)
	}
	return i, nil
}

func (m *UpdateVariantSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVariantSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantSetId)))
		i += copy(dAtA[i:], m.VariantSetId)
	}
	if m.VariantSet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.VariantSet.Size()))
		n9, err := m.VariantSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.UpdateMask != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.UpdateMask.Size()))
		n10, err := m.UpdateMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *SearchVariantsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchVariantsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantSetIds) > 0 {
		for _, s := range m.VariantSetIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.VariantName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantName)))
		i += copy(dAtA[i:], m.VariantName)
	}
	if len(m.CallSetIds) > 0 {
		for _, s := range m.CallSetIds {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ReferenceName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.ReferenceName)))
		i += copy(dAtA[i:], m.ReferenceName)
	}
	if m.Start != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.End))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.PageSize))
	}
	if m.MaxCalls != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.MaxCalls))
	}
	return i, nil
}

func (m *SearchVariantsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchVariantsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Variants) > 0 {
		for _, msg := range m.Variants {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *CreateVariantRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateVariantRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Variant != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Variant.Size()))
		n11, err := m.Variant.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *UpdateVariantRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateVariantRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantId)))
		i += copy(dAtA[i:], m.VariantId)
	}
	if m.Variant != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Variant.Size()))
		n12, err := m.Variant.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.UpdateMask != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.UpdateMask.Size()))
		n13, err := m.UpdateMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *DeleteVariantRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteVariantRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantId)))
		i += copy(dAtA[i:], m.VariantId)
	}
	return i, nil
}

func (m *GetVariantRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVariantRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantId)))
		i += copy(dAtA[i:], m.VariantId)
	}
	return i, nil
}

func (m *MergeVariantsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeVariantsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantSetId)))
		i += copy(dAtA[i:], m.VariantSetId)
	}
	if len(m.Variants) > 0 {
		for _, msg := range m.Variants {
			dAtA[i] = 0x12
			i++
			i = encodeVarintVariants(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InfoMergeConfig) > 0 {
		for k, _ := range m.InfoMergeConfig {
			dAtA[i] = 0x1a
			i++
			v := m.InfoMergeConfig[k]
			mapSize := 1 + len(k) + sovVariants(uint64(len(k))) + 1 + sovVariants(uint64(v))
			i = encodeVarintVariants(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintVariants(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *SearchCallSetsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchCallSetsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VariantSetIds) > 0 {
		for _, s := range m.VariantSetIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *SearchCallSetsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchCallSetsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallSets) > 0 {
		for _, msg := range m.CallSets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *CreateCallSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCallSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CallSet != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.CallSet.Size()))
		n14, err := m.CallSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *UpdateCallSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCallSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.CallSetId)))
		i += copy(dAtA[i:], m.CallSetId)
	}
	if m.CallSet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.CallSet.Size()))
		n15, err := m.CallSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.UpdateMask != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.UpdateMask.Size()))
		n16, err := m.UpdateMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *DeleteCallSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCallSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.CallSetId)))
		i += copy(dAtA[i:], m.CallSetId)
	}
	return i, nil
}

func (m *GetCallSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCallSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CallSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.CallSetId)))
		i += copy(dAtA[i:], m.CallSetId)
	}
	return i, nil
}

func (m *StreamVariantsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamVariantsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if len(m.VariantSetId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.VariantSetId)))
		i += copy(dAtA[i:], m.VariantSetId)
	}
	if len(m.CallSetIds) > 0 {
		for _, s := range m.CallSetIds {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ReferenceName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVariants(dAtA, i, uint64(len(m.ReferenceName)))
		i += copy(dAtA[i:], m.ReferenceName)
	}
	if m.Start != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVariants(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *StreamVariantsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamVariantsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Variants) > 0 {
		for _, msg := range m.Variants {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVariants(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Variants(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Variants(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintVariants(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *VariantSetMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVariants(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVariants(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVariants(uint64(mapEntrySize))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovVariants(uint64(m.Type))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.Number)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *VariantSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.DatasetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	if len(m.ReferenceBounds) > 0 {
		for _, e := range m.ReferenceBounds {
			l = e.Size()
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.ReferenceSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *Variant) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.ReferenceBases)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.AlternateBases) > 0 {
		for _, s := range m.AlternateBases {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	if m.Quality != 0 {
		n += 9
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVariants(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVariants(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVariants(uint64(mapEntrySize))
		}
	}
	if len(m.Calls) > 0 {
		for _, e := range m.Calls {
			l = e.Size()
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	if m.Created != 0 {
		n += 1 + sovVariants(uint64(m.Created))
	}
	if m.End != 0 {
		n += 1 + sovVariants(uint64(m.End))
	}
	l = len(m.ReferenceName)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.VariantSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.Start != 0 {
		n += 2 + sovVariants(uint64(m.Start))
	}
	return n
}

func (m *VariantCall) Size() (n int) {
	var l int
	_ = l
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVariants(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVariants(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVariants(uint64(mapEntrySize))
		}
	}
	l = len(m.Phaseset)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.GenotypeLikelihood) > 0 {
		n += 1 + sovVariants(uint64(len(m.GenotypeLikelihood)*8)) + len(m.GenotypeLikelihood)*8
	}
	if len(m.Genotype) > 0 {
		l = 0
		for _, e := range m.Genotype {
			l += sovVariants(uint64(e))
		}
		n += 1 + sovVariants(uint64(l)) + l
	}
	l = len(m.CallSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.CallSetName)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *CallSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVariants(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovVariants(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovVariants(uint64(mapEntrySize))
		}
	}
	if m.Created != 0 {
		n += 1 + sovVariants(uint64(m.Created))
	}
	if len(m.VariantSetIds) > 0 {
		for _, s := range m.VariantSetIds {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.SampleId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *ReferenceBound) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReferenceName)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.UpperBound != 0 {
		n += 1 + sovVariants(uint64(m.UpperBound))
	}
	return n
}

func (m *ImportVariantsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VariantSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.SourceUris) > 0 {
		for _, s := range m.SourceUris {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	if m.Format != 0 {
		n += 1 + sovVariants(uint64(m.Format))
	}
	if m.NormalizeReferenceNames {
		n += 2
	}
	if len(m.InfoMergeConfig) > 0 {
		for k, v := range m.InfoMergeConfig {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovVariants(uint64(len(k))) + 1 + sovVariants(uint64(v))
			n += mapEntrySize + 1 + sovVariants(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ImportVariantsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.CallSetIds) > 0 {
		for _, s := range m.CallSetIds {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	return n
}

func (m *CreateVariantSetRequest) Size() (n int) {
	var l int
	_ = l
	if m.VariantSet != nil {
		l = m.VariantSet.Size()
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *ExportVariantSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VariantSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.CallSetIds) > 0 {
		for _, s := range m.CallSetIds {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.Format != 0 {
		n += 1 + sovVariants(uint64(m.Format))
	}
	l = len(m.BigqueryDataset)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.BigqueryTable)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *GetVariantSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VariantSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *SearchVariantSetsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.DatasetIds) > 0 {
		for _, s := range m.DatasetIds {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovVariants(uint64(m.PageSize))
	}
	return n
}

func (m *SearchVariantSetsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.VariantSets) > 0 {
		for _, e := range m.VariantSets {
			l = e.Size()
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *DeleteVariantSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VariantSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *UpdateVariantSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VariantSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.VariantSet != nil {
		l = m.VariantSet.Size()
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.UpdateMask != nil {
		l = m.UpdateMask.Size()
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *SearchVariantsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.VariantSetIds) > 0 {
		for _, s := range m.VariantSetIds {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.VariantName)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.CallSetIds) > 0 {
		for _, s := range m.CallSetIds {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.ReferenceName)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovVariants(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovVariants(uint64(m.End))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovVariants(uint64(m.PageSize))
	}
	if m.MaxCalls != 0 {
		n += 1 + sovVariants(uint64(m.MaxCalls))
	}
	return n
}

func (m *SearchVariantsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Variants) > 0 {
		for _, e := range m.Variants {
			l = e.Size()
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *CreateVariantRequest) Size() (n int) {
	var l int
	_ = l
	if m.Variant != nil {
		l = m.Variant.Size()
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *UpdateVariantRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VariantId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.Variant != nil {
		l = m.Variant.Size()
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.UpdateMask != nil {
		l = m.UpdateMask.Size()
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *DeleteVariantRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VariantId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *GetVariantRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VariantId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *MergeVariantsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.VariantSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.Variants) > 0 {
		for _, e := range m.Variants {
			l = e.Size()
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	if len(m.InfoMergeConfig) > 0 {
		for k, v := range m.InfoMergeConfig {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovVariants(uint64(len(k))) + 1 + sovVariants(uint64(v))
			n += mapEntrySize + 1 + sovVariants(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SearchCallSetsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.VariantSetIds) > 0 {
		for _, s := range m.VariantSetIds {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovVariants(uint64(m.PageSize))
	}
	return n
}

func (m *SearchCallSetsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.CallSets) > 0 {
		for _, e := range m.CallSets {
			l = e.Size()
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *CreateCallSetRequest) Size() (n int) {
	var l int
	_ = l
	if m.CallSet != nil {
		l = m.CallSet.Size()
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *UpdateCallSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.CallSet != nil {
		l = m.CallSet.Size()
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.UpdateMask != nil {
		l = m.UpdateMask.Size()
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *DeleteCallSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *GetCallSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.CallSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	return n
}

func (m *StreamVariantsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	l = len(m.VariantSetId)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if len(m.CallSetIds) > 0 {
		for _, s := range m.CallSetIds {
			l = len(s)
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	l = len(m.ReferenceName)
	if l > 0 {
		n += 1 + l + sovVariants(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovVariants(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovVariants(uint64(m.End))
	}
	return n
}

func (m *StreamVariantsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Variants) > 0 {
		for _, e := range m.Variants {
			l = e.Size()
			n += 1 + l + sovVariants(uint64(l))
		}
	}
	return n
}

func sovVariants(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVariants(x uint64) (n int) {
	return sovVariants(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VariantSetMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VariantSetMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VariantSetMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]*google_protobuf3.ListValue)
			}
			var mapkey string
			var mapvalue *google_protobuf3.ListValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVariants
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthVariants
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthVariants
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &google_protobuf3.ListValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVariants(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVariants
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (VariantSetMetadata_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Number = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VariantSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VariantSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VariantSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, &VariantSetMetadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceBounds = append(m.ReferenceBounds, &ReferenceBound{})
			if err := m.ReferenceBounds[len(m.ReferenceBounds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Variant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceBases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceBases = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlternateBases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlternateBases = append(m.AlternateBases, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Quality = float64(math.Float64frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]*google_protobuf3.ListValue)
			}
			var mapkey string
			var mapvalue *google_protobuf3.ListValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVariants
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthVariants
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthVariants
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &google_protobuf3.ListValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVariants(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVariants
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calls = append(m.Calls, &VariantCall{})
			if err := m.Calls[len(m.Calls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VariantCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VariantCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VariantCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]*google_protobuf3.ListValue)
			}
			var mapkey string
			var mapvalue *google_protobuf3.ListValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVariants
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthVariants
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthVariants
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &google_protobuf3.ListValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVariants(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVariants
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phaseset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phaseset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.GenotypeLikelihood = append(m.GenotypeLikelihood, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVariants
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.GenotypeLikelihood = append(m.GenotypeLikelihood, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GenotypeLikelihood", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Genotype = append(m.Genotype, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVariants
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Genotype = append(m.Genotype, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Genotype", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]*google_protobuf3.ListValue)
			}
			var mapkey string
			var mapvalue *google_protobuf3.ListValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVariants
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthVariants
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthVariants
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &google_protobuf3.ListValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVariants(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVariants
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetIds = append(m.VariantSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SampleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReferenceBound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReferenceBound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReferenceBound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperBound", wireType)
			}
			m.UpperBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperBound |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportVariantsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportVariantsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportVariantsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceUris", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceUris = append(m.SourceUris, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= (ImportVariantsRequest_Format(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalizeReferenceNames", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NormalizeReferenceNames = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoMergeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoMergeConfig == nil {
				m.InfoMergeConfig = make(map[string]InfoMergeOperation)
			}
			var mapkey string
			var mapvalue InfoMergeOperation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVariants
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (InfoMergeOperation(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVariants(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVariants
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InfoMergeConfig[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportVariantsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportVariantsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportVariantsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSetIds = append(m.CallSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVariantSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVariantSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVariantSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VariantSet == nil {
				m.VariantSet = &VariantSet{}
			}
			if err := m.VariantSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportVariantSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportVariantSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportVariantSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSetIds = append(m.CallSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= (ExportVariantSetRequest_Format(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigqueryDataset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigqueryDataset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigqueryTable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigqueryTable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVariantSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVariantSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVariantSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchVariantSetsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchVariantSetsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchVariantSetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetIds = append(m.DatasetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchVariantSetsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchVariantSetsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchVariantSetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSets = append(m.VariantSets, &VariantSet{})
			if err := m.VariantSets[len(m.VariantSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVariantSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVariantSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVariantSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVariantSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVariantSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVariantSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VariantSet == nil {
				m.VariantSet = &VariantSet{}
			}
			if err := m.VariantSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateMask == nil {
				m.UpdateMask = &google_protobuf2.FieldMask{}
			}
			if err := m.UpdateMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchVariantsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchVariantsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchVariantsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetIds = append(m.VariantSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSetIds = append(m.CallSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCalls", wireType)
			}
			m.MaxCalls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCalls |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchVariantsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchVariantsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchVariantsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variants = append(m.Variants, &Variant{})
			if err := m.Variants[len(m.Variants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateVariantRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateVariantRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateVariantRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Variant == nil {
				m.Variant = &Variant{}
			}
			if err := m.Variant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateVariantRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateVariantRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateVariantRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Variant == nil {
				m.Variant = &Variant{}
			}
			if err := m.Variant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateMask == nil {
				m.UpdateMask = &google_protobuf2.FieldMask{}
			}
			if err := m.UpdateMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteVariantRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteVariantRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteVariantRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVariantRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVariantRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVariantRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeVariantsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeVariantsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeVariantsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variants = append(m.Variants, &Variant{})
			if err := m.Variants[len(m.Variants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoMergeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoMergeConfig == nil {
				m.InfoMergeConfig = make(map[string]InfoMergeOperation)
			}
			var mapkey string
			var mapvalue InfoMergeOperation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthVariants
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVariants
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (InfoMergeOperation(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVariants(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVariants
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InfoMergeConfig[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchCallSetsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchCallSetsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchCallSetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetIds = append(m.VariantSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchCallSetsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchCallSetsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchCallSetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSets = append(m.CallSets, &CallSet{})
			if err := m.CallSets[len(m.CallSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCallSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCallSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCallSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallSet == nil {
				m.CallSet = &CallSet{}
			}
			if err := m.CallSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCallSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCallSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCallSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CallSet == nil {
				m.CallSet = &CallSet{}
			}
			if err := m.CallSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateMask == nil {
				m.UpdateMask = &google_protobuf2.FieldMask{}
			}
			if err := m.UpdateMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCallSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCallSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCallSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCallSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCallSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCallSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamVariantsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamVariantsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamVariantsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariantSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariantSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSetIds = append(m.CallSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamVariantsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamVariantsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamVariantsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVariants
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variants = append(m.Variants, &Variant{})
			if err := m.Variants[len(m.Variants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVariants(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVariants
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVariants(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVariants
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVariants
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthVariants
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVariants
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVariants(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVariants = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVariants   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/genomics/v1/variants.proto", fileDescriptorVariants) }

var fileDescriptorVariants = []byte{
	// 2373 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0x5f, 0x6f, 0xdb, 0xc8,
	0x11, 0x2f, 0x29, 0xc9, 0x96, 0x46, 0x96, 0xcc, 0x6c, 0x7c, 0xb6, 0xa2, 0x24, 0x8e, 0xc3, 0x26,
	0x39, 0x9f, 0x9b, 0x5a, 0x89, 0x0e, 0xb9, 0x5e, 0x7d, 0x77, 0x0d, 0x6c, 0x45, 0xf6, 0xa9, 0xb0,
	0x25, 0x1f, 0xad, 0xa4, 0xcd, 0x01, 0x85, 0x40, 0x4b, 0x6b, 0x85, 0x89, 0x44, 0x2a, 0x24, 0xe5,
	0xc6, 0x09, 0xf2, 0xd0, 0xeb, 0x3f, 0x1c, 0x50, 0xa0, 0x40, 0x0f, 0xe8, 0x53, 0x5f, 0xfb, 0x50,
	0xb4, 0xe8, 0x37, 0xc8, 0x7b, 0x1f, 0xda, 0xa2, 0x40, 0xd1, 0xf7, 0x22, 0xe8, 0x87, 0xe8, 0x63,
	0xb1, 0xcb, 0x5d, 0x8a, 0xa4, 0x56, 0xb4, 0x9c, 0x43, 0x80, 0xbe, 0x69, 0x67, 0x67, 0x67, 0x66,
	0x67, 0x7e, 0x33, 0x3b, 0x43, 0x1b, 0xae, 0x76, 0x2d, 0xab, 0xdb, 0xc3, 0xa5, 0x2e, 0x36, 0xad,
	0xbe, 0xd1, 0x76, 0x4a, 0xc7, 0xb7, 0x4b, 0xc7, 0xba, 0x6d, 0xe8, 0xa6, 0xeb, 0xac, 0x0f, 0x6c,
	0xcb, 0xb5, 0x10, 0xf2, 0x58, 0xd6, 0x39, 0xcb, 0xfa, 0xf1, 0xed, 0xe2, 0x25, 0x76, 0x4c, 0x1f,
	0x18, 0x25, 0xdd, 0x34, 0x2d, 0x57, 0x77, 0x0d, 0xcb, 0x64, 0x27, 0x8a, 0xdf, 0x64, 0xbb, 0x3d,
	0xcb, 0xec, 0xda, 0x43, 0xd3, 0x34, 0xcc, 0x6e, 0xc9, 0x1a, 0x60, 0x3b, 0xc4, 0x74, 0x91, 0x31,
	0xd1, 0xd5, 0xe1, 0xf0, 0xa8, 0x84, 0xfb, 0x03, 0xf7, 0x84, 0x6d, 0xae, 0x44, 0x37, 0x8f, 0x0c,
	0xdc, 0xeb, 0xb4, 0xfa, 0xba, 0xf3, 0x84, 0x71, 0x5c, 0x8a, 0x72, 0x38, 0xae, 0x3d, 0x6c, 0xbb,
	0xde, 0xae, 0xfa, 0x2a, 0x01, 0xe8, 0x81, 0x77, 0x8d, 0x03, 0xec, 0xee, 0x61, 0x57, 0xef, 0xe8,
	0xae, 0x8e, 0x14, 0x48, 0x3c, 0xc1, 0x27, 0x05, 0x69, 0x45, 0x5a, 0xcd, 0x68, 0xe4, 0x27, 0x5a,
	0x80, 0xd4, 0xb1, 0xde, 0x1b, 0xe2, 0x82, 0x4c, 0x69, 0xde, 0x02, 0xdd, 0x83, 0xa4, 0x61, 0x1e,
	0x59, 0x85, 0xc4, 0x4a, 0x62, 0x35, 0x5b, 0xbe, 0xb5, 0x3e, 0xee, 0x81, 0xf5, 0x71, 0xe9, 0xeb,
	0x35, 0xf3, 0xc8, 0xaa, 0x9a, 0xae, 0x7d, 0xa2, 0xd1, 0xd3, 0x28, 0x0f, 0xb2, 0xd1, 0x29, 0x24,
	0xa9, 0x60, 0xd9, 0xe8, 0xa0, 0xbb, 0x90, 0x74, 0x4f, 0x06, 0xb8, 0x90, 0x5a, 0x91, 0x56, 0xf3,
	0xe5, 0x6f, 0x4d, 0x29, 0xb5, 0x79, 0x32, 0xc0, 0x1a, 0x3d, 0x88, 0x56, 0x20, 0xdb, 0xc1, 0x4e,
	0xdb, 0x36, 0x06, 0xc4, 0x91, 0x85, 0x59, 0x2a, 0x39, 0x48, 0x42, 0x8b, 0x30, 0x63, 0x0e, 0xfb,
	0x87, 0xd8, 0x2e, 0xa4, 0xe9, 0x26, 0x5b, 0x15, 0x0f, 0x20, 0xe3, 0x5b, 0x27, 0xf0, 0xc2, 0xad,
	0xa0, 0x17, 0xb2, 0xe5, 0x22, 0x37, 0x8d, 0x3b, 0x77, 0x7d, 0xd7, 0x70, 0xdc, 0x07, 0x84, 0x83,
	0x79, 0x68, 0x43, 0xfe, 0x50, 0x52, 0x1f, 0x42, 0x92, 0x18, 0x87, 0x16, 0x40, 0x69, 0x3e, 0xdc,
	0xaf, 0xb6, 0xee, 0xd7, 0x0f, 0xf6, 0xab, 0x95, 0xda, 0x76, 0xad, 0x7a, 0x4f, 0xf9, 0x06, 0xca,
	0xc2, 0x6c, 0xad, 0xde, 0xac, 0xee, 0x54, 0x35, 0x45, 0x42, 0x19, 0x48, 0x6d, 0xef, 0x36, 0x36,
	0x9b, 0x8a, 0x8c, 0xd2, 0x90, 0xdc, 0xde, 0xdd, 0xdc, 0x51, 0x12, 0x28, 0x07, 0x99, 0xca, 0xa7,
	0x9b, 0xda, 0x66, 0xa5, 0x59, 0xd5, 0x94, 0x24, 0x02, 0x98, 0x39, 0x68, 0x6a, 0xb5, 0xfa, 0x8e,
	0x92, 0x52, 0xff, 0x2c, 0x03, 0x8c, 0x7c, 0x81, 0x2e, 0x03, 0x10, 0x5f, 0x38, 0xd8, 0x6d, 0x19,
	0x1d, 0x66, 0x78, 0x86, 0x51, 0x6a, 0x1d, 0xe6, 0x68, 0xd9, 0x77, 0xf4, 0x16, 0xa4, 0xfb, 0xcc,
	0x7d, 0x85, 0x24, 0x0d, 0xe1, 0x8d, 0xe9, 0x9c, 0xad, 0xf9, 0xe7, 0xd0, 0x1e, 0x28, 0x36, 0x3e,
	0xc2, 0x36, 0x36, 0xdb, 0xb8, 0x75, 0x68, 0x0d, 0xcd, 0x8e, 0x53, 0x48, 0x51, 0x59, 0xaa, 0x48,
	0x96, 0xc6, 0x79, 0xb7, 0x08, 0xab, 0x36, 0x6f, 0x87, 0xd6, 0x0e, 0x5a, 0x0d, 0x8a, 0x63, 0xf7,
	0x98, 0xa1, 0x06, 0xe7, 0x7d, 0xfa, 0x01, 0xbd, 0x0c, 0x82, 0xa4, 0xa9, 0xf7, 0x31, 0x8b, 0x2e,
	0xfd, 0x1d, 0x0d, 0x7c, 0x7a, 0x2c, 0xf0, 0xea, 0x97, 0x49, 0x98, 0x65, 0xf7, 0x19, 0x73, 0xc7,
	0x02, 0xa4, 0x88, 0x14, 0x87, 0xc2, 0x39, 0xa3, 0x79, 0x0b, 0xf4, 0x2e, 0xcc, 0x07, 0x2e, 0xa8,
	0x3b, 0xd8, 0x19, 0x33, 0x68, 0x8b, 0x50, 0x09, 0xa3, 0xde, 0x73, 0xb1, 0x6d, 0xea, 0x2e, 0x67,
	0x9c, 0xa5, 0x82, 0xf2, 0x3e, 0xd9, 0x63, 0x2c, 0xc0, 0xec, 0xd3, 0xa1, 0xde, 0x33, 0xdc, 0x13,
	0x6a, 0xa1, 0xa4, 0xf1, 0x25, 0x81, 0xe5, 0x91, 0x41, 0x98, 0x0b, 0x19, 0x7a, 0x92, 0xad, 0xd0,
	0x77, 0x59, 0x9e, 0x01, 0x75, 0xec, 0xf5, 0x98, 0x20, 0x8d, 0x25, 0xd7, 0x1d, 0x48, 0xb5, 0xf5,
	0x5e, 0xcf, 0x29, 0x64, 0xe9, 0xd9, 0x2b, 0x31, 0x67, 0x2b, 0x7a, 0xaf, 0xa7, 0x79, 0xdc, 0xc4,
	0xc6, 0xb6, 0x8d, 0x75, 0x17, 0x77, 0x0a, 0x73, 0x2b, 0xd2, 0x6a, 0x42, 0xe3, 0x4b, 0x92, 0x15,
	0xd8, 0xec, 0x14, 0x72, 0x94, 0x4a, 0x7e, 0xa2, 0xeb, 0x30, 0x72, 0x45, 0x8b, 0xc6, 0x24, 0x4f,
	0x1d, 0x94, 0xf3, 0xa9, 0x75, 0x12, 0x9c, 0x6b, 0x90, 0x67, 0x15, 0x93, 0x07, 0x76, 0x9e, 0xb2,
	0xcd, 0x1d, 0xfb, 0xf8, 0xaa, 0xd1, 0x20, 0x38, 0xae, 0x6e, 0xbb, 0x05, 0x85, 0x2a, 0xf0, 0x16,
	0x6f, 0x27, 0x2f, 0xff, 0x2e, 0x43, 0x36, 0x70, 0x75, 0xf4, 0x09, 0xf3, 0xb2, 0x4c, 0x3d, 0xf5,
	0xde, 0x29, 0x9e, 0x1a, 0xf3, 0x74, 0x11, 0xd2, 0x83, 0x47, 0x24, 0xc0, 0xd8, 0xa5, 0xa5, 0x2b,
	0xa3, 0xf9, 0x6b, 0x54, 0x82, 0xf3, 0x44, 0x0c, 0xa9, 0x4e, 0xad, 0x9e, 0xf1, 0x04, 0xf7, 0x8c,
	0x47, 0x96, 0x45, 0x90, 0x9d, 0x58, 0x95, 0x34, 0xc4, 0xb7, 0x76, 0xfd, 0x1d, 0x22, 0x8c, 0x53,
	0x29, 0x8a, 0x52, 0x9a, 0xbf, 0x46, 0xcb, 0x90, 0x25, 0x41, 0xe2, 0x5e, 0xf4, 0x50, 0x9e, 0x21,
	0x24, 0xcf, 0x85, 0x2a, 0xe4, 0xfc, 0x7d, 0x1a, 0x8e, 0x8c, 0x97, 0x07, 0x8c, 0x83, 0x04, 0xe3,
	0xed, 0x38, 0xf4, 0x77, 0x32, 0xcc, 0x56, 0x3c, 0x25, 0x2c, 0xb9, 0x24, 0x3f, 0xb9, 0x78, 0xba,
	0xca, 0x81, 0x74, 0xe5, 0xb0, 0x4e, 0x4e, 0x86, 0x35, 0x13, 0x37, 0xe6, 0xec, 0x00, 0x3e, 0x53,
	0x61, 0x7c, 0xde, 0x80, 0xf9, 0x30, 0xcc, 0x1c, 0xea, 0xe6, 0x8c, 0x96, 0x0b, 0xe2, 0xcc, 0x41,
	0x17, 0x21, 0xe3, 0xe8, 0xfd, 0x41, 0x0f, 0x13, 0x1f, 0x7a, 0x45, 0x24, 0xed, 0x11, 0x6a, 0x9d,
	0xb7, 0xe3, 0x9e, 0x1f, 0x42, 0x3e, 0x5c, 0xfe, 0x04, 0x99, 0x23, 0x89, 0x32, 0xe7, 0x0a, 0x64,
	0x87, 0x83, 0x01, 0xb6, 0xbd, 0xfa, 0x4a, 0x95, 0x26, 0x34, 0xa0, 0x24, 0x2a, 0x47, 0xfd, 0x55,
	0x12, 0xde, 0xa9, 0xf5, 0x07, 0x96, 0xed, 0x32, 0x80, 0x3a, 0x1a, 0x7e, 0x3a, 0xc4, 0x8e, 0x2b,
	0x48, 0x3a, 0x49, 0x90, 0x74, 0x57, 0x20, 0xeb, 0x58, 0x43, 0xbb, 0x8d, 0x5b, 0x43, 0xdb, 0x70,
	0x68, 0x02, 0x64, 0x34, 0xf0, 0x48, 0xf7, 0x6d, 0xc3, 0x41, 0x9f, 0xc2, 0xcc, 0x91, 0x65, 0xf7,
	0x75, 0xb7, 0x90, 0xa0, 0x8f, 0xb2, 0xf0, 0xa9, 0x17, 0x5a, 0xb0, 0xbe, 0x4d, 0xcf, 0x69, 0xec,
	0x3c, 0xda, 0x80, 0x0b, 0x26, 0xf9, 0xd5, 0x33, 0x9e, 0xe3, 0x56, 0xf8, 0xf2, 0x0e, 0x0d, 0x65,
	0x5a, 0x5b, 0xf2, 0x19, 0xb4, 0xa0, 0x1b, 0x1c, 0xf4, 0x18, 0xce, 0x91, 0xe0, 0xb7, 0xfa, 0xd8,
	0xee, 0xe2, 0x56, 0xdb, 0x32, 0x8f, 0x8c, 0x2e, 0x0d, 0x6e, 0xb6, 0xfc, 0xbd, 0xe9, 0x0d, 0x22,
	0x81, 0xdd, 0x23, 0x12, 0x2a, 0x54, 0x80, 0x87, 0xaa, 0x79, 0x23, 0x4c, 0x2d, 0x3e, 0x86, 0x05,
	0x11, 0xa3, 0x00, 0x0c, 0x1f, 0x07, 0xc1, 0x90, 0x17, 0x3f, 0xa1, 0xbe, 0xa8, 0x06, 0x6f, 0xef,
	0x82, 0xc0, 0xa8, 0xc3, 0x8c, 0xe7, 0x25, 0xb4, 0x08, 0x68, 0xbb, 0xa1, 0xed, 0x6d, 0x36, 0x23,
	0x4d, 0x42, 0x1e, 0x80, 0xd1, 0x1f, 0x54, 0xb6, 0x15, 0x09, 0x5d, 0x82, 0x02, 0x5b, 0x57, 0x1a,
	0x7b, 0xfb, 0xbb, 0xd5, 0x66, 0xb5, 0xb5, 0x53, 0xad, 0x37, 0xf6, 0x6a, 0x95, 0x03, 0x45, 0x56,
	0x37, 0x60, 0x31, 0x7a, 0x75, 0x67, 0x60, 0x99, 0x0e, 0x79, 0x20, 0xe7, 0x02, 0xa5, 0xc3, 0x29,
	0x48, 0x5e, 0xa4, 0xfd, 0xda, 0xe1, 0xa8, 0x9f, 0xc3, 0x52, 0x85, 0x66, 0xd2, 0xe8, 0xd5, 0xe7,
	0x58, 0xba, 0x0b, 0xd9, 0x00, 0x96, 0xa8, 0x0b, 0xb2, 0xe5, 0xe5, 0xf8, 0x8e, 0x41, 0x83, 0x11,
	0xd0, 0xd4, 0x7f, 0xc9, 0xb0, 0x54, 0x7d, 0x16, 0x30, 0x2c, 0x20, 0x7c, 0x3a, 0xa0, 0x46, 0xed,
	0x97, 0xa3, 0xf6, 0x93, 0x16, 0x68, 0x60, 0x5b, 0x8f, 0x71, 0x9b, 0xca, 0x48, 0x78, 0xb5, 0x91,
	0x51, 0x6a, 0x1d, 0xf4, 0x7d, 0x1f, 0xc8, 0x49, 0x1a, 0xad, 0xb2, 0xc8, 0xfc, 0x09, 0x36, 0x46,
	0xa1, 0xfc, 0x1e, 0x28, 0x87, 0x46, 0xf7, 0xe9, 0x10, 0xdb, 0x27, 0x2d, 0xd6, 0x64, 0xb1, 0xc2,
	0x3f, 0xcf, 0xe9, 0xf7, 0x3c, 0x32, 0x49, 0x74, 0x9f, 0xd5, 0xd5, 0x0f, 0x7b, 0x98, 0xf5, 0x10,
	0x39, 0x4e, 0x6d, 0x12, 0xa2, 0x7a, 0xe7, 0x54, 0x20, 0x9c, 0x87, 0x79, 0x46, 0xdf, 0xaa, 0xed,
	0x7c, 0x76, 0xbf, 0xaa, 0x3d, 0x54, 0x24, 0xf5, 0x63, 0x58, 0xd8, 0xc1, 0x6f, 0xea, 0x53, 0xf5,
	0xc7, 0x50, 0x38, 0xc0, 0xba, 0xdd, 0x7e, 0x34, 0x12, 0xe0, 0x97, 0x8f, 0x2b, 0x90, 0x1d, 0x35,
	0x94, 0x3e, 0x5c, 0xfc, 0x8e, 0xd2, 0x73, 0xb7, 0xde, 0xc5, 0x2d, 0xd7, 0x7a, 0x82, 0x4d, 0x56,
	0xdc, 0x33, 0x84, 0xd2, 0x24, 0x04, 0x52, 0x64, 0xe9, 0xb6, 0x63, 0x3c, 0xc7, 0x34, 0x18, 0x29,
	0x2d, 0x4d, 0x08, 0x07, 0xc6, 0x73, 0xac, 0xfe, 0x42, 0x82, 0x0b, 0x02, 0xcd, 0x0c, 0xaa, 0x9b,
	0x30, 0x17, 0x30, 0xde, 0xd3, 0x7d, 0x3a, 0xdc, 0xb2, 0xa3, 0xab, 0x39, 0xe4, 0x29, 0x30, 0xf1,
	0x33, 0xb7, 0x35, 0x66, 0x61, 0x8e, 0x90, 0xf7, 0xb9, 0x95, 0xea, 0x5d, 0x58, 0xba, 0x87, 0x7b,
	0x58, 0x84, 0xf9, 0xe9, 0x5c, 0xf8, 0x4a, 0x82, 0xa5, 0xfb, 0x83, 0x8e, 0xfe, 0xc6, 0x12, 0xa2,
	0xb9, 0x25, 0x9f, 0x35, 0xb7, 0xd0, 0x47, 0xe4, 0x8d, 0x20, 0x16, 0xd0, 0xe1, 0x8f, 0xe2, 0x50,
	0xf4, 0x30, 0x6d, 0x93, 0xf9, 0x70, 0x4f, 0x77, 0x9e, 0x90, 0xf7, 0x83, 0xb0, 0x93, 0xdf, 0xea,
	0x9f, 0x64, 0x78, 0x27, 0x14, 0x09, 0x1f, 0x00, 0x82, 0xd7, 0x54, 0x12, 0xbd, 0xa6, 0x57, 0x47,
	0xd1, 0x0a, 0x3c, 0xf3, 0xfc, 0x4e, 0x75, 0xaf, 0x39, 0x0f, 0xe7, 0x6e, 0x62, 0x2c, 0x77, 0xc7,
	0x9f, 0xc3, 0xa4, 0xe8, 0x39, 0xf4, 0x5b, 0xc4, 0x54, 0xa0, 0x45, 0xe4, 0x7d, 0xe9, 0xcc, 0xa8,
	0x2f, 0x0d, 0x63, 0x73, 0x36, 0x16, 0x9b, 0xe9, 0x30, 0x36, 0xc9, 0x66, 0x5f, 0x7f, 0xd6, 0xf2,
	0x5a, 0xe7, 0x8c, 0xb7, 0xd9, 0xd7, 0x9f, 0x91, 0x76, 0xc4, 0x51, 0x4f, 0x60, 0x31, 0xea, 0x2d,
	0x06, 0xda, 0xef, 0x40, 0x9a, 0x7f, 0x15, 0x60, 0x80, 0xbd, 0x18, 0x13, 0x43, 0xcd, 0x67, 0x9e,
	0x1a, 0xaa, 0x7b, 0xb0, 0x10, 0x2a, 0xcf, 0x3c, 0x4e, 0x77, 0x60, 0x96, 0xc9, 0x62, 0x75, 0x39,
	0x56, 0x2f, 0xe7, 0x55, 0xff, 0x20, 0xc1, 0x42, 0x08, 0xb8, 0x5c, 0xde, 0x65, 0xe0, 0xe0, 0x0a,
	0x4c, 0x92, 0x8c, 0x52, 0xeb, 0x04, 0xd5, 0xc9, 0xd3, 0xab, 0x8b, 0x82, 0x34, 0x71, 0x26, 0x90,
	0xde, 0x81, 0x85, 0x50, 0x96, 0x4e, 0x67, 0xaa, 0x5a, 0x86, 0x73, 0xa3, 0xe2, 0x38, 0xe5, 0x99,
	0xbf, 0xca, 0xb0, 0x40, 0x9f, 0xeb, 0x37, 0x6b, 0xa7, 0x82, 0x28, 0x90, 0xcf, 0x82, 0x02, 0x43,
	0xd4, 0xe0, 0x78, 0x1f, 0x57, 0x3e, 0x11, 0x49, 0x10, 0xd9, 0xf8, 0x7f, 0xd8, 0xdf, 0xfc, 0x5a,
	0xe2, 0xe5, 0x85, 0xb5, 0xf3, 0x67, 0x2e, 0x2f, 0xa2, 0xe9, 0x21, 0x9c, 0xde, 0x89, 0xd8, 0xf4,
	0x4e, 0x46, 0x9e, 0x9e, 0xe7, 0x3c, 0x83, 0x47, 0x06, 0xb1, 0x0c, 0xfe, 0x10, 0x32, 0xbc, 0x4a,
	0xc5, 0xa6, 0x30, 0x3b, 0xa8, 0xa5, 0x59, 0xfd, 0x9a, 0x3e, 0x85, 0xeb, 0x3c, 0x85, 0xb9, 0x08,
	0xe6, 0x8b, 0x0f, 0x20, 0xcd, 0x35, 0xc7, 0xe5, 0x30, 0x3f, 0x35, 0xcb, 0x14, 0xab, 0x7f, 0xf4,
	0x73, 0x38, 0x22, 0x30, 0x32, 0x27, 0x4a, 0xd1, 0x39, 0x31, 0xa8, 0x50, 0x9e, 0x5e, 0xe1, 0xd7,
	0xcb, 0xe2, 0x0f, 0x78, 0x16, 0x9f, 0xcd, 0x58, 0xf5, 0x7d, 0x9a, 0xc6, 0x67, 0x3c, 0xf4, 0x37,
	0x02, 0x3c, 0xd7, 0xc6, 0x7a, 0x3f, 0x9a, 0xc8, 0xe1, 0x36, 0x51, 0x8a, 0xb6, 0x89, 0xe3, 0x79,
	0x2e, 0x4f, 0xd1, 0x8d, 0xbe, 0xed, 0x17, 0x4d, 0xfd, 0x0c, 0x16, 0xa3, 0xd7, 0xf9, 0x9a, 0x0f,
	0xcf, 0xda, 0x8f, 0x00, 0x8d, 0x27, 0x2f, 0xba, 0x06, 0x2b, 0xb5, 0xfa, 0x76, 0xa3, 0xb5, 0x57,
	0xd5, 0x76, 0xaa, 0xad, 0xc6, 0x7e, 0x55, 0xdb, 0x6c, 0xd6, 0x1a, 0xf5, 0xf1, 0xa9, 0xa4, 0xb6,
	0x53, 0x6f, 0x68, 0xd5, 0x56, 0xbd, 0xfa, 0x03, 0x45, 0x42, 0xe7, 0x20, 0xb7, 0xd7, 0x78, 0x50,
	0x6d, 0x35, 0x1b, 0xad, 0xca, 0xe6, 0xee, 0xee, 0x81, 0x22, 0x97, 0x7f, 0x2f, 0xc1, 0x92, 0x67,
	0xb2, 0x61, 0x76, 0xfd, 0xd6, 0xc5, 0x3e, 0x36, 0xda, 0x18, 0x7d, 0x29, 0x41, 0x3e, 0x7c, 0x1d,
	0x24, 0xfc, 0xe8, 0x22, 0x8c, 0x60, 0x71, 0x6d, 0x1a, 0x56, 0xcf, 0x3b, 0xea, 0xf2, 0x17, 0xff,
	0xfc, 0xcf, 0x57, 0x72, 0x41, 0x3d, 0x1f, 0xfc, 0x6c, 0xbf, 0xe1, 0x50, 0xe6, 0x0d, 0x69, 0xed,
	0x96, 0x54, 0x7e, 0x85, 0x40, 0x09, 0x9b, 0xf7, 0xe0, 0x36, 0x7a, 0x0e, 0xf9, 0xf0, 0x1c, 0x25,
	0xb6, 0x4f, 0x38, 0x66, 0x16, 0x2f, 0x73, 0xd6, 0xc0, 0xd7, 0xfd, 0x75, 0xdf, 0xc3, 0x13, 0x4c,
	0x32, 0xa8, 0xa8, 0x0d, 0x69, 0x0d, 0xfd, 0x5c, 0x02, 0x25, 0x3a, 0x88, 0x21, 0xe1, 0xb7, 0xf0,
	0x09, 0xe3, 0x5a, 0xf1, 0x94, 0xee, 0x51, 0xbd, 0x46, 0x2d, 0x58, 0x56, 0xe7, 0x83, 0x16, 0x60,
	0xd7, 0xd9, 0x08, 0x76, 0xa2, 0xe8, 0x37, 0x12, 0x28, 0xd1, 0x79, 0x48, 0x6c, 0xc7, 0x84, 0xa9,
	0xe9, 0x34, 0x47, 0x94, 0xa9, 0x19, 0x37, 0xd5, 0x77, 0x23, 0x66, 0x94, 0x5e, 0x84, 0x33, 0xf0,
	0xe5, 0x06, 0x7e, 0xc6, 0x9d, 0xf3, 0x53, 0x09, 0x72, 0xa1, 0x89, 0x07, 0xad, 0x8a, 0x2c, 0x12,
	0x0d, 0x45, 0xa7, 0xba, 0x65, 0x95, 0xda, 0xa3, 0xa2, 0x95, 0xd3, 0xec, 0x41, 0x5f, 0x49, 0x70,
	0x6e, 0x6c, 0x7e, 0x41, 0x37, 0x85, 0xb8, 0x9c, 0x30, 0x60, 0x15, 0xbf, 0x3d, 0x25, 0x37, 0x03,
	0xf2, 0x55, 0x6a, 0xdc, 0x45, 0x75, 0x31, 0x6a, 0x9c, 0x43, 0x8f, 0x10, 0xdf, 0xfc, 0x44, 0x02,
	0x25, 0x3a, 0xcd, 0x88, 0x03, 0x36, 0x61, 0xe6, 0x29, 0x2e, 0x8e, 0x95, 0xf2, 0x6a, 0x7f, 0xe0,
	0x9e, 0x70, 0xcf, 0xac, 0x9d, 0xee, 0x99, 0xdf, 0x4a, 0xa0, 0x44, 0xe7, 0x21, 0xb1, 0x0d, 0x13,
	0xa6, 0xa6, 0x53, 0xa3, 0x74, 0x87, 0xda, 0x52, 0x2a, 0x9f, 0x6a, 0x4b, 0x18, 0xcd, 0xbf, 0x24,
	0x25, 0x27, 0xd4, 0xba, 0x4f, 0x28, 0x39, 0xa2, 0x61, 0x68, 0x42, 0xc9, 0x11, 0x4e, 0x02, 0xe2,
	0xfc, 0x0e, 0x84, 0x69, 0x08, 0xb9, 0x50, 0xe2, 0x8a, 0x11, 0x2c, 0xea, 0xf5, 0x8b, 0x71, 0x95,
	0x5d, 0xbd, 0x4c, 0xf5, 0x2e, 0xa9, 0x73, 0xa1, 0xba, 0xe2, 0x77, 0xe0, 0x5f, 0x48, 0x90, 0x0b,
	0xf9, 0x5c, 0xac, 0x57, 0x34, 0x13, 0xc4, 0xeb, 0x5d, 0xa3, 0x7a, 0xaf, 0x95, 0x2f, 0x84, 0xee,
	0xfb, 0x62, 0xd4, 0x65, 0xbf, 0x1c, 0x19, 0xe1, 0x42, 0x2e, 0x84, 0x3d, 0xb1, 0x0d, 0xa2, 0x66,
	0x7f, 0x22, 0x36, 0x59, 0x62, 0xac, 0x4d, 0x56, 0x8f, 0x1c, 0x80, 0x51, 0x41, 0x40, 0xd7, 0xe3,
	0x0b, 0xc6, 0x54, 0x77, 0x66, 0x4a, 0x51, 0x8c, 0xd2, 0x01, 0xe4, 0x42, 0x4d, 0xba, 0xf8, 0xaa,
	0xa2, 0x3e, 0x7e, 0xe2, 0x55, 0x79, 0x84, 0x51, 0x28, 0xc2, 0x74, 0x64, 0x20, 0xc0, 0x1a, 0x41,
	0x9c, 0xf7, 0xb6, 0x71, 0x10, 0x8f, 0x34, 0xe4, 0x71, 0x10, 0x8f, 0xb6, 0xca, 0x61, 0x88, 0xd3,
	0x49, 0x39, 0x5c, 0x89, 0x8e, 0x39, 0xc4, 0xf9, 0xdf, 0x04, 0x62, 0x20, 0x1e, 0x6e, 0xec, 0x8a,
	0x71, 0x8d, 0xa8, 0xaf, 0x77, 0x2e, 0xa8, 0x77, 0xc3, 0xef, 0x65, 0xd1, 0xcf, 0x7c, 0x8c, 0xc7,
	0x2a, 0x16, 0xf5, 0xcc, 0xf1, 0x8a, 0x6f, 0x52, 0xc5, 0x37, 0xca, 0xc5, 0xd0, 0x85, 0x5f, 0x04,
	0x7a, 0xc0, 0x97, 0x01, 0x33, 0x86, 0x1c, 0xe5, 0xb1, 0x56, 0x88, 0x9a, 0xe1, 0x89, 0xa1, 0x57,
	0xa9, 0x01, 0x97, 0xd6, 0x62, 0x0c, 0x40, 0x2e, 0x85, 0x39, 0xd7, 0x39, 0x09, 0xe6, 0x67, 0xb9,
	0x36, 0xd3, 0x8a, 0x62, 0xb4, 0x6e, 0xb9, 0x7f, 0x79, 0xbd, 0x2c, 0xfd, 0xe3, 0xf5, 0xb2, 0xf4,
	0xef, 0xd7, 0xcb, 0x12, 0x2c, 0xb6, 0xad, 0xbe, 0x40, 0xe2, 0x56, 0x8e, 0x63, 0x7c, 0x9f, 0xdc,
	0x6b, 0x5f, 0xfa, 0x7c, 0x83, 0x33, 0x59, 0x3d, 0xdd, 0xec, 0xae, 0x5b, 0x76, 0xb7, 0xd4, 0xc5,
	0x26, 0xbd, 0x75, 0xc9, 0xdb, 0xd2, 0x07, 0x86, 0x13, 0xfc, 0xaf, 0x8b, 0x8f, 0xf8, 0xef, 0xff,
	0x4a, 0xd2, 0xe1, 0x0c, 0xe5, 0x7c, 0xff, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x29, 0x0e,
	0xdb, 0x9e, 0x21, 0x00, 0x00,
}
