// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/genomics/v1/readalignment.proto

package genomics

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf3 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A linear alignment can be represented by one CIGAR string. Describes the
// mapped position and local alignment of the read to the reference.
type LinearAlignment struct {
	// The position of this alignment.
	Position *Position `protobuf:"bytes,1,opt,name=position" json:"position,omitempty"`
	// The mapping quality of this alignment. Represents how likely
	// the read maps to this position as opposed to other locations.
	//
	// Specifically, this is -10 log10 Pr(mapping position is wrong), rounded to
	// the nearest integer.
	MappingQuality int32 `protobuf:"varint,2,opt,name=mapping_quality,json=mappingQuality,proto3" json:"mapping_quality,omitempty"`
	// Represents the local alignment of this sequence (alignment matches, indels,
	// etc) against the reference.
	Cigar []*CigarUnit `protobuf:"bytes,3,rep,name=cigar" json:"cigar,omitempty"`
}

func (m *LinearAlignment) Reset()                    { *m = LinearAlignment{} }
func (m *LinearAlignment) String() string            { return proto.CompactTextString(m) }
func (*LinearAlignment) ProtoMessage()               {}
func (*LinearAlignment) Descriptor() ([]byte, []int) { return fileDescriptorReadalignment, []int{0} }

func (m *LinearAlignment) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *LinearAlignment) GetMappingQuality() int32 {
	if m != nil {
		return m.MappingQuality
	}
	return 0
}

func (m *LinearAlignment) GetCigar() []*CigarUnit {
	if m != nil {
		return m.Cigar
	}
	return nil
}

// A read alignment describes a linear alignment of a string of DNA to a
// [reference sequence][google.genomics.v1.Reference], in addition to metadata
// about the fragment (the molecule of DNA sequenced) and the read (the bases
// which were read by the sequencer). A read is equivalent to a line in a SAM
// file. A read belongs to exactly one read group and exactly one
// [read group set][google.genomics.v1.ReadGroupSet].
//
// For more genomics resource definitions, see [Fundamentals of Google
// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
//
// ### Reverse-stranded reads
//
// Mapped reads (reads having a non-null `alignment`) can be aligned to either
// the forward or the reverse strand of their associated reference. Strandedness
// of a mapped read is encoded by `alignment.position.reverseStrand`.
//
// If we consider the reference to be a forward-stranded coordinate space of
// `[0, reference.length)` with `0` as the left-most position and
// `reference.length` as the right-most position, reads are always aligned left
// to right. That is, `alignment.position.position` always refers to the
// left-most reference coordinate and `alignment.cigar` describes the alignment
// of this read to the reference from left to right. All per-base fields such as
// `alignedSequence` and `alignedQuality` share this same left-to-right
// orientation; this is true of reads which are aligned to either strand. For
// reverse-stranded reads, this means that `alignedSequence` is the reverse
// complement of the bases that were originally reported by the sequencing
// machine.
//
// ### Generating a reference-aligned sequence string
//
// When interacting with mapped reads, it's often useful to produce a string
// representing the local alignment of the read to reference. The following
// pseudocode demonstrates one way of doing this:
//
//     out = ""
//     offset = 0
//     for c in read.alignment.cigar {
//       switch c.operation {
//       case "ALIGNMENT_MATCH", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH":
//         out += read.alignedSequence[offset:offset+c.operationLength]
//         offset += c.operationLength
//         break
//       case "CLIP_SOFT", "INSERT":
//         offset += c.operationLength
//         break
//       case "PAD":
//         out += repeat("*", c.operationLength)
//         break
//       case "DELETE":
//         out += repeat("-", c.operationLength)
//         break
//       case "SKIP":
//         out += repeat(" ", c.operationLength)
//         break
//       case "CLIP_HARD":
//         break
//       }
//     }
//     return out
//
// ### Converting to SAM's CIGAR string
//
// The following pseudocode generates a SAM CIGAR string from the
// `cigar` field. Note that this is a lossy conversion
// (`cigar.referenceSequence` is lost).
//
//     cigarMap = {
//       "ALIGNMENT_MATCH": "M",
//       "INSERT": "I",
//       "DELETE": "D",
//       "SKIP": "N",
//       "CLIP_SOFT": "S",
//       "CLIP_HARD": "H",
//       "PAD": "P",
//       "SEQUENCE_MATCH": "=",
//       "SEQUENCE_MISMATCH": "X",
//     }
//     cigarStr = ""
//     for c in read.alignment.cigar {
//       cigarStr += c.operationLength + cigarMap[c.operation]
//     }
//     return cigarStr
type Read struct {
	// The server-generated read ID, unique across all reads. This is different
	// from the `fragmentName`.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The ID of the read group this read belongs to. A read belongs to exactly
	// one read group. This is a server-generated ID which is distinct from SAM's
	// RG tag (for that value, see
	// [ReadGroup.name][google.genomics.v1.ReadGroup.name]).
	ReadGroupId string `protobuf:"bytes,2,opt,name=read_group_id,json=readGroupId,proto3" json:"read_group_id,omitempty"`
	// The ID of the read group set this read belongs to. A read belongs to
	// exactly one read group set.
	ReadGroupSetId string `protobuf:"bytes,3,opt,name=read_group_set_id,json=readGroupSetId,proto3" json:"read_group_set_id,omitempty"`
	// The fragment name. Equivalent to QNAME (query template name) in SAM.
	FragmentName string `protobuf:"bytes,4,opt,name=fragment_name,json=fragmentName,proto3" json:"fragment_name,omitempty"`
	// The orientation and the distance between reads from the fragment are
	// consistent with the sequencing protocol (SAM flag 0x2).
	ProperPlacement bool `protobuf:"varint,5,opt,name=proper_placement,json=properPlacement,proto3" json:"proper_placement,omitempty"`
	// The fragment is a PCR or optical duplicate (SAM flag 0x400).
	DuplicateFragment bool `protobuf:"varint,6,opt,name=duplicate_fragment,json=duplicateFragment,proto3" json:"duplicate_fragment,omitempty"`
	// The observed length of the fragment, equivalent to TLEN in SAM.
	FragmentLength int32 `protobuf:"varint,7,opt,name=fragment_length,json=fragmentLength,proto3" json:"fragment_length,omitempty"`
	// The read number in sequencing. 0-based and less than numberReads. This
	// field replaces SAM flag 0x40 and 0x80.
	ReadNumber int32 `protobuf:"varint,8,opt,name=read_number,json=readNumber,proto3" json:"read_number,omitempty"`
	// The number of reads in the fragment (extension to SAM flag 0x1).
	NumberReads int32 `protobuf:"varint,9,opt,name=number_reads,json=numberReads,proto3" json:"number_reads,omitempty"`
	// Whether this read did not pass filters, such as platform or vendor quality
	// controls (SAM flag 0x200).
	FailedVendorQualityChecks bool `protobuf:"varint,10,opt,name=failed_vendor_quality_checks,json=failedVendorQualityChecks,proto3" json:"failed_vendor_quality_checks,omitempty"`
	// The linear alignment for this alignment record. This field is null for
	// unmapped reads.
	Alignment *LinearAlignment `protobuf:"bytes,11,opt,name=alignment" json:"alignment,omitempty"`
	// Whether this alignment is secondary. Equivalent to SAM flag 0x100.
	// A secondary alignment represents an alternative to the primary alignment
	// for this read. Aligners may return secondary alignments if a read can map
	// ambiguously to multiple coordinates in the genome. By convention, each read
	// has one and only one alignment where both `secondaryAlignment`
	// and `supplementaryAlignment` are false.
	SecondaryAlignment bool `protobuf:"varint,12,opt,name=secondary_alignment,json=secondaryAlignment,proto3" json:"secondary_alignment,omitempty"`
	// Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
	// Supplementary alignments are used in the representation of a chimeric
	// alignment. In a chimeric alignment, a read is split into multiple
	// linear alignments that map to different reference contigs. The first
	// linear alignment in the read will be designated as the representative
	// alignment; the remaining linear alignments will be designated as
	// supplementary alignments. These alignments may have different mapping
	// quality scores. In each linear alignment in a chimeric alignment, the read
	// will be hard clipped. The `alignedSequence` and
	// `alignedQuality` fields in the alignment record will only
	// represent the bases for its respective linear alignment.
	SupplementaryAlignment bool `protobuf:"varint,13,opt,name=supplementary_alignment,json=supplementaryAlignment,proto3" json:"supplementary_alignment,omitempty"`
	// The bases of the read sequence contained in this alignment record,
	// **without CIGAR operations applied** (equivalent to SEQ in SAM).
	// `alignedSequence` and `alignedQuality` may be
	// shorter than the full read sequence and quality. This will occur if the
	// alignment is part of a chimeric alignment, or if the read was trimmed. When
	// this occurs, the CIGAR for this read will begin/end with a hard clip
	// operator that will indicate the length of the excised sequence.
	AlignedSequence string `protobuf:"bytes,14,opt,name=aligned_sequence,json=alignedSequence,proto3" json:"aligned_sequence,omitempty"`
	// The quality of the read sequence contained in this alignment record
	// (equivalent to QUAL in SAM).
	// `alignedSequence` and `alignedQuality` may be shorter than the full read
	// sequence and quality. This will occur if the alignment is part of a
	// chimeric alignment, or if the read was trimmed. When this occurs, the CIGAR
	// for this read will begin/end with a hard clip operator that will indicate
	// the length of the excised sequence.
	AlignedQuality []int32 `protobuf:"varint,15,rep,packed,name=aligned_quality,json=alignedQuality" json:"aligned_quality,omitempty"`
	// The mapping of the primary alignment of the
	// `(readNumber+1)%numberReads` read in the fragment. It replaces
	// mate position and mate strand in SAM.
	NextMatePosition *Position `protobuf:"bytes,16,opt,name=next_mate_position,json=nextMatePosition" json:"next_mate_position,omitempty"`
	// A map of additional read alignment information. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,17,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Read) Reset()                    { *m = Read{} }
func (m *Read) String() string            { return proto.CompactTextString(m) }
func (*Read) ProtoMessage()               {}
func (*Read) Descriptor() ([]byte, []int) { return fileDescriptorReadalignment, []int{1} }

func (m *Read) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Read) GetReadGroupId() string {
	if m != nil {
		return m.ReadGroupId
	}
	return ""
}

func (m *Read) GetReadGroupSetId() string {
	if m != nil {
		return m.ReadGroupSetId
	}
	return ""
}

func (m *Read) GetFragmentName() string {
	if m != nil {
		return m.FragmentName
	}
	return ""
}

func (m *Read) GetProperPlacement() bool {
	if m != nil {
		return m.ProperPlacement
	}
	return false
}

func (m *Read) GetDuplicateFragment() bool {
	if m != nil {
		return m.DuplicateFragment
	}
	return false
}

func (m *Read) GetFragmentLength() int32 {
	if m != nil {
		return m.FragmentLength
	}
	return 0
}

func (m *Read) GetReadNumber() int32 {
	if m != nil {
		return m.ReadNumber
	}
	return 0
}

func (m *Read) GetNumberReads() int32 {
	if m != nil {
		return m.NumberReads
	}
	return 0
}

func (m *Read) GetFailedVendorQualityChecks() bool {
	if m != nil {
		return m.FailedVendorQualityChecks
	}
	return false
}

func (m *Read) GetAlignment() *LinearAlignment {
	if m != nil {
		return m.Alignment
	}
	return nil
}

func (m *Read) GetSecondaryAlignment() bool {
	if m != nil {
		return m.SecondaryAlignment
	}
	return false
}

func (m *Read) GetSupplementaryAlignment() bool {
	if m != nil {
		return m.SupplementaryAlignment
	}
	return false
}

func (m *Read) GetAlignedSequence() string {
	if m != nil {
		return m.AlignedSequence
	}
	return ""
}

func (m *Read) GetAlignedQuality() []int32 {
	if m != nil {
		return m.AlignedQuality
	}
	return nil
}

func (m *Read) GetNextMatePosition() *Position {
	if m != nil {
		return m.NextMatePosition
	}
	return nil
}

func (m *Read) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

func init() {
	proto.RegisterType((*LinearAlignment)(nil), "google.genomics.v1.LinearAlignment")
	proto.RegisterType((*Read)(nil), "google.genomics.v1.Read")
}
func (m *LinearAlignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinearAlignment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(m.Position.Size()))
		n1, err := m.Position.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.MappingQuality != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(m.MappingQuality))
	}
	if len(m.Cigar) > 0 {
		for _, msg := range m.Cigar {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintReadalignment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Read) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Read) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.ReadGroupId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(len(m.ReadGroupId)))
		i += copy(dAtA[i:], m.ReadGroupId)
	}
	if len(m.ReadGroupSetId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(len(m.ReadGroupSetId)))
		i += copy(dAtA[i:], m.ReadGroupSetId)
	}
	if len(m.FragmentName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(len(m.FragmentName)))
		i += copy(dAtA[i:], m.FragmentName)
	}
	if m.ProperPlacement {
		dAtA[i] = 0x28
		i++
		if m.ProperPlacement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DuplicateFragment {
		dAtA[i] = 0x30
		i++
		if m.DuplicateFragment {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FragmentLength != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(m.FragmentLength))
	}
	if m.ReadNumber != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(m.ReadNumber))
	}
	if m.NumberReads != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(m.NumberReads))
	}
	if m.FailedVendorQualityChecks {
		dAtA[i] = 0x50
		i++
		if m.FailedVendorQualityChecks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Alignment != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(m.Alignment.Size()))
		n2, err := m.Alignment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.SecondaryAlignment {
		dAtA[i] = 0x60
		i++
		if m.SecondaryAlignment {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SupplementaryAlignment {
		dAtA[i] = 0x68
		i++
		if m.SupplementaryAlignment {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.AlignedSequence) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(len(m.AlignedSequence)))
		i += copy(dAtA[i:], m.AlignedSequence)
	}
	if len(m.AlignedQuality) > 0 {
		dAtA4 := make([]byte, len(m.AlignedQuality)*10)
		var j3 int
		for _, num1 := range m.AlignedQuality {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x7a
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.NextMatePosition != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintReadalignment(dAtA, i, uint64(m.NextMatePosition.Size()))
		n5, err := m.NextMatePosition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.Info[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovReadalignment(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovReadalignment(uint64(len(k))) + msgSize
			i = encodeVarintReadalignment(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintReadalignment(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintReadalignment(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	return i, nil
}

func encodeFixed64Readalignment(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Readalignment(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintReadalignment(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LinearAlignment) Size() (n int) {
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovReadalignment(uint64(l))
	}
	if m.MappingQuality != 0 {
		n += 1 + sovReadalignment(uint64(m.MappingQuality))
	}
	if len(m.Cigar) > 0 {
		for _, e := range m.Cigar {
			l = e.Size()
			n += 1 + l + sovReadalignment(uint64(l))
		}
	}
	return n
}

func (m *Read) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovReadalignment(uint64(l))
	}
	l = len(m.ReadGroupId)
	if l > 0 {
		n += 1 + l + sovReadalignment(uint64(l))
	}
	l = len(m.ReadGroupSetId)
	if l > 0 {
		n += 1 + l + sovReadalignment(uint64(l))
	}
	l = len(m.FragmentName)
	if l > 0 {
		n += 1 + l + sovReadalignment(uint64(l))
	}
	if m.ProperPlacement {
		n += 2
	}
	if m.DuplicateFragment {
		n += 2
	}
	if m.FragmentLength != 0 {
		n += 1 + sovReadalignment(uint64(m.FragmentLength))
	}
	if m.ReadNumber != 0 {
		n += 1 + sovReadalignment(uint64(m.ReadNumber))
	}
	if m.NumberReads != 0 {
		n += 1 + sovReadalignment(uint64(m.NumberReads))
	}
	if m.FailedVendorQualityChecks {
		n += 2
	}
	if m.Alignment != nil {
		l = m.Alignment.Size()
		n += 1 + l + sovReadalignment(uint64(l))
	}
	if m.SecondaryAlignment {
		n += 2
	}
	if m.SupplementaryAlignment {
		n += 2
	}
	l = len(m.AlignedSequence)
	if l > 0 {
		n += 1 + l + sovReadalignment(uint64(l))
	}
	if len(m.AlignedQuality) > 0 {
		l = 0
		for _, e := range m.AlignedQuality {
			l += sovReadalignment(uint64(e))
		}
		n += 1 + sovReadalignment(uint64(l)) + l
	}
	if m.NextMatePosition != nil {
		l = m.NextMatePosition.Size()
		n += 2 + l + sovReadalignment(uint64(l))
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovReadalignment(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovReadalignment(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovReadalignment(uint64(mapEntrySize))
		}
	}
	return n
}

func sovReadalignment(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozReadalignment(x uint64) (n int) {
	return sovReadalignment(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LinearAlignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReadalignment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinearAlignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinearAlignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &Position{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingQuality", wireType)
			}
			m.MappingQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MappingQuality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cigar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cigar = append(m.Cigar, &CigarUnit{})
			if err := m.Cigar[len(m.Cigar)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReadalignment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReadalignment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Read) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReadalignment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Read: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Read: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragmentName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProperPlacement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProperPlacement = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DuplicateFragment", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DuplicateFragment = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentLength", wireType)
			}
			m.FragmentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentLength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadNumber", wireType)
			}
			m.ReadNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberReads", wireType)
			}
			m.NumberReads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberReads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedVendorQualityChecks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailedVendorQualityChecks = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Alignment == nil {
				m.Alignment = &LinearAlignment{}
			}
			if err := m.Alignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryAlignment", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SecondaryAlignment = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplementaryAlignment", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupplementaryAlignment = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlignedSequence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlignedSequence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReadalignment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AlignedQuality = append(m.AlignedQuality, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReadalignment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthReadalignment
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReadalignment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AlignedQuality = append(m.AlignedQuality, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AlignedQuality", wireType)
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextMatePosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextMatePosition == nil {
				m.NextMatePosition = &Position{}
			}
			if err := m.NextMatePosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReadalignment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]*google_protobuf3.ListValue)
			}
			var mapkey string
			var mapvalue *google_protobuf3.ListValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReadalignment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReadalignment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthReadalignment
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReadalignment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthReadalignment
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthReadalignment
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &google_protobuf3.ListValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipReadalignment(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthReadalignment
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReadalignment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReadalignment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReadalignment(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReadalignment
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReadalignment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthReadalignment
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowReadalignment
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipReadalignment(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthReadalignment = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReadalignment   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/genomics/v1/readalignment.proto", fileDescriptorReadalignment) }

var fileDescriptorReadalignment = []byte{
	// 700 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xcd, 0x4e, 0xdb, 0x4a,
	0x14, 0xc7, 0xe5, 0x84, 0x70, 0xc9, 0x04, 0x92, 0x30, 0x57, 0xe2, 0xfa, 0x46, 0xdc, 0xdc, 0x10,
	0xa4, 0x36, 0x2c, 0x6a, 0x17, 0x90, 0x5a, 0x44, 0x17, 0x15, 0xa0, 0xb6, 0xa2, 0xa2, 0x28, 0x35,
	0x2a, 0x8b, 0x6e, 0xac, 0xc1, 0x3e, 0x31, 0x23, 0xec, 0x19, 0x33, 0x1e, 0x47, 0xcd, 0x23, 0xf5,
	0x4d, 0xba, 0xec, 0x23, 0x54, 0xac, 0xfb, 0x00, 0x5d, 0x56, 0x33, 0xf6, 0x38, 0xd0, 0x66, 0xd1,
	0x5d, 0xf2, 0x3f, 0xbf, 0xf3, 0xe1, 0xf3, 0x31, 0xe8, 0x51, 0xc4, 0x79, 0x14, 0x83, 0x1b, 0x01,
	0xe3, 0x09, 0x0d, 0x32, 0x77, 0xba, 0xeb, 0x0a, 0x20, 0x21, 0x89, 0x69, 0xc4, 0x12, 0x60, 0xd2,
	0x49, 0x05, 0x97, 0x1c, 0xe3, 0x82, 0x73, 0x0c, 0xe7, 0x4c, 0x77, 0x7b, 0x9b, 0xa5, 0x2f, 0x49,
	0xa9, 0x4b, 0x18, 0xe3, 0x92, 0x48, 0xca, 0x59, 0x56, 0x78, 0xf4, 0xfa, 0x0b, 0x22, 0x07, 0x34,
	0x22, 0xa2, 0xb4, 0x6f, 0x2d, 0xb0, 0xa7, 0x3c, 0xa3, 0x2a, 0x46, 0x89, 0x98, 0x04, 0xfa, 0xdf,
	0x55, 0x3e, 0x71, 0x33, 0x29, 0xf2, 0xa0, 0x2c, 0x69, 0xf8, 0xd9, 0x42, 0x9d, 0x33, 0xca, 0x80,
	0x88, 0x23, 0x53, 0x2c, 0x3e, 0x40, 0x2b, 0x26, 0x86, 0x6d, 0x0d, 0xac, 0x51, 0x6b, 0x6f, 0xd3,
	0xf9, 0xbd, 0x72, 0x67, 0x5c, 0x32, 0x5e, 0x45, 0xe3, 0xc7, 0xa8, 0x93, 0x90, 0x34, 0xa5, 0x2c,
	0xf2, 0x6f, 0x73, 0x12, 0x53, 0x39, 0xb3, 0x6b, 0x03, 0x6b, 0xd4, 0xf0, 0xda, 0xa5, 0xfc, 0xbe,
	0x50, 0xf1, 0x3e, 0x6a, 0xe8, 0xcf, 0xb0, 0xeb, 0x83, 0xfa, 0xa8, 0xb5, 0xf7, 0xdf, 0xa2, 0xf8,
	0x27, 0x0a, 0xf8, 0xc0, 0xa8, 0xf4, 0x0a, 0x76, 0xf8, 0x7d, 0x19, 0x2d, 0x79, 0x40, 0x42, 0xdc,
	0x46, 0x35, 0x1a, 0xea, 0xd2, 0x9a, 0x5e, 0x8d, 0x86, 0x78, 0x88, 0xd6, 0x54, 0xbb, 0xfd, 0x48,
	0xf0, 0x3c, 0xf5, 0x69, 0xa8, 0x93, 0x36, 0xbd, 0x96, 0x12, 0xdf, 0x28, 0xed, 0x34, 0xc4, 0x3b,
	0x68, 0xfd, 0x1e, 0x93, 0x81, 0x54, 0x5c, 0x5d, 0x73, 0xed, 0x8a, 0xbb, 0x00, 0x79, 0x1a, 0xe2,
	0x6d, 0xb4, 0x36, 0x11, 0x24, 0x52, 0xbd, 0xf0, 0x19, 0x49, 0xc0, 0x5e, 0xd2, 0xd8, 0xaa, 0x11,
	0xcf, 0x49, 0x02, 0x78, 0x07, 0x75, 0x53, 0xc1, 0x53, 0x10, 0x7e, 0x1a, 0x93, 0x00, 0x94, 0x6e,
	0x37, 0x06, 0xd6, 0x68, 0xc5, 0xeb, 0x14, 0xfa, 0xd8, 0xc8, 0xf8, 0x09, 0xc2, 0x61, 0x9e, 0xc6,
	0x34, 0x20, 0x12, 0x7c, 0x13, 0xc4, 0x5e, 0xd6, 0xf0, 0x7a, 0x65, 0x79, 0x5d, 0x1a, 0x54, 0x13,
	0xab, 0xf4, 0x31, 0xb0, 0x48, 0x5e, 0xdb, 0x7f, 0x15, 0x4d, 0x34, 0xf2, 0x99, 0x56, 0xf1, 0xff,
	0x48, 0x7f, 0xa1, 0xcf, 0xf2, 0xe4, 0x0a, 0x84, 0xbd, 0xa2, 0x21, 0xa4, 0xa4, 0x73, 0xad, 0xe0,
	0x2d, 0xb4, 0x5a, 0xd8, 0x7c, 0x25, 0x66, 0x76, 0x53, 0x13, 0xad, 0x42, 0x53, 0x9d, 0xcc, 0xf0,
	0x4b, 0xb4, 0x39, 0x21, 0x34, 0x86, 0xd0, 0x9f, 0x02, 0x0b, 0xb9, 0x30, 0x73, 0xf3, 0x83, 0x6b,
	0x08, 0x6e, 0x32, 0x1b, 0xe9, 0x2a, 0xff, 0x2d, 0x98, 0x4b, 0x8d, 0x94, 0x33, 0x3c, 0xd1, 0x00,
	0x3e, 0x42, 0xcd, 0x6a, 0xcd, 0xed, 0x96, 0xde, 0x96, 0xed, 0x45, 0xd3, 0xfc, 0x65, 0xc9, 0xbc,
	0xb9, 0x17, 0x76, 0xd1, 0xdf, 0x19, 0x04, 0x9c, 0x85, 0x44, 0xcc, 0xfc, 0x79, 0xb0, 0x55, 0x9d,
	0x1a, 0x57, 0xa6, 0xf9, 0x82, 0x3e, 0x47, 0xff, 0x64, 0x79, 0x9a, 0xc6, 0xba, 0xbd, 0x0f, 0x9d,
	0xd6, 0xb4, 0xd3, 0xc6, 0x03, 0xf3, 0xdc, 0x71, 0x07, 0x75, 0x35, 0x0a, 0xa1, 0x9f, 0xc1, 0x6d,
	0x0e, 0x2c, 0x00, 0xbb, 0xad, 0x87, 0xdb, 0x29, 0xf5, 0x8b, 0x52, 0x56, 0x53, 0x30, 0xa8, 0x59,
	0xe5, 0xce, 0xa0, 0xae, 0xa6, 0x50, 0xca, 0x66, 0x95, 0xdf, 0x22, 0xcc, 0xe0, 0x93, 0xf4, 0x13,
	0x35, 0xdd, 0xea, 0x6e, 0xba, 0x7f, 0x70, 0x37, 0x5d, 0xe5, 0xf7, 0x8e, 0x48, 0x30, 0x0a, 0x7e,
	0x86, 0x96, 0x28, 0x9b, 0x70, 0x7b, 0x5d, 0x5f, 0xc5, 0x70, 0x91, 0xb7, 0x1a, 0x9b, 0x73, 0xca,
	0x26, 0xfc, 0x15, 0x93, 0x62, 0xe6, 0x69, 0xbe, 0x77, 0x81, 0x9a, 0x95, 0x84, 0xbb, 0xa8, 0x7e,
	0x03, 0xb3, 0xf2, 0x3c, 0xd4, 0x4f, 0xfc, 0x14, 0x35, 0xa6, 0x24, 0xce, 0x41, 0xdf, 0x45, 0x6b,
	0xaf, 0x67, 0xe2, 0x9a, 0x27, 0xc1, 0x39, 0xa3, 0x99, 0xbc, 0x54, 0x84, 0x57, 0x80, 0x87, 0xb5,
	0x03, 0xeb, 0x78, 0xf6, 0xe5, 0xae, 0x6f, 0x7d, 0xbd, 0xeb, 0x5b, 0xdf, 0xee, 0xfa, 0x16, 0xda,
	0x08, 0x78, 0xb2, 0xa0, 0x9e, 0x63, 0xac, 0x0a, 0xaa, 0x3a, 0x3c, 0x56, 0x11, 0xc7, 0xd6, 0xc7,
	0x43, 0x43, 0xf2, 0x98, 0xb0, 0xc8, 0xe1, 0x22, 0x52, 0x4f, 0x94, 0xce, 0xe7, 0x16, 0x26, 0x92,
	0xd2, 0xec, 0xfe, 0xb3, 0xf5, 0xc2, 0xfc, 0xfe, 0x61, 0x59, 0x57, 0xcb, 0x9a, 0xdc, 0xff, 0x19,
	0x00, 0x00, 0xff, 0xff, 0x0f, 0xa3, 0x0c, 0x08, 0x59, 0x05, 0x00, 0x00,
}
