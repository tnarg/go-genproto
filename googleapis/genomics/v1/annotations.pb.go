// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/genomics/v1/annotations.proto

/*
	Package genomics is a generated protocol buffer package.

	It is generated from these files:
		google/genomics/v1/annotations.proto
		google/genomics/v1/cigar.proto
		google/genomics/v1/datasets.proto
		google/genomics/v1/operations.proto
		google/genomics/v1/position.proto
		google/genomics/v1/range.proto
		google/genomics/v1/readalignment.proto
		google/genomics/v1/readgroup.proto
		google/genomics/v1/readgroupset.proto
		google/genomics/v1/reads.proto
		google/genomics/v1/references.proto
		google/genomics/v1/variants.proto

	It has these top-level messages:
		AnnotationSet
		Annotation
		VariantAnnotation
		Transcript
		ExternalId
		CreateAnnotationSetRequest
		GetAnnotationSetRequest
		UpdateAnnotationSetRequest
		DeleteAnnotationSetRequest
		SearchAnnotationSetsRequest
		SearchAnnotationSetsResponse
		CreateAnnotationRequest
		BatchCreateAnnotationsRequest
		BatchCreateAnnotationsResponse
		GetAnnotationRequest
		UpdateAnnotationRequest
		DeleteAnnotationRequest
		SearchAnnotationsRequest
		SearchAnnotationsResponse
		CigarUnit
		Dataset
		ListDatasetsRequest
		ListDatasetsResponse
		CreateDatasetRequest
		UpdateDatasetRequest
		DeleteDatasetRequest
		UndeleteDatasetRequest
		GetDatasetRequest
		OperationMetadata
		OperationEvent
		Position
		Range
		LinearAlignment
		Read
		ReadGroup
		ReadGroupSet
		SearchReadGroupSetsRequest
		SearchReadGroupSetsResponse
		ImportReadGroupSetsRequest
		ImportReadGroupSetsResponse
		ExportReadGroupSetRequest
		UpdateReadGroupSetRequest
		DeleteReadGroupSetRequest
		GetReadGroupSetRequest
		ListCoverageBucketsRequest
		CoverageBucket
		ListCoverageBucketsResponse
		SearchReadsRequest
		SearchReadsResponse
		StreamReadsRequest
		StreamReadsResponse
		Reference
		ReferenceSet
		SearchReferenceSetsRequest
		SearchReferenceSetsResponse
		GetReferenceSetRequest
		SearchReferencesRequest
		SearchReferencesResponse
		GetReferenceRequest
		ListBasesRequest
		ListBasesResponse
		VariantSetMetadata
		VariantSet
		Variant
		VariantCall
		CallSet
		ReferenceBound
		ImportVariantsRequest
		ImportVariantsResponse
		CreateVariantSetRequest
		ExportVariantSetRequest
		GetVariantSetRequest
		SearchVariantSetsRequest
		SearchVariantSetsResponse
		DeleteVariantSetRequest
		UpdateVariantSetRequest
		SearchVariantsRequest
		SearchVariantsResponse
		CreateVariantRequest
		UpdateVariantRequest
		DeleteVariantRequest
		GetVariantRequest
		MergeVariantsRequest
		SearchCallSetsRequest
		SearchCallSetsResponse
		CreateCallSetRequest
		UpdateCallSetRequest
		DeleteCallSetRequest
		GetCallSetRequest
		StreamVariantsRequest
		StreamVariantsResponse
*/
package genomics

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "google.golang.org/genproto/protobuf/field_mask"
import google_protobuf3 "github.com/gogo/protobuf/types"
import google_protobuf4 "github.com/gogo/protobuf/types"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// When an [Annotation][google.genomics.v1.Annotation] or
// [AnnotationSet][google.genomics.v1.AnnotationSet] is created, if `type` is
// not specified it will be set to `GENERIC`.
type AnnotationType int32

const (
	AnnotationType_ANNOTATION_TYPE_UNSPECIFIED AnnotationType = 0
	// A `GENERIC` annotation type should be used when no other annotation
	// type will suffice. This represents an untyped annotation of the reference
	// genome.
	AnnotationType_GENERIC AnnotationType = 1
	// A `VARIANT` annotation type.
	AnnotationType_VARIANT AnnotationType = 2
	// A `GENE` annotation type represents the existence of a gene at the
	// associated reference coordinates. The start coordinate is typically the
	// gene's transcription start site and the end is typically the end of the
	// gene's last exon.
	AnnotationType_GENE AnnotationType = 3
	// A `TRANSCRIPT` annotation type represents the assertion that a
	// particular region of the reference genome may be transcribed as RNA.
	AnnotationType_TRANSCRIPT AnnotationType = 4
)

var AnnotationType_name = map[int32]string{
	0: "ANNOTATION_TYPE_UNSPECIFIED",
	1: "GENERIC",
	2: "VARIANT",
	3: "GENE",
	4: "TRANSCRIPT",
}
var AnnotationType_value = map[string]int32{
	"ANNOTATION_TYPE_UNSPECIFIED": 0,
	"GENERIC":                     1,
	"VARIANT":                     2,
	"GENE":                        3,
	"TRANSCRIPT":                  4,
}

func (x AnnotationType) String() string {
	return proto.EnumName(AnnotationType_name, int32(x))
}
func (AnnotationType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAnnotations, []int{0} }

type VariantAnnotation_Type int32

const (
	VariantAnnotation_TYPE_UNSPECIFIED VariantAnnotation_Type = 0
	// `TYPE_OTHER` should be used when no other Type will suffice.
	// Further explanation of the variant type may be included in the
	// [info][google.genomics.v1.Annotation.info] field.
	VariantAnnotation_TYPE_OTHER VariantAnnotation_Type = 1
	// `INSERTION` indicates an insertion.
	VariantAnnotation_INSERTION VariantAnnotation_Type = 2
	// `DELETION` indicates a deletion.
	VariantAnnotation_DELETION VariantAnnotation_Type = 3
	// `SUBSTITUTION` indicates a block substitution of
	// two or more nucleotides.
	VariantAnnotation_SUBSTITUTION VariantAnnotation_Type = 4
	// `SNP` indicates a single nucleotide polymorphism.
	VariantAnnotation_SNP VariantAnnotation_Type = 5
	// `STRUCTURAL` indicates a large structural variant,
	// including chromosomal fusions, inversions, etc.
	VariantAnnotation_STRUCTURAL VariantAnnotation_Type = 6
	// `CNV` indicates a variation in copy number.
	VariantAnnotation_CNV VariantAnnotation_Type = 7
)

var VariantAnnotation_Type_name = map[int32]string{
	0: "TYPE_UNSPECIFIED",
	1: "TYPE_OTHER",
	2: "INSERTION",
	3: "DELETION",
	4: "SUBSTITUTION",
	5: "SNP",
	6: "STRUCTURAL",
	7: "CNV",
}
var VariantAnnotation_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED": 0,
	"TYPE_OTHER":       1,
	"INSERTION":        2,
	"DELETION":         3,
	"SUBSTITUTION":     4,
	"SNP":              5,
	"STRUCTURAL":       6,
	"CNV":              7,
}

func (x VariantAnnotation_Type) String() string {
	return proto.EnumName(VariantAnnotation_Type_name, int32(x))
}
func (VariantAnnotation_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{2, 0}
}

type VariantAnnotation_Effect int32

const (
	VariantAnnotation_EFFECT_UNSPECIFIED VariantAnnotation_Effect = 0
	// `EFFECT_OTHER` should be used when no other Effect
	// will suffice.
	VariantAnnotation_EFFECT_OTHER VariantAnnotation_Effect = 1
	// `FRAMESHIFT` indicates a mutation in which the insertion or
	// deletion of nucleotides resulted in a frameshift change.
	VariantAnnotation_FRAMESHIFT VariantAnnotation_Effect = 2
	// `FRAME_PRESERVING_INDEL` indicates a mutation in which a
	// multiple of three nucleotides has been inserted or deleted, resulting
	// in no change to the reading frame of the coding sequence.
	VariantAnnotation_FRAME_PRESERVING_INDEL VariantAnnotation_Effect = 3
	// `SYNONYMOUS_SNP` indicates a single nucleotide polymorphism
	// mutation that results in no amino acid change.
	VariantAnnotation_SYNONYMOUS_SNP VariantAnnotation_Effect = 4
	// `NONSYNONYMOUS_SNP` indicates a single nucleotide
	// polymorphism mutation that results in an amino acid change.
	VariantAnnotation_NONSYNONYMOUS_SNP VariantAnnotation_Effect = 5
	// `STOP_GAIN` indicates a mutation that leads to the creation
	// of a stop codon at the variant site. Frameshift mutations creating
	// downstream stop codons do not count as `STOP_GAIN`.
	VariantAnnotation_STOP_GAIN VariantAnnotation_Effect = 6
	// `STOP_LOSS` indicates a mutation that eliminates a
	// stop codon at the variant site.
	VariantAnnotation_STOP_LOSS VariantAnnotation_Effect = 7
	// `SPLICE_SITE_DISRUPTION` indicates that this variant is
	// found in a splice site for the associated transcript, and alters the
	// normal splicing pattern.
	VariantAnnotation_SPLICE_SITE_DISRUPTION VariantAnnotation_Effect = 8
)

var VariantAnnotation_Effect_name = map[int32]string{
	0: "EFFECT_UNSPECIFIED",
	1: "EFFECT_OTHER",
	2: "FRAMESHIFT",
	3: "FRAME_PRESERVING_INDEL",
	4: "SYNONYMOUS_SNP",
	5: "NONSYNONYMOUS_SNP",
	6: "STOP_GAIN",
	7: "STOP_LOSS",
	8: "SPLICE_SITE_DISRUPTION",
}
var VariantAnnotation_Effect_value = map[string]int32{
	"EFFECT_UNSPECIFIED":     0,
	"EFFECT_OTHER":           1,
	"FRAMESHIFT":             2,
	"FRAME_PRESERVING_INDEL": 3,
	"SYNONYMOUS_SNP":         4,
	"NONSYNONYMOUS_SNP":      5,
	"STOP_GAIN":              6,
	"STOP_LOSS":              7,
	"SPLICE_SITE_DISRUPTION": 8,
}

func (x VariantAnnotation_Effect) String() string {
	return proto.EnumName(VariantAnnotation_Effect_name, int32(x))
}
func (VariantAnnotation_Effect) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{2, 1}
}

type VariantAnnotation_ClinicalSignificance int32

const (
	VariantAnnotation_CLINICAL_SIGNIFICANCE_UNSPECIFIED VariantAnnotation_ClinicalSignificance = 0
	// `OTHER` should be used when no other clinical significance
	// value will suffice.
	VariantAnnotation_CLINICAL_SIGNIFICANCE_OTHER VariantAnnotation_ClinicalSignificance = 1
	VariantAnnotation_UNCERTAIN                   VariantAnnotation_ClinicalSignificance = 2
	VariantAnnotation_BENIGN                      VariantAnnotation_ClinicalSignificance = 3
	VariantAnnotation_LIKELY_BENIGN               VariantAnnotation_ClinicalSignificance = 4
	VariantAnnotation_LIKELY_PATHOGENIC           VariantAnnotation_ClinicalSignificance = 5
	VariantAnnotation_PATHOGENIC                  VariantAnnotation_ClinicalSignificance = 6
	VariantAnnotation_DRUG_RESPONSE               VariantAnnotation_ClinicalSignificance = 7
	VariantAnnotation_HISTOCOMPATIBILITY          VariantAnnotation_ClinicalSignificance = 8
	VariantAnnotation_CONFERS_SENSITIVITY         VariantAnnotation_ClinicalSignificance = 9
	VariantAnnotation_RISK_FACTOR                 VariantAnnotation_ClinicalSignificance = 10
	VariantAnnotation_ASSOCIATION                 VariantAnnotation_ClinicalSignificance = 11
	VariantAnnotation_PROTECTIVE                  VariantAnnotation_ClinicalSignificance = 12
	// `MULTIPLE_REPORTED` should be used when multiple clinical
	// signficances are reported for a variant. The original clinical
	// significance values may be provided in the `info` field.
	VariantAnnotation_MULTIPLE_REPORTED VariantAnnotation_ClinicalSignificance = 13
)

var VariantAnnotation_ClinicalSignificance_name = map[int32]string{
	0:  "CLINICAL_SIGNIFICANCE_UNSPECIFIED",
	1:  "CLINICAL_SIGNIFICANCE_OTHER",
	2:  "UNCERTAIN",
	3:  "BENIGN",
	4:  "LIKELY_BENIGN",
	5:  "LIKELY_PATHOGENIC",
	6:  "PATHOGENIC",
	7:  "DRUG_RESPONSE",
	8:  "HISTOCOMPATIBILITY",
	9:  "CONFERS_SENSITIVITY",
	10: "RISK_FACTOR",
	11: "ASSOCIATION",
	12: "PROTECTIVE",
	13: "MULTIPLE_REPORTED",
}
var VariantAnnotation_ClinicalSignificance_value = map[string]int32{
	"CLINICAL_SIGNIFICANCE_UNSPECIFIED": 0,
	"CLINICAL_SIGNIFICANCE_OTHER":       1,
	"UNCERTAIN":                         2,
	"BENIGN":                            3,
	"LIKELY_BENIGN":                     4,
	"LIKELY_PATHOGENIC":                 5,
	"PATHOGENIC":                        6,
	"DRUG_RESPONSE":                     7,
	"HISTOCOMPATIBILITY":                8,
	"CONFERS_SENSITIVITY":               9,
	"RISK_FACTOR":                       10,
	"ASSOCIATION":                       11,
	"PROTECTIVE":                        12,
	"MULTIPLE_REPORTED":                 13,
}

func (x VariantAnnotation_ClinicalSignificance) String() string {
	return proto.EnumName(VariantAnnotation_ClinicalSignificance_name, int32(x))
}
func (VariantAnnotation_ClinicalSignificance) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{2, 2}
}

// An annotation set is a logical grouping of annotations that share consistent
// type information and provenance. Examples of annotation sets include 'all
// genes from refseq', and 'all variant annotations from ClinVar'.
type AnnotationSet struct {
	// The server-generated annotation set ID, unique across all annotation sets.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The dataset to which this annotation set belongs.
	DatasetId string `protobuf:"bytes,2,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
	// The ID of the reference set that defines the coordinate space for this
	// set's annotations.
	ReferenceSetId string `protobuf:"bytes,3,opt,name=reference_set_id,json=referenceSetId,proto3" json:"reference_set_id,omitempty"`
	// The display name for this annotation set.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// The source URI describing the file from which this annotation set was
	// generated, if any.
	SourceUri string `protobuf:"bytes,5,opt,name=source_uri,json=sourceUri,proto3" json:"source_uri,omitempty"`
	// The type of annotations contained within this set.
	Type AnnotationType `protobuf:"varint,6,opt,name=type,proto3,enum=google.genomics.v1.AnnotationType" json:"type,omitempty"`
	// A map of additional read alignment information. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,17,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AnnotationSet) Reset()                    { *m = AnnotationSet{} }
func (m *AnnotationSet) String() string            { return proto.CompactTextString(m) }
func (*AnnotationSet) ProtoMessage()               {}
func (*AnnotationSet) Descriptor() ([]byte, []int) { return fileDescriptorAnnotations, []int{0} }

func (m *AnnotationSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AnnotationSet) GetDatasetId() string {
	if m != nil {
		return m.DatasetId
	}
	return ""
}

func (m *AnnotationSet) GetReferenceSetId() string {
	if m != nil {
		return m.ReferenceSetId
	}
	return ""
}

func (m *AnnotationSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AnnotationSet) GetSourceUri() string {
	if m != nil {
		return m.SourceUri
	}
	return ""
}

func (m *AnnotationSet) GetType() AnnotationType {
	if m != nil {
		return m.Type
	}
	return AnnotationType_ANNOTATION_TYPE_UNSPECIFIED
}

func (m *AnnotationSet) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

// An annotation describes a region of reference genome. The value of an
// annotation may be one of several canonical types, supplemented by arbitrary
// info tags. An annotation is not inherently associated with a specific
// sample or individual (though a client could choose to use annotations in
// this way). Example canonical annotation types are `GENE` and
// `VARIANT`.
type Annotation struct {
	// The server-generated annotation ID, unique across all annotations.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The annotation set to which this annotation belongs.
	AnnotationSetId string `protobuf:"bytes,2,opt,name=annotation_set_id,json=annotationSetId,proto3" json:"annotation_set_id,omitempty"`
	// The display name of this annotation.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The ID of the Google Genomics reference associated with this range.
	ReferenceId string `protobuf:"bytes,4,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"`
	// The display name corresponding to the reference specified by
	// `referenceId`, for example `chr1`, `1`, or `chrX`.
	ReferenceName string `protobuf:"bytes,5,opt,name=reference_name,json=referenceName,proto3" json:"reference_name,omitempty"`
	// The start position of the range on the reference, 0-based inclusive.
	Start int64 `protobuf:"varint,6,opt,name=start,proto3" json:"start,omitempty"`
	// The end position of the range on the reference, 0-based exclusive.
	End int64 `protobuf:"varint,7,opt,name=end,proto3" json:"end,omitempty"`
	// Whether this range refers to the reverse strand, as opposed to the forward
	// strand. Note that regardless of this field, the start/end position of the
	// range always refer to the forward strand.
	ReverseStrand bool `protobuf:"varint,8,opt,name=reverse_strand,json=reverseStrand,proto3" json:"reverse_strand,omitempty"`
	// The data type for this annotation. Must match the containing annotation
	// set's type.
	Type AnnotationType `protobuf:"varint,9,opt,name=type,proto3,enum=google.genomics.v1.AnnotationType" json:"type,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Annotation_Variant
	//	*Annotation_Transcript
	Value isAnnotation_Value `protobuf_oneof:"value"`
	// A map of additional read alignment information. This must be of the form
	// map<string, string[]> (string key mapping to a list of string values).
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,12,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Annotation) Reset()                    { *m = Annotation{} }
func (m *Annotation) String() string            { return proto.CompactTextString(m) }
func (*Annotation) ProtoMessage()               {}
func (*Annotation) Descriptor() ([]byte, []int) { return fileDescriptorAnnotations, []int{1} }

type isAnnotation_Value interface {
	isAnnotation_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Annotation_Variant struct {
	Variant *VariantAnnotation `protobuf:"bytes,10,opt,name=variant,oneof"`
}
type Annotation_Transcript struct {
	Transcript *Transcript `protobuf:"bytes,11,opt,name=transcript,oneof"`
}

func (*Annotation_Variant) isAnnotation_Value()    {}
func (*Annotation_Transcript) isAnnotation_Value() {}

func (m *Annotation) GetValue() isAnnotation_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Annotation) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Annotation) GetAnnotationSetId() string {
	if m != nil {
		return m.AnnotationSetId
	}
	return ""
}

func (m *Annotation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Annotation) GetReferenceId() string {
	if m != nil {
		return m.ReferenceId
	}
	return ""
}

func (m *Annotation) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *Annotation) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Annotation) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Annotation) GetReverseStrand() bool {
	if m != nil {
		return m.ReverseStrand
	}
	return false
}

func (m *Annotation) GetType() AnnotationType {
	if m != nil {
		return m.Type
	}
	return AnnotationType_ANNOTATION_TYPE_UNSPECIFIED
}

func (m *Annotation) GetVariant() *VariantAnnotation {
	if x, ok := m.GetValue().(*Annotation_Variant); ok {
		return x.Variant
	}
	return nil
}

func (m *Annotation) GetTranscript() *Transcript {
	if x, ok := m.GetValue().(*Annotation_Transcript); ok {
		return x.Transcript
	}
	return nil
}

func (m *Annotation) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Annotation) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Annotation_OneofMarshaler, _Annotation_OneofUnmarshaler, _Annotation_OneofSizer, []interface{}{
		(*Annotation_Variant)(nil),
		(*Annotation_Transcript)(nil),
	}
}

func _Annotation_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Annotation)
	// value
	switch x := m.Value.(type) {
	case *Annotation_Variant:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Variant); err != nil {
			return err
		}
	case *Annotation_Transcript:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Transcript); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Annotation.Value has unexpected type %T", x)
	}
	return nil
}

func _Annotation_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Annotation)
	switch tag {
	case 10: // value.variant
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VariantAnnotation)
		err := b.DecodeMessage(msg)
		m.Value = &Annotation_Variant{msg}
		return true, err
	case 11: // value.transcript
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Transcript)
		err := b.DecodeMessage(msg)
		m.Value = &Annotation_Transcript{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Annotation_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Annotation)
	// value
	switch x := m.Value.(type) {
	case *Annotation_Variant:
		s := proto.Size(x.Variant)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Annotation_Transcript:
		s := proto.Size(x.Transcript)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type VariantAnnotation struct {
	// Type has been adapted from ClinVar's list of variant types.
	Type VariantAnnotation_Type `protobuf:"varint,1,opt,name=type,proto3,enum=google.genomics.v1.VariantAnnotation_Type" json:"type,omitempty"`
	// Effect of the variant on the coding sequence.
	Effect VariantAnnotation_Effect `protobuf:"varint,2,opt,name=effect,proto3,enum=google.genomics.v1.VariantAnnotation_Effect" json:"effect,omitempty"`
	// The alternate allele for this variant. If multiple alternate alleles
	// exist at this location, create a separate variant for each one, as they
	// may represent distinct conditions.
	AlternateBases string `protobuf:"bytes,3,opt,name=alternate_bases,json=alternateBases,proto3" json:"alternate_bases,omitempty"`
	// Google annotation ID of the gene affected by this variant. This should
	// be provided when the variant is created.
	GeneId string `protobuf:"bytes,4,opt,name=gene_id,json=geneId,proto3" json:"gene_id,omitempty"`
	// Google annotation IDs of the transcripts affected by this variant. These
	// should be provided when the variant is created.
	TranscriptIds []string `protobuf:"bytes,5,rep,name=transcript_ids,json=transcriptIds" json:"transcript_ids,omitempty"`
	// The set of conditions associated with this variant.
	// A condition describes the way a variant influences human health.
	Conditions []*VariantAnnotation_ClinicalCondition `protobuf:"bytes,6,rep,name=conditions" json:"conditions,omitempty"`
	// Describes the clinical significance of a variant.
	// It is adapted from the ClinVar controlled vocabulary for clinical
	// significance described at:
	// http://www.ncbi.nlm.nih.gov/clinvar/docs/clinsig/
	ClinicalSignificance VariantAnnotation_ClinicalSignificance `protobuf:"varint,7,opt,name=clinical_significance,json=clinicalSignificance,proto3,enum=google.genomics.v1.VariantAnnotation_ClinicalSignificance" json:"clinical_significance,omitempty"`
}

func (m *VariantAnnotation) Reset()                    { *m = VariantAnnotation{} }
func (m *VariantAnnotation) String() string            { return proto.CompactTextString(m) }
func (*VariantAnnotation) ProtoMessage()               {}
func (*VariantAnnotation) Descriptor() ([]byte, []int) { return fileDescriptorAnnotations, []int{2} }

func (m *VariantAnnotation) GetType() VariantAnnotation_Type {
	if m != nil {
		return m.Type
	}
	return VariantAnnotation_TYPE_UNSPECIFIED
}

func (m *VariantAnnotation) GetEffect() VariantAnnotation_Effect {
	if m != nil {
		return m.Effect
	}
	return VariantAnnotation_EFFECT_UNSPECIFIED
}

func (m *VariantAnnotation) GetAlternateBases() string {
	if m != nil {
		return m.AlternateBases
	}
	return ""
}

func (m *VariantAnnotation) GetGeneId() string {
	if m != nil {
		return m.GeneId
	}
	return ""
}

func (m *VariantAnnotation) GetTranscriptIds() []string {
	if m != nil {
		return m.TranscriptIds
	}
	return nil
}

func (m *VariantAnnotation) GetConditions() []*VariantAnnotation_ClinicalCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *VariantAnnotation) GetClinicalSignificance() VariantAnnotation_ClinicalSignificance {
	if m != nil {
		return m.ClinicalSignificance
	}
	return VariantAnnotation_CLINICAL_SIGNIFICANCE_UNSPECIFIED
}

type VariantAnnotation_ClinicalCondition struct {
	// A set of names for the condition.
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
	// The set of external IDs for this condition.
	ExternalIds []*ExternalId `protobuf:"bytes,2,rep,name=external_ids,json=externalIds" json:"external_ids,omitempty"`
	// The MedGen concept id associated with this gene.
	// Search for these IDs at http://www.ncbi.nlm.nih.gov/medgen/
	ConceptId string `protobuf:"bytes,3,opt,name=concept_id,json=conceptId,proto3" json:"concept_id,omitempty"`
	// The OMIM id for this condition.
	// Search for these IDs at http://omim.org/
	OmimId string `protobuf:"bytes,4,opt,name=omim_id,json=omimId,proto3" json:"omim_id,omitempty"`
}

func (m *VariantAnnotation_ClinicalCondition) Reset()         { *m = VariantAnnotation_ClinicalCondition{} }
func (m *VariantAnnotation_ClinicalCondition) String() string { return proto.CompactTextString(m) }
func (*VariantAnnotation_ClinicalCondition) ProtoMessage()    {}
func (*VariantAnnotation_ClinicalCondition) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{2, 0}
}

func (m *VariantAnnotation_ClinicalCondition) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *VariantAnnotation_ClinicalCondition) GetExternalIds() []*ExternalId {
	if m != nil {
		return m.ExternalIds
	}
	return nil
}

func (m *VariantAnnotation_ClinicalCondition) GetConceptId() string {
	if m != nil {
		return m.ConceptId
	}
	return ""
}

func (m *VariantAnnotation_ClinicalCondition) GetOmimId() string {
	if m != nil {
		return m.OmimId
	}
	return ""
}

// A transcript represents the assertion that a particular region of the
// reference genome may be transcribed as RNA.
type Transcript struct {
	// The annotation ID of the gene from which this transcript is transcribed.
	GeneId string `protobuf:"bytes,1,opt,name=gene_id,json=geneId,proto3" json:"gene_id,omitempty"`
	// The <a href="http://en.wikipedia.org/wiki/Exon">exons</a> that compose
	// this transcript. This field should be unset for genomes where transcript
	// splicing does not occur, for example prokaryotes.
	//
	// Introns are regions of the transcript that are not included in the
	// spliced RNA product. Though not explicitly modeled here, intron ranges can
	// be deduced; all regions of this transcript that are not exons are introns.
	//
	// Exonic sequences do not necessarily code for a translational product
	// (amino acids). Only the regions of exons bounded by the
	// [codingSequence][google.genomics.v1.Transcript.coding_sequence] correspond
	// to coding DNA sequence.
	//
	// Exons are ordered by start position and may not overlap.
	Exons []*Transcript_Exon `protobuf:"bytes,2,rep,name=exons" json:"exons,omitempty"`
	// The range of the coding sequence for this transcript, if any. To determine
	// the exact ranges of coding sequence, intersect this range with those of the
	// [exons][google.genomics.v1.Transcript.exons], if any. If there are any
	// [exons][google.genomics.v1.Transcript.exons], the
	// [codingSequence][google.genomics.v1.Transcript.coding_sequence] must start
	// and end within them.
	//
	// Note that in some cases, the reference genome will not exactly match the
	// observed mRNA transcript e.g. due to variance in the source genome from
	// reference. In these cases,
	// [exon.frame][google.genomics.v1.Transcript.Exon.frame] will not necessarily
	// match the expected reference reading frame and coding exon reference bases
	// cannot necessarily be concatenated to produce the original transcript mRNA.
	CodingSequence *Transcript_CodingSequence `protobuf:"bytes,3,opt,name=coding_sequence,json=codingSequence" json:"coding_sequence,omitempty"`
}

func (m *Transcript) Reset()                    { *m = Transcript{} }
func (m *Transcript) String() string            { return proto.CompactTextString(m) }
func (*Transcript) ProtoMessage()               {}
func (*Transcript) Descriptor() ([]byte, []int) { return fileDescriptorAnnotations, []int{3} }

func (m *Transcript) GetGeneId() string {
	if m != nil {
		return m.GeneId
	}
	return ""
}

func (m *Transcript) GetExons() []*Transcript_Exon {
	if m != nil {
		return m.Exons
	}
	return nil
}

func (m *Transcript) GetCodingSequence() *Transcript_CodingSequence {
	if m != nil {
		return m.CodingSequence
	}
	return nil
}

type Transcript_Exon struct {
	// The start position of the exon on this annotation's reference sequence,
	// 0-based inclusive. Note that this is relative to the reference start, and
	// **not** the containing annotation start.
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// The end position of the exon on this annotation's reference sequence,
	// 0-based exclusive. Note that this is relative to the reference start, and
	// *not* the containing annotation start.
	End int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	// The frame of this exon. Contains a value of 0, 1, or 2, which indicates
	// the offset of the first coding base of the exon within the reading frame
	// of the coding DNA sequence, if any. This field is dependent on the
	// strandedness of this annotation (see
	// [Annotation.reverse_strand][google.genomics.v1.Annotation.reverse_strand]).
	// For forward stranded annotations, this offset is relative to the
	// [exon.start][google.genomics.v1.Transcript.Exon.start]. For reverse
	// strand annotations, this offset is relative to the
	// [exon.end][google.genomics.v1.Transcript.Exon.end] `- 1`.
	//
	// Unset if this exon does not intersect the coding sequence. Upon creation
	// of a transcript, the frame must be populated for all or none of the
	// coding exons.
	Frame *google_protobuf4.Int32Value `protobuf:"bytes,3,opt,name=frame" json:"frame,omitempty"`
}

func (m *Transcript_Exon) Reset()                    { *m = Transcript_Exon{} }
func (m *Transcript_Exon) String() string            { return proto.CompactTextString(m) }
func (*Transcript_Exon) ProtoMessage()               {}
func (*Transcript_Exon) Descriptor() ([]byte, []int) { return fileDescriptorAnnotations, []int{3, 0} }

func (m *Transcript_Exon) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Transcript_Exon) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Transcript_Exon) GetFrame() *google_protobuf4.Int32Value {
	if m != nil {
		return m.Frame
	}
	return nil
}

type Transcript_CodingSequence struct {
	// The start of the coding sequence on this annotation's reference sequence,
	// 0-based inclusive. Note that this position is relative to the reference
	// start, and *not* the containing annotation start.
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// The end of the coding sequence on this annotation's reference sequence,
	// 0-based exclusive. Note that this position is relative to the reference
	// start, and *not* the containing annotation start.
	End int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Transcript_CodingSequence) Reset()         { *m = Transcript_CodingSequence{} }
func (m *Transcript_CodingSequence) String() string { return proto.CompactTextString(m) }
func (*Transcript_CodingSequence) ProtoMessage()    {}
func (*Transcript_CodingSequence) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{3, 1}
}

func (m *Transcript_CodingSequence) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Transcript_CodingSequence) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

type ExternalId struct {
	// The name of the source of this data.
	SourceName string `protobuf:"bytes,1,opt,name=source_name,json=sourceName,proto3" json:"source_name,omitempty"`
	// The id used by the source of this data.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ExternalId) Reset()                    { *m = ExternalId{} }
func (m *ExternalId) String() string            { return proto.CompactTextString(m) }
func (*ExternalId) ProtoMessage()               {}
func (*ExternalId) Descriptor() ([]byte, []int) { return fileDescriptorAnnotations, []int{4} }

func (m *ExternalId) GetSourceName() string {
	if m != nil {
		return m.SourceName
	}
	return ""
}

func (m *ExternalId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type CreateAnnotationSetRequest struct {
	// The annotation set to create.
	AnnotationSet *AnnotationSet `protobuf:"bytes,1,opt,name=annotation_set,json=annotationSet" json:"annotation_set,omitempty"`
}

func (m *CreateAnnotationSetRequest) Reset()         { *m = CreateAnnotationSetRequest{} }
func (m *CreateAnnotationSetRequest) String() string { return proto.CompactTextString(m) }
func (*CreateAnnotationSetRequest) ProtoMessage()    {}
func (*CreateAnnotationSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{5}
}

func (m *CreateAnnotationSetRequest) GetAnnotationSet() *AnnotationSet {
	if m != nil {
		return m.AnnotationSet
	}
	return nil
}

type GetAnnotationSetRequest struct {
	// The ID of the annotation set to be retrieved.
	AnnotationSetId string `protobuf:"bytes,1,opt,name=annotation_set_id,json=annotationSetId,proto3" json:"annotation_set_id,omitempty"`
}

func (m *GetAnnotationSetRequest) Reset()         { *m = GetAnnotationSetRequest{} }
func (m *GetAnnotationSetRequest) String() string { return proto.CompactTextString(m) }
func (*GetAnnotationSetRequest) ProtoMessage()    {}
func (*GetAnnotationSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{6}
}

func (m *GetAnnotationSetRequest) GetAnnotationSetId() string {
	if m != nil {
		return m.AnnotationSetId
	}
	return ""
}

type UpdateAnnotationSetRequest struct {
	// The ID of the annotation set to be updated.
	AnnotationSetId string `protobuf:"bytes,1,opt,name=annotation_set_id,json=annotationSetId,proto3" json:"annotation_set_id,omitempty"`
	// The new annotation set.
	AnnotationSet *AnnotationSet `protobuf:"bytes,2,opt,name=annotation_set,json=annotationSet" json:"annotation_set,omitempty"`
	// An optional mask specifying which fields to update. Mutable fields are
	// [name][google.genomics.v1.AnnotationSet.name],
	// [source_uri][google.genomics.v1.AnnotationSet.source_uri], and
	// [info][google.genomics.v1.AnnotationSet.info]. If unspecified, all
	// mutable fields will be updated.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateAnnotationSetRequest) Reset()         { *m = UpdateAnnotationSetRequest{} }
func (m *UpdateAnnotationSetRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateAnnotationSetRequest) ProtoMessage()    {}
func (*UpdateAnnotationSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{7}
}

func (m *UpdateAnnotationSetRequest) GetAnnotationSetId() string {
	if m != nil {
		return m.AnnotationSetId
	}
	return ""
}

func (m *UpdateAnnotationSetRequest) GetAnnotationSet() *AnnotationSet {
	if m != nil {
		return m.AnnotationSet
	}
	return nil
}

func (m *UpdateAnnotationSetRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type DeleteAnnotationSetRequest struct {
	// The ID of the annotation set to be deleted.
	AnnotationSetId string `protobuf:"bytes,1,opt,name=annotation_set_id,json=annotationSetId,proto3" json:"annotation_set_id,omitempty"`
}

func (m *DeleteAnnotationSetRequest) Reset()         { *m = DeleteAnnotationSetRequest{} }
func (m *DeleteAnnotationSetRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteAnnotationSetRequest) ProtoMessage()    {}
func (*DeleteAnnotationSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{8}
}

func (m *DeleteAnnotationSetRequest) GetAnnotationSetId() string {
	if m != nil {
		return m.AnnotationSetId
	}
	return ""
}

type SearchAnnotationSetsRequest struct {
	// Required. The dataset IDs to search within. Caller must have `READ` access
	// to these datasets.
	DatasetIds []string `protobuf:"bytes,1,rep,name=dataset_ids,json=datasetIds" json:"dataset_ids,omitempty"`
	// If specified, only annotation sets associated with the given reference set
	// are returned.
	ReferenceSetId string `protobuf:"bytes,2,opt,name=reference_set_id,json=referenceSetId,proto3" json:"reference_set_id,omitempty"`
	// Only return annotations sets for which a substring of the name matches this
	// string (case insensitive).
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// If specified, only annotation sets that have any of these types are
	// returned.
	Types []AnnotationType `protobuf:"varint,4,rep,packed,name=types,enum=google.genomics.v1.AnnotationType" json:"types,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,5,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The maximum number of results to return in a single page. If unspecified,
	// defaults to 128. The maximum value is 1024.
	PageSize int32 `protobuf:"varint,6,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *SearchAnnotationSetsRequest) Reset()         { *m = SearchAnnotationSetsRequest{} }
func (m *SearchAnnotationSetsRequest) String() string { return proto.CompactTextString(m) }
func (*SearchAnnotationSetsRequest) ProtoMessage()    {}
func (*SearchAnnotationSetsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{9}
}

func (m *SearchAnnotationSetsRequest) GetDatasetIds() []string {
	if m != nil {
		return m.DatasetIds
	}
	return nil
}

func (m *SearchAnnotationSetsRequest) GetReferenceSetId() string {
	if m != nil {
		return m.ReferenceSetId
	}
	return ""
}

func (m *SearchAnnotationSetsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SearchAnnotationSetsRequest) GetTypes() []AnnotationType {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *SearchAnnotationSetsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchAnnotationSetsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

type SearchAnnotationSetsResponse struct {
	// The matching annotation sets.
	AnnotationSets []*AnnotationSet `protobuf:"bytes,1,rep,name=annotation_sets,json=annotationSets" json:"annotation_sets,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *SearchAnnotationSetsResponse) Reset()         { *m = SearchAnnotationSetsResponse{} }
func (m *SearchAnnotationSetsResponse) String() string { return proto.CompactTextString(m) }
func (*SearchAnnotationSetsResponse) ProtoMessage()    {}
func (*SearchAnnotationSetsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{10}
}

func (m *SearchAnnotationSetsResponse) GetAnnotationSets() []*AnnotationSet {
	if m != nil {
		return m.AnnotationSets
	}
	return nil
}

func (m *SearchAnnotationSetsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type CreateAnnotationRequest struct {
	// The annotation to be created.
	Annotation *Annotation `protobuf:"bytes,1,opt,name=annotation" json:"annotation,omitempty"`
}

func (m *CreateAnnotationRequest) Reset()         { *m = CreateAnnotationRequest{} }
func (m *CreateAnnotationRequest) String() string { return proto.CompactTextString(m) }
func (*CreateAnnotationRequest) ProtoMessage()    {}
func (*CreateAnnotationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{11}
}

func (m *CreateAnnotationRequest) GetAnnotation() *Annotation {
	if m != nil {
		return m.Annotation
	}
	return nil
}

type BatchCreateAnnotationsRequest struct {
	// The annotations to be created. At most 4096 can be specified in a single
	// request.
	Annotations []*Annotation `protobuf:"bytes,1,rep,name=annotations" json:"annotations,omitempty"`
	// A unique request ID which enables the server to detect duplicated requests.
	// If provided, duplicated requests will result in the same response; if not
	// provided, duplicated requests may result in duplicated data. For a given
	// annotation set, callers should not reuse `request_id`s when writing
	// different batches of annotations - behavior in this case is undefined.
	// A common approach is to use a UUID. For batch jobs where worker crashes are
	// a possibility, consider using some unique variant of a worker or run ID.
	RequestId string `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *BatchCreateAnnotationsRequest) Reset()         { *m = BatchCreateAnnotationsRequest{} }
func (m *BatchCreateAnnotationsRequest) String() string { return proto.CompactTextString(m) }
func (*BatchCreateAnnotationsRequest) ProtoMessage()    {}
func (*BatchCreateAnnotationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{12}
}

func (m *BatchCreateAnnotationsRequest) GetAnnotations() []*Annotation {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *BatchCreateAnnotationsRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

type BatchCreateAnnotationsResponse struct {
	// The resulting per-annotation entries, ordered consistently with the
	// original request.
	Entries []*BatchCreateAnnotationsResponse_Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *BatchCreateAnnotationsResponse) Reset()         { *m = BatchCreateAnnotationsResponse{} }
func (m *BatchCreateAnnotationsResponse) String() string { return proto.CompactTextString(m) }
func (*BatchCreateAnnotationsResponse) ProtoMessage()    {}
func (*BatchCreateAnnotationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{13}
}

func (m *BatchCreateAnnotationsResponse) GetEntries() []*BatchCreateAnnotationsResponse_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type BatchCreateAnnotationsResponse_Entry struct {
	// The creation status.
	Status *google_rpc.Status `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	// The created annotation, if creation was successful.
	Annotation *Annotation `protobuf:"bytes,2,opt,name=annotation" json:"annotation,omitempty"`
}

func (m *BatchCreateAnnotationsResponse_Entry) Reset()         { *m = BatchCreateAnnotationsResponse_Entry{} }
func (m *BatchCreateAnnotationsResponse_Entry) String() string { return proto.CompactTextString(m) }
func (*BatchCreateAnnotationsResponse_Entry) ProtoMessage()    {}
func (*BatchCreateAnnotationsResponse_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{13, 0}
}

func (m *BatchCreateAnnotationsResponse_Entry) GetStatus() *google_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BatchCreateAnnotationsResponse_Entry) GetAnnotation() *Annotation {
	if m != nil {
		return m.Annotation
	}
	return nil
}

type GetAnnotationRequest struct {
	// The ID of the annotation to be retrieved.
	AnnotationId string `protobuf:"bytes,1,opt,name=annotation_id,json=annotationId,proto3" json:"annotation_id,omitempty"`
}

func (m *GetAnnotationRequest) Reset()                    { *m = GetAnnotationRequest{} }
func (m *GetAnnotationRequest) String() string            { return proto.CompactTextString(m) }
func (*GetAnnotationRequest) ProtoMessage()               {}
func (*GetAnnotationRequest) Descriptor() ([]byte, []int) { return fileDescriptorAnnotations, []int{14} }

func (m *GetAnnotationRequest) GetAnnotationId() string {
	if m != nil {
		return m.AnnotationId
	}
	return ""
}

type UpdateAnnotationRequest struct {
	// The ID of the annotation to be updated.
	AnnotationId string `protobuf:"bytes,1,opt,name=annotation_id,json=annotationId,proto3" json:"annotation_id,omitempty"`
	// The new annotation.
	Annotation *Annotation `protobuf:"bytes,2,opt,name=annotation" json:"annotation,omitempty"`
	// An optional mask specifying which fields to update. Mutable fields are
	// [name][google.genomics.v1.Annotation.name],
	// [variant][google.genomics.v1.Annotation.variant],
	// [transcript][google.genomics.v1.Annotation.transcript], and
	// [info][google.genomics.v1.Annotation.info]. If unspecified, all mutable
	// fields will be updated.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateAnnotationRequest) Reset()         { *m = UpdateAnnotationRequest{} }
func (m *UpdateAnnotationRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateAnnotationRequest) ProtoMessage()    {}
func (*UpdateAnnotationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{15}
}

func (m *UpdateAnnotationRequest) GetAnnotationId() string {
	if m != nil {
		return m.AnnotationId
	}
	return ""
}

func (m *UpdateAnnotationRequest) GetAnnotation() *Annotation {
	if m != nil {
		return m.Annotation
	}
	return nil
}

func (m *UpdateAnnotationRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type DeleteAnnotationRequest struct {
	// The ID of the annotation to be deleted.
	AnnotationId string `protobuf:"bytes,1,opt,name=annotation_id,json=annotationId,proto3" json:"annotation_id,omitempty"`
}

func (m *DeleteAnnotationRequest) Reset()         { *m = DeleteAnnotationRequest{} }
func (m *DeleteAnnotationRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteAnnotationRequest) ProtoMessage()    {}
func (*DeleteAnnotationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{16}
}

func (m *DeleteAnnotationRequest) GetAnnotationId() string {
	if m != nil {
		return m.AnnotationId
	}
	return ""
}

type SearchAnnotationsRequest struct {
	// Required. The annotation sets to search within. The caller must have
	// `READ` access to these annotation sets.
	// All queried annotation sets must have the same type.
	AnnotationSetIds []string `protobuf:"bytes,1,rep,name=annotation_set_ids,json=annotationSetIds" json:"annotation_set_ids,omitempty"`
	// Required. `reference_id` or `reference_name` must be set.
	//
	// Types that are valid to be assigned to Reference:
	//	*SearchAnnotationsRequest_ReferenceId
	//	*SearchAnnotationsRequest_ReferenceName
	Reference isSearchAnnotationsRequest_Reference `protobuf_oneof:"reference"`
	// The start position of the range on the reference, 0-based inclusive. If
	// specified,
	// [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
	// [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
	// must be specified. Defaults to 0.
	Start int64 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	// The end position of the range on the reference, 0-based exclusive. If
	// [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
	// [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
	// must be specified, Defaults to the length of the reference.
	End int64 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,6,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The maximum number of results to return in a single page. If unspecified,
	// defaults to 256. The maximum value is 2048.
	PageSize int32 `protobuf:"varint,7,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *SearchAnnotationsRequest) Reset()         { *m = SearchAnnotationsRequest{} }
func (m *SearchAnnotationsRequest) String() string { return proto.CompactTextString(m) }
func (*SearchAnnotationsRequest) ProtoMessage()    {}
func (*SearchAnnotationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{17}
}

type isSearchAnnotationsRequest_Reference interface {
	isSearchAnnotationsRequest_Reference()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SearchAnnotationsRequest_ReferenceId struct {
	ReferenceId string `protobuf:"bytes,2,opt,name=reference_id,json=referenceId,proto3,oneof"`
}
type SearchAnnotationsRequest_ReferenceName struct {
	ReferenceName string `protobuf:"bytes,3,opt,name=reference_name,json=referenceName,proto3,oneof"`
}

func (*SearchAnnotationsRequest_ReferenceId) isSearchAnnotationsRequest_Reference()   {}
func (*SearchAnnotationsRequest_ReferenceName) isSearchAnnotationsRequest_Reference() {}

func (m *SearchAnnotationsRequest) GetReference() isSearchAnnotationsRequest_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *SearchAnnotationsRequest) GetAnnotationSetIds() []string {
	if m != nil {
		return m.AnnotationSetIds
	}
	return nil
}

func (m *SearchAnnotationsRequest) GetReferenceId() string {
	if x, ok := m.GetReference().(*SearchAnnotationsRequest_ReferenceId); ok {
		return x.ReferenceId
	}
	return ""
}

func (m *SearchAnnotationsRequest) GetReferenceName() string {
	if x, ok := m.GetReference().(*SearchAnnotationsRequest_ReferenceName); ok {
		return x.ReferenceName
	}
	return ""
}

func (m *SearchAnnotationsRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchAnnotationsRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchAnnotationsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchAnnotationsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SearchAnnotationsRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SearchAnnotationsRequest_OneofMarshaler, _SearchAnnotationsRequest_OneofUnmarshaler, _SearchAnnotationsRequest_OneofSizer, []interface{}{
		(*SearchAnnotationsRequest_ReferenceId)(nil),
		(*SearchAnnotationsRequest_ReferenceName)(nil),
	}
}

func _SearchAnnotationsRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SearchAnnotationsRequest)
	// reference
	switch x := m.Reference.(type) {
	case *SearchAnnotationsRequest_ReferenceId:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ReferenceId)
	case *SearchAnnotationsRequest_ReferenceName:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.ReferenceName)
	case nil:
	default:
		return fmt.Errorf("SearchAnnotationsRequest.Reference has unexpected type %T", x)
	}
	return nil
}

func _SearchAnnotationsRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SearchAnnotationsRequest)
	switch tag {
	case 2: // reference.reference_id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Reference = &SearchAnnotationsRequest_ReferenceId{x}
		return true, err
	case 3: // reference.reference_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Reference = &SearchAnnotationsRequest_ReferenceName{x}
		return true, err
	default:
		return false, nil
	}
}

func _SearchAnnotationsRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SearchAnnotationsRequest)
	// reference
	switch x := m.Reference.(type) {
	case *SearchAnnotationsRequest_ReferenceId:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ReferenceId)))
		n += len(x.ReferenceId)
	case *SearchAnnotationsRequest_ReferenceName:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ReferenceName)))
		n += len(x.ReferenceName)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SearchAnnotationsResponse struct {
	// The matching annotations.
	Annotations []*Annotation `protobuf:"bytes,1,rep,name=annotations" json:"annotations,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *SearchAnnotationsResponse) Reset()         { *m = SearchAnnotationsResponse{} }
func (m *SearchAnnotationsResponse) String() string { return proto.CompactTextString(m) }
func (*SearchAnnotationsResponse) ProtoMessage()    {}
func (*SearchAnnotationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAnnotations, []int{18}
}

func (m *SearchAnnotationsResponse) GetAnnotations() []*Annotation {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *SearchAnnotationsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func init() {
	proto.RegisterType((*AnnotationSet)(nil), "google.genomics.v1.AnnotationSet")
	proto.RegisterType((*Annotation)(nil), "google.genomics.v1.Annotation")
	proto.RegisterType((*VariantAnnotation)(nil), "google.genomics.v1.VariantAnnotation")
	proto.RegisterType((*VariantAnnotation_ClinicalCondition)(nil), "google.genomics.v1.VariantAnnotation.ClinicalCondition")
	proto.RegisterType((*Transcript)(nil), "google.genomics.v1.Transcript")
	proto.RegisterType((*Transcript_Exon)(nil), "google.genomics.v1.Transcript.Exon")
	proto.RegisterType((*Transcript_CodingSequence)(nil), "google.genomics.v1.Transcript.CodingSequence")
	proto.RegisterType((*ExternalId)(nil), "google.genomics.v1.ExternalId")
	proto.RegisterType((*CreateAnnotationSetRequest)(nil), "google.genomics.v1.CreateAnnotationSetRequest")
	proto.RegisterType((*GetAnnotationSetRequest)(nil), "google.genomics.v1.GetAnnotationSetRequest")
	proto.RegisterType((*UpdateAnnotationSetRequest)(nil), "google.genomics.v1.UpdateAnnotationSetRequest")
	proto.RegisterType((*DeleteAnnotationSetRequest)(nil), "google.genomics.v1.DeleteAnnotationSetRequest")
	proto.RegisterType((*SearchAnnotationSetsRequest)(nil), "google.genomics.v1.SearchAnnotationSetsRequest")
	proto.RegisterType((*SearchAnnotationSetsResponse)(nil), "google.genomics.v1.SearchAnnotationSetsResponse")
	proto.RegisterType((*CreateAnnotationRequest)(nil), "google.genomics.v1.CreateAnnotationRequest")
	proto.RegisterType((*BatchCreateAnnotationsRequest)(nil), "google.genomics.v1.BatchCreateAnnotationsRequest")
	proto.RegisterType((*BatchCreateAnnotationsResponse)(nil), "google.genomics.v1.BatchCreateAnnotationsResponse")
	proto.RegisterType((*BatchCreateAnnotationsResponse_Entry)(nil), "google.genomics.v1.BatchCreateAnnotationsResponse.Entry")
	proto.RegisterType((*GetAnnotationRequest)(nil), "google.genomics.v1.GetAnnotationRequest")
	proto.RegisterType((*UpdateAnnotationRequest)(nil), "google.genomics.v1.UpdateAnnotationRequest")
	proto.RegisterType((*DeleteAnnotationRequest)(nil), "google.genomics.v1.DeleteAnnotationRequest")
	proto.RegisterType((*SearchAnnotationsRequest)(nil), "google.genomics.v1.SearchAnnotationsRequest")
	proto.RegisterType((*SearchAnnotationsResponse)(nil), "google.genomics.v1.SearchAnnotationsResponse")
	proto.RegisterEnum("google.genomics.v1.AnnotationType", AnnotationType_name, AnnotationType_value)
	proto.RegisterEnum("google.genomics.v1.VariantAnnotation_Type", VariantAnnotation_Type_name, VariantAnnotation_Type_value)
	proto.RegisterEnum("google.genomics.v1.VariantAnnotation_Effect", VariantAnnotation_Effect_name, VariantAnnotation_Effect_value)
	proto.RegisterEnum("google.genomics.v1.VariantAnnotation_ClinicalSignificance", VariantAnnotation_ClinicalSignificance_name, VariantAnnotation_ClinicalSignificance_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AnnotationServiceV1 service

type AnnotationServiceV1Client interface {
	// Creates a new annotation set. Caller must have WRITE permission for the
	// associated dataset.
	//
	// The following fields are required:
	//
	//   * [datasetId][google.genomics.v1.AnnotationSet.dataset_id]
	//   * [referenceSetId][google.genomics.v1.AnnotationSet.reference_set_id]
	//
	// All other fields may be optionally specified, unless documented as being
	// server-generated (for example, the `id` field).
	CreateAnnotationSet(ctx context.Context, in *CreateAnnotationSetRequest, opts ...grpc.CallOption) (*AnnotationSet, error)
	// Gets an annotation set. Caller must have READ permission for
	// the associated dataset.
	GetAnnotationSet(ctx context.Context, in *GetAnnotationSetRequest, opts ...grpc.CallOption) (*AnnotationSet, error)
	// Updates an annotation set. The update must respect all mutability
	// restrictions and other invariants described on the annotation set resource.
	// Caller must have WRITE permission for the associated dataset.
	UpdateAnnotationSet(ctx context.Context, in *UpdateAnnotationSetRequest, opts ...grpc.CallOption) (*AnnotationSet, error)
	// Deletes an annotation set. Caller must have WRITE permission
	// for the associated annotation set.
	DeleteAnnotationSet(ctx context.Context, in *DeleteAnnotationSetRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	// Searches for annotation sets that match the given criteria. Annotation sets
	// are returned in an unspecified order. This order is consistent, such that
	// two queries for the same content (regardless of page size) yield annotation
	// sets in the same order across their respective streams of paginated
	// responses. Caller must have READ permission for the queried datasets.
	SearchAnnotationSets(ctx context.Context, in *SearchAnnotationSetsRequest, opts ...grpc.CallOption) (*SearchAnnotationSetsResponse, error)
	// Creates a new annotation. Caller must have WRITE permission
	// for the associated annotation set.
	//
	// The following fields are required:
	//
	// * [annotationSetId][google.genomics.v1.Annotation.annotation_set_id]
	// * [referenceName][google.genomics.v1.Annotation.reference_name] or
	//   [referenceId][google.genomics.v1.Annotation.reference_id]
	//
	// ### Transcripts
	//
	// For annotations of type TRANSCRIPT, the following fields of
	// [transcript][google.genomics.v1.Annotation.transcript] must be provided:
	//
	// * [exons.start][google.genomics.v1.Transcript.Exon.start]
	// * [exons.end][google.genomics.v1.Transcript.Exon.end]
	//
	// All other fields may be optionally specified, unless documented as being
	// server-generated (for example, the `id` field). The annotated
	// range must be no longer than 100Mbp (mega base pairs). See the
	// [Annotation resource][google.genomics.v1.Annotation]
	// for additional restrictions on each field.
	CreateAnnotation(ctx context.Context, in *CreateAnnotationRequest, opts ...grpc.CallOption) (*Annotation, error)
	// Creates one or more new annotations atomically. All annotations must
	// belong to the same annotation set. Caller must have WRITE
	// permission for this annotation set. For optimal performance, batch
	// positionally adjacent annotations together.
	//
	// If the request has a systemic issue, such as an attempt to write to
	// an inaccessible annotation set, the entire RPC will fail accordingly. For
	// lesser data issues, when possible an error will be isolated to the
	// corresponding batch entry in the response; the remaining well formed
	// annotations will be created normally.
	//
	// For details on the requirements for each individual annotation resource,
	// see
	// [CreateAnnotation][google.genomics.v1.AnnotationServiceV1.CreateAnnotation].
	BatchCreateAnnotations(ctx context.Context, in *BatchCreateAnnotationsRequest, opts ...grpc.CallOption) (*BatchCreateAnnotationsResponse, error)
	// Gets an annotation. Caller must have READ permission
	// for the associated annotation set.
	GetAnnotation(ctx context.Context, in *GetAnnotationRequest, opts ...grpc.CallOption) (*Annotation, error)
	// Updates an annotation. Caller must have
	// WRITE permission for the associated dataset.
	UpdateAnnotation(ctx context.Context, in *UpdateAnnotationRequest, opts ...grpc.CallOption) (*Annotation, error)
	// Deletes an annotation. Caller must have WRITE permission for
	// the associated annotation set.
	DeleteAnnotation(ctx context.Context, in *DeleteAnnotationRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	// Searches for annotations that match the given criteria. Results are
	// ordered by genomic coordinate (by reference sequence, then position).
	// Annotations with equivalent genomic coordinates are returned in an
	// unspecified order. This order is consistent, such that two queries for the
	// same content (regardless of page size) yield annotations in the same order
	// across their respective streams of paginated responses. Caller must have
	// READ permission for the queried annotation sets.
	SearchAnnotations(ctx context.Context, in *SearchAnnotationsRequest, opts ...grpc.CallOption) (*SearchAnnotationsResponse, error)
}

type annotationServiceV1Client struct {
	cc *grpc.ClientConn
}

func NewAnnotationServiceV1Client(cc *grpc.ClientConn) AnnotationServiceV1Client {
	return &annotationServiceV1Client{cc}
}

func (c *annotationServiceV1Client) CreateAnnotationSet(ctx context.Context, in *CreateAnnotationSetRequest, opts ...grpc.CallOption) (*AnnotationSet, error) {
	out := new(AnnotationSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/CreateAnnotationSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) GetAnnotationSet(ctx context.Context, in *GetAnnotationSetRequest, opts ...grpc.CallOption) (*AnnotationSet, error) {
	out := new(AnnotationSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/GetAnnotationSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) UpdateAnnotationSet(ctx context.Context, in *UpdateAnnotationSetRequest, opts ...grpc.CallOption) (*AnnotationSet, error) {
	out := new(AnnotationSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/UpdateAnnotationSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) DeleteAnnotationSet(ctx context.Context, in *DeleteAnnotationSetRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/DeleteAnnotationSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) SearchAnnotationSets(ctx context.Context, in *SearchAnnotationSetsRequest, opts ...grpc.CallOption) (*SearchAnnotationSetsResponse, error) {
	out := new(SearchAnnotationSetsResponse)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/SearchAnnotationSets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) CreateAnnotation(ctx context.Context, in *CreateAnnotationRequest, opts ...grpc.CallOption) (*Annotation, error) {
	out := new(Annotation)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/CreateAnnotation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) BatchCreateAnnotations(ctx context.Context, in *BatchCreateAnnotationsRequest, opts ...grpc.CallOption) (*BatchCreateAnnotationsResponse, error) {
	out := new(BatchCreateAnnotationsResponse)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/BatchCreateAnnotations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) GetAnnotation(ctx context.Context, in *GetAnnotationRequest, opts ...grpc.CallOption) (*Annotation, error) {
	out := new(Annotation)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/GetAnnotation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) UpdateAnnotation(ctx context.Context, in *UpdateAnnotationRequest, opts ...grpc.CallOption) (*Annotation, error) {
	out := new(Annotation)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/UpdateAnnotation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) DeleteAnnotation(ctx context.Context, in *DeleteAnnotationRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/DeleteAnnotation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *annotationServiceV1Client) SearchAnnotations(ctx context.Context, in *SearchAnnotationsRequest, opts ...grpc.CallOption) (*SearchAnnotationsResponse, error) {
	out := new(SearchAnnotationsResponse)
	err := grpc.Invoke(ctx, "/google.genomics.v1.AnnotationServiceV1/SearchAnnotations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AnnotationServiceV1 service

type AnnotationServiceV1Server interface {
	// Creates a new annotation set. Caller must have WRITE permission for the
	// associated dataset.
	//
	// The following fields are required:
	//
	//   * [datasetId][google.genomics.v1.AnnotationSet.dataset_id]
	//   * [referenceSetId][google.genomics.v1.AnnotationSet.reference_set_id]
	//
	// All other fields may be optionally specified, unless documented as being
	// server-generated (for example, the `id` field).
	CreateAnnotationSet(context.Context, *CreateAnnotationSetRequest) (*AnnotationSet, error)
	// Gets an annotation set. Caller must have READ permission for
	// the associated dataset.
	GetAnnotationSet(context.Context, *GetAnnotationSetRequest) (*AnnotationSet, error)
	// Updates an annotation set. The update must respect all mutability
	// restrictions and other invariants described on the annotation set resource.
	// Caller must have WRITE permission for the associated dataset.
	UpdateAnnotationSet(context.Context, *UpdateAnnotationSetRequest) (*AnnotationSet, error)
	// Deletes an annotation set. Caller must have WRITE permission
	// for the associated annotation set.
	DeleteAnnotationSet(context.Context, *DeleteAnnotationSetRequest) (*google_protobuf1.Empty, error)
	// Searches for annotation sets that match the given criteria. Annotation sets
	// are returned in an unspecified order. This order is consistent, such that
	// two queries for the same content (regardless of page size) yield annotation
	// sets in the same order across their respective streams of paginated
	// responses. Caller must have READ permission for the queried datasets.
	SearchAnnotationSets(context.Context, *SearchAnnotationSetsRequest) (*SearchAnnotationSetsResponse, error)
	// Creates a new annotation. Caller must have WRITE permission
	// for the associated annotation set.
	//
	// The following fields are required:
	//
	// * [annotationSetId][google.genomics.v1.Annotation.annotation_set_id]
	// * [referenceName][google.genomics.v1.Annotation.reference_name] or
	//   [referenceId][google.genomics.v1.Annotation.reference_id]
	//
	// ### Transcripts
	//
	// For annotations of type TRANSCRIPT, the following fields of
	// [transcript][google.genomics.v1.Annotation.transcript] must be provided:
	//
	// * [exons.start][google.genomics.v1.Transcript.Exon.start]
	// * [exons.end][google.genomics.v1.Transcript.Exon.end]
	//
	// All other fields may be optionally specified, unless documented as being
	// server-generated (for example, the `id` field). The annotated
	// range must be no longer than 100Mbp (mega base pairs). See the
	// [Annotation resource][google.genomics.v1.Annotation]
	// for additional restrictions on each field.
	CreateAnnotation(context.Context, *CreateAnnotationRequest) (*Annotation, error)
	// Creates one or more new annotations atomically. All annotations must
	// belong to the same annotation set. Caller must have WRITE
	// permission for this annotation set. For optimal performance, batch
	// positionally adjacent annotations together.
	//
	// If the request has a systemic issue, such as an attempt to write to
	// an inaccessible annotation set, the entire RPC will fail accordingly. For
	// lesser data issues, when possible an error will be isolated to the
	// corresponding batch entry in the response; the remaining well formed
	// annotations will be created normally.
	//
	// For details on the requirements for each individual annotation resource,
	// see
	// [CreateAnnotation][google.genomics.v1.AnnotationServiceV1.CreateAnnotation].
	BatchCreateAnnotations(context.Context, *BatchCreateAnnotationsRequest) (*BatchCreateAnnotationsResponse, error)
	// Gets an annotation. Caller must have READ permission
	// for the associated annotation set.
	GetAnnotation(context.Context, *GetAnnotationRequest) (*Annotation, error)
	// Updates an annotation. Caller must have
	// WRITE permission for the associated dataset.
	UpdateAnnotation(context.Context, *UpdateAnnotationRequest) (*Annotation, error)
	// Deletes an annotation. Caller must have WRITE permission for
	// the associated annotation set.
	DeleteAnnotation(context.Context, *DeleteAnnotationRequest) (*google_protobuf1.Empty, error)
	// Searches for annotations that match the given criteria. Results are
	// ordered by genomic coordinate (by reference sequence, then position).
	// Annotations with equivalent genomic coordinates are returned in an
	// unspecified order. This order is consistent, such that two queries for the
	// same content (regardless of page size) yield annotations in the same order
	// across their respective streams of paginated responses. Caller must have
	// READ permission for the queried annotation sets.
	SearchAnnotations(context.Context, *SearchAnnotationsRequest) (*SearchAnnotationsResponse, error)
}

func RegisterAnnotationServiceV1Server(s *grpc.Server, srv AnnotationServiceV1Server) {
	s.RegisterService(&_AnnotationServiceV1_serviceDesc, srv)
}

func _AnnotationServiceV1_CreateAnnotationSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAnnotationSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).CreateAnnotationSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/CreateAnnotationSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).CreateAnnotationSet(ctx, req.(*CreateAnnotationSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_GetAnnotationSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAnnotationSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).GetAnnotationSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/GetAnnotationSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).GetAnnotationSet(ctx, req.(*GetAnnotationSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_UpdateAnnotationSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAnnotationSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).UpdateAnnotationSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/UpdateAnnotationSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).UpdateAnnotationSet(ctx, req.(*UpdateAnnotationSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_DeleteAnnotationSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAnnotationSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).DeleteAnnotationSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/DeleteAnnotationSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).DeleteAnnotationSet(ctx, req.(*DeleteAnnotationSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_SearchAnnotationSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchAnnotationSetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).SearchAnnotationSets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/SearchAnnotationSets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).SearchAnnotationSets(ctx, req.(*SearchAnnotationSetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_CreateAnnotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAnnotationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).CreateAnnotation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/CreateAnnotation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).CreateAnnotation(ctx, req.(*CreateAnnotationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_BatchCreateAnnotations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateAnnotationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).BatchCreateAnnotations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/BatchCreateAnnotations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).BatchCreateAnnotations(ctx, req.(*BatchCreateAnnotationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_GetAnnotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAnnotationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).GetAnnotation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/GetAnnotation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).GetAnnotation(ctx, req.(*GetAnnotationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_UpdateAnnotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAnnotationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).UpdateAnnotation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/UpdateAnnotation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).UpdateAnnotation(ctx, req.(*UpdateAnnotationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_DeleteAnnotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAnnotationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).DeleteAnnotation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/DeleteAnnotation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).DeleteAnnotation(ctx, req.(*DeleteAnnotationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnnotationServiceV1_SearchAnnotations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchAnnotationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnotationServiceV1Server).SearchAnnotations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.AnnotationServiceV1/SearchAnnotations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnotationServiceV1Server).SearchAnnotations(ctx, req.(*SearchAnnotationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AnnotationServiceV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.genomics.v1.AnnotationServiceV1",
	HandlerType: (*AnnotationServiceV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAnnotationSet",
			Handler:    _AnnotationServiceV1_CreateAnnotationSet_Handler,
		},
		{
			MethodName: "GetAnnotationSet",
			Handler:    _AnnotationServiceV1_GetAnnotationSet_Handler,
		},
		{
			MethodName: "UpdateAnnotationSet",
			Handler:    _AnnotationServiceV1_UpdateAnnotationSet_Handler,
		},
		{
			MethodName: "DeleteAnnotationSet",
			Handler:    _AnnotationServiceV1_DeleteAnnotationSet_Handler,
		},
		{
			MethodName: "SearchAnnotationSets",
			Handler:    _AnnotationServiceV1_SearchAnnotationSets_Handler,
		},
		{
			MethodName: "CreateAnnotation",
			Handler:    _AnnotationServiceV1_CreateAnnotation_Handler,
		},
		{
			MethodName: "BatchCreateAnnotations",
			Handler:    _AnnotationServiceV1_BatchCreateAnnotations_Handler,
		},
		{
			MethodName: "GetAnnotation",
			Handler:    _AnnotationServiceV1_GetAnnotation_Handler,
		},
		{
			MethodName: "UpdateAnnotation",
			Handler:    _AnnotationServiceV1_UpdateAnnotation_Handler,
		},
		{
			MethodName: "DeleteAnnotation",
			Handler:    _AnnotationServiceV1_DeleteAnnotation_Handler,
		},
		{
			MethodName: "SearchAnnotations",
			Handler:    _AnnotationServiceV1_SearchAnnotations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/genomics/v1/annotations.proto",
}

func (m *AnnotationSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnnotationSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.DatasetId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.DatasetId)))
		i += copy(dAtA[i:], m.DatasetId)
	}
	if len(m.ReferenceSetId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.ReferenceSetId)))
		i += copy(dAtA[i:], m.ReferenceSetId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.SourceUri) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.SourceUri)))
		i += copy(dAtA[i:], m.SourceUri)
	}
	if m.Type != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Type))
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.Info[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovAnnotations(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovAnnotations(uint64(len(k))) + msgSize
			i = encodeVarintAnnotations(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnnotations(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintAnnotations(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *Annotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Annotation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.AnnotationSetId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.AnnotationSetId)))
		i += copy(dAtA[i:], m.AnnotationSetId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ReferenceId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.ReferenceId)))
		i += copy(dAtA[i:], m.ReferenceId)
	}
	if len(m.ReferenceName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.ReferenceName)))
		i += copy(dAtA[i:], m.ReferenceName)
	}
	if m.Start != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.End))
	}
	if m.ReverseStrand {
		dAtA[i] = 0x40
		i++
		if m.ReverseStrand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Type != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Type))
	}
	if m.Value != nil {
		nn2, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x62
			i++
			v := m.Info[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovAnnotations(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovAnnotations(uint64(len(k))) + msgSize
			i = encodeVarintAnnotations(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnnotations(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintAnnotations(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *Annotation_Variant) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Variant != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Variant.Size()))
		n4, err := m.Variant.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Annotation_Transcript) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Transcript != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Transcript.Size()))
		n5, err := m.Transcript.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *VariantAnnotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VariantAnnotation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Type))
	}
	if m.Effect != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Effect))
	}
	if len(m.AlternateBases) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.AlternateBases)))
		i += copy(dAtA[i:], m.AlternateBases)
	}
	if len(m.GeneId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.GeneId)))
		i += copy(dAtA[i:], m.GeneId)
	}
	if len(m.TranscriptIds) > 0 {
		for _, s := range m.TranscriptIds {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x32
			i++
			i = encodeVarintAnnotations(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ClinicalSignificance != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.ClinicalSignificance))
	}
	return i, nil
}

func (m *VariantAnnotation_ClinicalCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VariantAnnotation_ClinicalCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExternalIds) > 0 {
		for _, msg := range m.ExternalIds {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAnnotations(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConceptId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.ConceptId)))
		i += copy(dAtA[i:], m.ConceptId)
	}
	if len(m.OmimId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.OmimId)))
		i += copy(dAtA[i:], m.OmimId)
	}
	return i, nil
}

func (m *Transcript) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transcript) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GeneId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.GeneId)))
		i += copy(dAtA[i:], m.GeneId)
	}
	if len(m.Exons) > 0 {
		for _, msg := range m.Exons {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAnnotations(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CodingSequence != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.CodingSequence.Size()))
		n6, err := m.CodingSequence.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Transcript_Exon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transcript_Exon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.End))
	}
	if m.Frame != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Frame.Size()))
		n7, err := m.Frame.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *Transcript_CodingSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transcript_CodingSequence) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *ExternalId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.SourceName)))
		i += copy(dAtA[i:], m.SourceName)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *CreateAnnotationSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAnnotationSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AnnotationSet != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.AnnotationSet.Size()))
		n8, err := m.AnnotationSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *GetAnnotationSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAnnotationSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AnnotationSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.AnnotationSetId)))
		i += copy(dAtA[i:], m.AnnotationSetId)
	}
	return i, nil
}

func (m *UpdateAnnotationSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAnnotationSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AnnotationSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.AnnotationSetId)))
		i += copy(dAtA[i:], m.AnnotationSetId)
	}
	if m.AnnotationSet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.AnnotationSet.Size()))
		n9, err := m.AnnotationSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.UpdateMask != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.UpdateMask.Size()))
		n10, err := m.UpdateMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *DeleteAnnotationSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAnnotationSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AnnotationSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.AnnotationSetId)))
		i += copy(dAtA[i:], m.AnnotationSetId)
	}
	return i, nil
}

func (m *SearchAnnotationSetsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchAnnotationSetsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatasetIds) > 0 {
		for _, s := range m.DatasetIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ReferenceSetId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.ReferenceSetId)))
		i += copy(dAtA[i:], m.ReferenceSetId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Types) > 0 {
		dAtA12 := make([]byte, len(m.Types)*10)
		var j11 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *SearchAnnotationSetsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchAnnotationSetsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AnnotationSets) > 0 {
		for _, msg := range m.AnnotationSets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnnotations(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *CreateAnnotationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAnnotationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Annotation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Annotation.Size()))
		n13, err := m.Annotation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *BatchCreateAnnotationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCreateAnnotationsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for _, msg := range m.Annotations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnnotations(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RequestId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.RequestId)))
		i += copy(dAtA[i:], m.RequestId)
	}
	return i, nil
}

func (m *BatchCreateAnnotationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCreateAnnotationsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnnotations(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BatchCreateAnnotationsResponse_Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCreateAnnotationsResponse_Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Status.Size()))
		n14, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Annotation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Annotation.Size()))
		n15, err := m.Annotation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *GetAnnotationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAnnotationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AnnotationId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.AnnotationId)))
		i += copy(dAtA[i:], m.AnnotationId)
	}
	return i, nil
}

func (m *UpdateAnnotationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAnnotationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AnnotationId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.AnnotationId)))
		i += copy(dAtA[i:], m.AnnotationId)
	}
	if m.Annotation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Annotation.Size()))
		n16, err := m.Annotation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.UpdateMask != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.UpdateMask.Size()))
		n17, err := m.UpdateMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *DeleteAnnotationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAnnotationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AnnotationId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.AnnotationId)))
		i += copy(dAtA[i:], m.AnnotationId)
	}
	return i, nil
}

func (m *SearchAnnotationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchAnnotationsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AnnotationSetIds) > 0 {
		for _, s := range m.AnnotationSetIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Reference != nil {
		nn18, err := m.Reference.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn18
	}
	if m.Start != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.End))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *SearchAnnotationsRequest_ReferenceId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintAnnotations(dAtA, i, uint64(len(m.ReferenceId)))
	i += copy(dAtA[i:], m.ReferenceId)
	return i, nil
}
func (m *SearchAnnotationsRequest_ReferenceName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAnnotations(dAtA, i, uint64(len(m.ReferenceName)))
	i += copy(dAtA[i:], m.ReferenceName)
	return i, nil
}
func (m *SearchAnnotationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchAnnotationsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for _, msg := range m.Annotations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAnnotations(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAnnotations(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func encodeFixed64Annotations(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Annotations(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAnnotations(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AnnotationSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.DatasetId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.ReferenceSetId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.SourceUri)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovAnnotations(uint64(m.Type))
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAnnotations(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAnnotations(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovAnnotations(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Annotation) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.AnnotationSetId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.ReferenceId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.ReferenceName)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovAnnotations(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovAnnotations(uint64(m.End))
	}
	if m.ReverseStrand {
		n += 2
	}
	if m.Type != 0 {
		n += 1 + sovAnnotations(uint64(m.Type))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAnnotations(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAnnotations(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAnnotations(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Annotation_Variant) Size() (n int) {
	var l int
	_ = l
	if m.Variant != nil {
		l = m.Variant.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}
func (m *Annotation_Transcript) Size() (n int) {
	var l int
	_ = l
	if m.Transcript != nil {
		l = m.Transcript.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}
func (m *VariantAnnotation) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAnnotations(uint64(m.Type))
	}
	if m.Effect != 0 {
		n += 1 + sovAnnotations(uint64(m.Effect))
	}
	l = len(m.AlternateBases)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.GeneId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if len(m.TranscriptIds) > 0 {
		for _, s := range m.TranscriptIds {
			l = len(s)
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	if m.ClinicalSignificance != 0 {
		n += 1 + sovAnnotations(uint64(m.ClinicalSignificance))
	}
	return n
}

func (m *VariantAnnotation_ClinicalCondition) Size() (n int) {
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	if len(m.ExternalIds) > 0 {
		for _, e := range m.ExternalIds {
			l = e.Size()
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	l = len(m.ConceptId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.OmimId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *Transcript) Size() (n int) {
	var l int
	_ = l
	l = len(m.GeneId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if len(m.Exons) > 0 {
		for _, e := range m.Exons {
			l = e.Size()
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	if m.CodingSequence != nil {
		l = m.CodingSequence.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *Transcript_Exon) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovAnnotations(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovAnnotations(uint64(m.End))
	}
	if m.Frame != nil {
		l = m.Frame.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *Transcript_CodingSequence) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovAnnotations(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovAnnotations(uint64(m.End))
	}
	return n
}

func (m *ExternalId) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceName)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *CreateAnnotationSetRequest) Size() (n int) {
	var l int
	_ = l
	if m.AnnotationSet != nil {
		l = m.AnnotationSet.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *GetAnnotationSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.AnnotationSetId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *UpdateAnnotationSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.AnnotationSetId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if m.AnnotationSet != nil {
		l = m.AnnotationSet.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if m.UpdateMask != nil {
		l = m.UpdateMask.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *DeleteAnnotationSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.AnnotationSetId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *SearchAnnotationSetsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.DatasetIds) > 0 {
		for _, s := range m.DatasetIds {
			l = len(s)
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	l = len(m.ReferenceSetId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovAnnotations(uint64(e))
		}
		n += 1 + sovAnnotations(uint64(l)) + l
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovAnnotations(uint64(m.PageSize))
	}
	return n
}

func (m *SearchAnnotationSetsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.AnnotationSets) > 0 {
		for _, e := range m.AnnotationSets {
			l = e.Size()
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *CreateAnnotationRequest) Size() (n int) {
	var l int
	_ = l
	if m.Annotation != nil {
		l = m.Annotation.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *BatchCreateAnnotationsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for _, e := range m.Annotations {
			l = e.Size()
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *BatchCreateAnnotationsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	return n
}

func (m *BatchCreateAnnotationsResponse_Entry) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if m.Annotation != nil {
		l = m.Annotation.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *GetAnnotationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.AnnotationId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *UpdateAnnotationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.AnnotationId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if m.Annotation != nil {
		l = m.Annotation.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if m.UpdateMask != nil {
		l = m.UpdateMask.Size()
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *DeleteAnnotationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.AnnotationId)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func (m *SearchAnnotationsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.AnnotationSetIds) > 0 {
		for _, s := range m.AnnotationSetIds {
			l = len(s)
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	if m.Reference != nil {
		n += m.Reference.Size()
	}
	if m.Start != 0 {
		n += 1 + sovAnnotations(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovAnnotations(uint64(m.End))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovAnnotations(uint64(m.PageSize))
	}
	return n
}

func (m *SearchAnnotationsRequest_ReferenceId) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReferenceId)
	n += 1 + l + sovAnnotations(uint64(l))
	return n
}
func (m *SearchAnnotationsRequest_ReferenceName) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReferenceName)
	n += 1 + l + sovAnnotations(uint64(l))
	return n
}
func (m *SearchAnnotationsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for _, e := range m.Annotations {
			l = e.Size()
			n += 1 + l + sovAnnotations(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovAnnotations(uint64(l))
	}
	return n
}

func sovAnnotations(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAnnotations(x uint64) (n int) {
	return sovAnnotations(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AnnotationSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotationSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotationSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AnnotationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]*google_protobuf3.ListValue)
			}
			var mapkey string
			var mapvalue *google_protobuf3.ListValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnnotations
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnnotations
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAnnotations
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnnotations
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAnnotations
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthAnnotations
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &google_protobuf3.ListValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAnnotations(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAnnotations
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Annotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Annotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Annotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotationSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseStrand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReverseStrand = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AnnotationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VariantAnnotation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Annotation_Variant{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transcript", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Transcript{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Annotation_Transcript{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]*google_protobuf3.ListValue)
			}
			var mapkey string
			var mapvalue *google_protobuf3.ListValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnnotations
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnnotations
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAnnotations
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnnotations
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAnnotations
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthAnnotations
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &google_protobuf3.ListValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAnnotations(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAnnotations
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VariantAnnotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VariantAnnotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VariantAnnotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (VariantAnnotation_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			m.Effect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Effect |= (VariantAnnotation_Effect(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlternateBases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlternateBases = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TranscriptIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TranscriptIds = append(m.TranscriptIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &VariantAnnotation_ClinicalCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClinicalSignificance", wireType)
			}
			m.ClinicalSignificance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClinicalSignificance |= (VariantAnnotation_ClinicalSignificance(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VariantAnnotation_ClinicalCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClinicalCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClinicalCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIds = append(m.ExternalIds, &ExternalId{})
			if err := m.ExternalIds[len(m.ExternalIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConceptId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConceptId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OmimId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OmimId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transcript) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transcript: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transcript: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exons = append(m.Exons, &Transcript_Exon{})
			if err := m.Exons[len(m.Exons)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodingSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodingSequence == nil {
				m.CodingSequence = &Transcript_CodingSequence{}
			}
			if err := m.CodingSequence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transcript_Exon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frame == nil {
				m.Frame = &google_protobuf4.Int32Value{}
			}
			if err := m.Frame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transcript_CodingSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodingSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodingSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAnnotationSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAnnotationSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAnnotationSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnnotationSet == nil {
				m.AnnotationSet = &AnnotationSet{}
			}
			if err := m.AnnotationSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAnnotationSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAnnotationSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAnnotationSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotationSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAnnotationSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAnnotationSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAnnotationSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotationSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnnotationSet == nil {
				m.AnnotationSet = &AnnotationSet{}
			}
			if err := m.AnnotationSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateMask == nil {
				m.UpdateMask = &google_protobuf2.FieldMask{}
			}
			if err := m.UpdateMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAnnotationSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAnnotationSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAnnotationSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotationSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchAnnotationSetsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchAnnotationSetsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchAnnotationSetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetIds = append(m.DatasetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v AnnotationType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnnotations
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (AnnotationType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAnnotations
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAnnotations
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v AnnotationType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAnnotations
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (AnnotationType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchAnnotationSetsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchAnnotationSetsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchAnnotationSetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotationSets = append(m.AnnotationSets, &AnnotationSet{})
			if err := m.AnnotationSets[len(m.AnnotationSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAnnotationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAnnotationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAnnotationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotation == nil {
				m.Annotation = &Annotation{}
			}
			if err := m.Annotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCreateAnnotationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchCreateAnnotationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchCreateAnnotationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotations = append(m.Annotations, &Annotation{})
			if err := m.Annotations[len(m.Annotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCreateAnnotationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchCreateAnnotationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchCreateAnnotationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &BatchCreateAnnotationsResponse_Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCreateAnnotationsResponse_Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &google_rpc.Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotation == nil {
				m.Annotation = &Annotation{}
			}
			if err := m.Annotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAnnotationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAnnotationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAnnotationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAnnotationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAnnotationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAnnotationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotation == nil {
				m.Annotation = &Annotation{}
			}
			if err := m.Annotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateMask == nil {
				m.UpdateMask = &google_protobuf2.FieldMask{}
			}
			if err := m.UpdateMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAnnotationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAnnotationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAnnotationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchAnnotationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchAnnotationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchAnnotationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnotationSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnnotationSetIds = append(m.AnnotationSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = &SearchAnnotationsRequest_ReferenceId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = &SearchAnnotationsRequest_ReferenceName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchAnnotationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchAnnotationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchAnnotationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotations = append(m.Annotations, &Annotation{})
			if err := m.Annotations[len(m.Annotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnnotations
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnnotations(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnnotations
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAnnotations(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAnnotations
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnnotations
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAnnotations
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAnnotations
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAnnotations(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAnnotations = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAnnotations   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/genomics/v1/annotations.proto", fileDescriptorAnnotations) }

var fileDescriptorAnnotations = []byte{
	// 2204 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x59, 0xcd, 0x6f, 0xdb, 0xc8,
	0x15, 0x0f, 0xf5, 0x69, 0x3f, 0xd9, 0x32, 0x3d, 0xf1, 0xda, 0x5a, 0x39, 0x71, 0x1c, 0xe6, 0xcb,
	0x70, 0x13, 0x79, 0xa3, 0x00, 0x6d, 0xea, 0xb4, 0xe9, 0xca, 0x34, 0x6d, 0x4f, 0x57, 0xa6, 0x04,
	0x92, 0x72, 0xe1, 0x5e, 0x08, 0x86, 0x1a, 0x7b, 0x89, 0xd8, 0xa4, 0x4a, 0xd2, 0xde, 0x78, 0x8b,
	0x05, 0x16, 0x8b, 0x2d, 0x7a, 0xea, 0x65, 0x77, 0xef, 0xbd, 0x14, 0x68, 0xff, 0x87, 0x5e, 0x0a,
	0xf4, 0xd2, 0x53, 0x5b, 0xa0, 0xe8, 0xbd, 0x08, 0x7a, 0xd9, 0x6b, 0x4f, 0x05, 0x7a, 0x29, 0x66,
	0x48, 0x4a, 0x14, 0x45, 0xd9, 0x72, 0x03, 0xf4, 0xc6, 0x79, 0xf3, 0xde, 0x9b, 0xdf, 0xfc, 0x66,
	0xde, 0xc7, 0x48, 0x70, 0xff, 0xd8, 0x71, 0x8e, 0x4f, 0xc8, 0xc6, 0x31, 0xb1, 0x9d, 0x53, 0xcb,
	0xf4, 0x36, 0xce, 0x9f, 0x6e, 0x18, 0xb6, 0xed, 0xf8, 0x86, 0x6f, 0x39, 0xb6, 0x57, 0xeb, 0xb9,
	0x8e, 0xef, 0x20, 0x14, 0x68, 0xd5, 0x22, 0xad, 0xda, 0xf9, 0xd3, 0xea, 0xad, 0xd0, 0xd2, 0xe8,
	0x59, 0xa3, 0x16, 0xd5, 0xe5, 0x70, 0x96, 0x8d, 0x5e, 0x9d, 0x1d, 0x6d, 0x90, 0xd3, 0x9e, 0x7f,
	0x11, 0x4e, 0xae, 0x26, 0x27, 0x8f, 0x2c, 0x72, 0xd2, 0xd5, 0x4f, 0x0d, 0xef, 0x75, 0xa8, 0x71,
	0x2b, 0xa9, 0xe1, 0xf9, 0xee, 0x99, 0xe9, 0x87, 0xb3, 0x2b, 0xc9, 0xd9, 0x4f, 0x5c, 0xa3, 0xd7,
	0x23, 0x6e, 0xb4, 0xf8, 0x52, 0x38, 0xef, 0xf6, 0xcc, 0x0d, 0xcf, 0x37, 0xfc, 0xb3, 0x70, 0x42,
	0xf8, 0x36, 0x03, 0xb3, 0x8d, 0x3e, 0x56, 0x95, 0xf8, 0xa8, 0x0c, 0x19, 0xab, 0x5b, 0xe1, 0x56,
	0xb9, 0xb5, 0x69, 0x25, 0x63, 0x75, 0xd1, 0x6d, 0x80, 0xae, 0xe1, 0x1b, 0x1e, 0xf1, 0x75, 0xab,
	0x5b, 0xc9, 0x30, 0xf9, 0x74, 0x28, 0xc1, 0x5d, 0xb4, 0x06, 0xbc, 0x4b, 0x8e, 0x88, 0x4b, 0x6c,
	0x93, 0xe8, 0xa1, 0x52, 0x96, 0x29, 0x95, 0xfb, 0x72, 0x95, 0x69, 0x22, 0xc8, 0xd9, 0xc6, 0x29,
	0xa9, 0xe4, 0xd8, 0x2c, 0xfb, 0xa6, 0xce, 0x3d, 0xe7, 0xcc, 0x35, 0x89, 0x7e, 0xe6, 0x5a, 0x95,
	0x7c, 0xe0, 0x3c, 0x90, 0x74, 0x5c, 0x0b, 0x7d, 0x17, 0x72, 0xfe, 0x45, 0x8f, 0x54, 0x0a, 0xab,
	0xdc, 0x5a, 0xb9, 0x2e, 0xd4, 0x46, 0x49, 0xaf, 0x0d, 0xc0, 0x6b, 0x17, 0x3d, 0xa2, 0x30, 0x7d,
	0xf4, 0x23, 0xc8, 0x59, 0xf6, 0x91, 0x53, 0x99, 0x5f, 0xcd, 0xae, 0x95, 0xea, 0xdf, 0xb9, 0xdc,
	0x4e, 0x25, 0x7e, 0x0d, 0xdb, 0x47, 0x8e, 0x64, 0xfb, 0xee, 0x85, 0xc2, 0x0c, 0xab, 0x2a, 0x4c,
	0xf7, 0x45, 0x88, 0x87, 0xec, 0x6b, 0x72, 0x11, 0x52, 0x42, 0x3f, 0xd1, 0x07, 0x90, 0x3f, 0x37,
	0x4e, 0xce, 0x08, 0xa3, 0xa3, 0x54, 0xaf, 0x46, 0x0b, 0x44, 0xf4, 0xd7, 0x9a, 0x96, 0xe7, 0x1f,
	0x50, 0x0d, 0x25, 0x50, 0xdc, 0xcc, 0x3c, 0xe7, 0x84, 0x3f, 0xe7, 0x00, 0x06, 0xcb, 0x8e, 0x10,
	0xbd, 0x0e, 0xf3, 0x83, 0x5b, 0xa3, 0x0f, 0xf1, 0x3d, 0x67, 0xc4, 0xd1, 0xc6, 0xb8, 0xcc, 0xc6,
	0xb8, 0xbc, 0x0b, 0x33, 0x83, 0x93, 0xb0, 0xba, 0x21, 0xcf, 0xa5, 0xbe, 0x0c, 0x77, 0xd1, 0x03,
	0x18, 0x1c, 0x8a, 0xce, 0x1c, 0x04, 0x94, 0xcf, 0xf6, 0xa5, 0x32, 0xf5, 0xb4, 0x00, 0x79, 0xcf,
	0x37, 0x5c, 0x9f, 0xf1, 0x9e, 0x55, 0x82, 0x01, 0xa5, 0x81, 0xd8, 0xdd, 0x4a, 0x91, 0xc9, 0xe8,
	0x67, 0xe0, 0xee, 0x9c, 0xb8, 0x1e, 0xd1, 0x3d, 0xdf, 0x35, 0xec, 0x6e, 0x65, 0x6a, 0x95, 0x5b,
	0x9b, 0xa2, 0xee, 0x98, 0x54, 0x65, 0xc2, 0xfe, 0x29, 0x4e, 0x5f, 0xf3, 0x14, 0x1b, 0x50, 0x3c,
	0x37, 0x5c, 0xcb, 0xb0, 0xfd, 0x0a, 0x30, 0x9e, 0x1f, 0xa4, 0x99, 0x1e, 0x04, 0x2a, 0x03, 0x0f,
	0x7b, 0x37, 0x94, 0xc8, 0x0e, 0x7d, 0x08, 0x40, 0x31, 0x78, 0xa6, 0x6b, 0xf5, 0xfc, 0x4a, 0x89,
	0x79, 0x59, 0x49, 0xf3, 0xa2, 0xf5, 0xb5, 0xf6, 0x6e, 0x28, 0x31, 0x1b, 0xf4, 0x83, 0xf0, 0x2a,
	0xcd, 0xb0, 0xab, 0xb4, 0x76, 0x39, 0xf8, 0xff, 0xcb, 0x3d, 0xda, 0x2a, 0x86, 0x56, 0xc2, 0x7f,
	0xa6, 0x61, 0x7e, 0x64, 0xfb, 0xe8, 0x65, 0x48, 0x37, 0xc7, 0xe8, 0x5e, 0x9f, 0x88, 0xb3, 0x5a,
	0x8c, 0xf6, 0x6d, 0x28, 0x90, 0xa3, 0x23, 0x62, 0xfa, 0x0c, 0x55, 0xb9, 0xfe, 0x78, 0x32, 0x0f,
	0x12, 0xb3, 0x51, 0x42, 0x5b, 0xf4, 0x08, 0xe6, 0x8c, 0x13, 0x9f, 0xb8, 0xb6, 0xe1, 0x13, 0xfd,
	0x95, 0xe1, 0x11, 0x2f, 0x4a, 0x0b, 0x7d, 0xf1, 0x16, 0x95, 0xa2, 0x25, 0x28, 0x1e, 0x13, 0x3b,
	0x76, 0x63, 0x0b, 0x74, 0x18, 0x5c, 0xd6, 0xc1, 0x39, 0xe8, 0x56, 0xd7, 0xab, 0xe4, 0x57, 0xb3,
	0xf4, 0xb2, 0x0e, 0xa4, 0xb8, 0xeb, 0xa1, 0x9f, 0x00, 0x98, 0x8e, 0xdd, 0xb5, 0x58, 0xae, 0xad,
	0x14, 0xd8, 0x31, 0x7d, 0x6f, 0x32, 0xc8, 0xe2, 0x89, 0x65, 0x5b, 0xa6, 0x71, 0x22, 0x46, 0xf6,
	0x4a, 0xcc, 0x15, 0x72, 0xe0, 0x3d, 0x33, 0x54, 0xd0, 0x3d, 0xeb, 0xd8, 0xb6, 0x8e, 0x2c, 0xd3,
	0xb0, 0x4d, 0xc2, 0x22, 0xa0, 0x5c, 0xdf, 0xbc, 0xde, 0x1a, 0x6a, 0xcc, 0x83, 0xb2, 0x60, 0xa6,
	0x48, 0xab, 0xbf, 0xe1, 0x60, 0x7e, 0x04, 0x12, 0x0d, 0x46, 0x1a, 0xa9, 0x5e, 0x85, 0x63, 0xbb,
	0x0f, 0x06, 0xa8, 0x01, 0x33, 0xe4, 0x0d, 0xe3, 0xf1, 0x84, 0x51, 0x93, 0x61, 0xfb, 0x4e, 0xbd,
	0xda, 0x52, 0xa8, 0x87, 0xbb, 0x4a, 0x89, 0xf4, 0xbf, 0x3d, 0x9a, 0x7b, 0x4d, 0xc7, 0x36, 0x49,
	0x2f, 0x96, 0xb3, 0xa7, 0x43, 0x09, 0xee, 0xd2, 0x73, 0x71, 0x4e, 0xad, 0xd3, 0xd8, 0xb9, 0xd0,
	0x21, 0xee, 0x0a, 0x9f, 0x41, 0x8e, 0xde, 0x16, 0xb4, 0x00, 0xbc, 0x76, 0xd8, 0x96, 0xf4, 0x8e,
	0xac, 0xb6, 0x25, 0x11, 0xef, 0x60, 0x69, 0x9b, 0xbf, 0x81, 0xca, 0x00, 0x4c, 0xda, 0xd2, 0xf6,
	0x24, 0x85, 0xe7, 0xd0, 0x2c, 0x4c, 0x63, 0x59, 0x95, 0x14, 0x0d, 0xb7, 0x64, 0x3e, 0x83, 0x66,
	0x60, 0x6a, 0x5b, 0x6a, 0x4a, 0x6c, 0x94, 0x45, 0x3c, 0xcc, 0xa8, 0x9d, 0x2d, 0x55, 0xc3, 0x5a,
	0x87, 0x49, 0x72, 0xa8, 0x08, 0x59, 0x55, 0x6e, 0xf3, 0x79, 0xea, 0x47, 0xd5, 0x94, 0x8e, 0xa8,
	0x75, 0x94, 0x46, 0x93, 0x2f, 0xd0, 0x09, 0x51, 0x3e, 0xe0, 0x8b, 0xc2, 0x1f, 0x39, 0x28, 0x04,
	0x77, 0x0d, 0x2d, 0x02, 0x92, 0x76, 0x76, 0x24, 0x51, 0x4b, 0x60, 0xe0, 0x61, 0x26, 0x94, 0x47,
	0x28, 0xca, 0x00, 0x3b, 0x4a, 0x63, 0x5f, 0x52, 0xf7, 0xf0, 0x8e, 0xc6, 0x67, 0x50, 0x15, 0x16,
	0xd9, 0x58, 0x6f, 0x2b, 0x92, 0x2a, 0x29, 0x07, 0x58, 0xde, 0xd5, 0xb1, 0xbc, 0x2d, 0x35, 0xf9,
	0x2c, 0x42, 0x50, 0x56, 0x0f, 0xe5, 0x96, 0x7c, 0xb8, 0xdf, 0xea, 0xa8, 0x3a, 0x45, 0x93, 0x43,
	0xef, 0xc1, 0xbc, 0xdc, 0x92, 0x13, 0xe2, 0x3c, 0xdd, 0x9c, 0xaa, 0xb5, 0xda, 0xfa, 0x6e, 0x03,
	0xcb, 0x7c, 0xa1, 0x3f, 0x6c, 0xb6, 0x54, 0x95, 0x2f, 0xd2, 0x45, 0xd4, 0x76, 0x13, 0x8b, 0x92,
	0xae, 0x62, 0x4d, 0xd2, 0xb7, 0xb1, 0xaa, 0x74, 0xda, 0x6c, 0x9f, 0x53, 0xc2, 0x1f, 0x32, 0xb0,
	0x90, 0x76, 0x35, 0xd0, 0x03, 0xb8, 0x2b, 0x36, 0xb1, 0x8c, 0xc5, 0x46, 0x53, 0x57, 0xf1, 0xae,
	0x8c, 0x77, 0xb0, 0xd8, 0x90, 0xc5, 0x24, 0xcd, 0x77, 0x60, 0x39, 0x5d, 0x2d, 0xc6, 0x7b, 0x47,
	0x16, 0x25, 0x45, 0xa3, 0xd0, 0x32, 0x08, 0xa0, 0xb0, 0x25, 0xc9, 0x78, 0x97, 0xb2, 0x3e, 0x0f,
	0xb3, 0x4d, 0xfc, 0x91, 0xd4, 0x3c, 0xd4, 0x43, 0x11, 0xdb, 0x5f, 0x28, 0x6a, 0x37, 0xb4, 0xbd,
	0xd6, 0xae, 0x24, 0x63, 0x31, 0x38, 0x84, 0xd8, 0xb8, 0x40, 0x2d, 0xb7, 0x95, 0xce, 0xae, 0xae,
	0x48, 0x6a, 0xbb, 0x25, 0xab, 0x12, 0x5f, 0xa4, 0x67, 0xb0, 0x87, 0x55, 0xad, 0x25, 0xb6, 0xf6,
	0xdb, 0x0d, 0x0d, 0x6f, 0xe1, 0x26, 0xd6, 0x0e, 0xf9, 0x29, 0xb4, 0x04, 0x37, 0xc5, 0x96, 0xbc,
	0x23, 0x29, 0xaa, 0xae, 0x4a, 0xb2, 0x8a, 0x35, 0x7c, 0x40, 0x27, 0xa6, 0xd1, 0x1c, 0x94, 0x14,
	0xac, 0x7e, 0xa4, 0xef, 0x34, 0x44, 0xad, 0xa5, 0xf0, 0x40, 0x05, 0x0d, 0x55, 0x6d, 0x89, 0xb8,
	0xc1, 0xb8, 0x29, 0xb1, 0x55, 0x95, 0x96, 0x26, 0x89, 0x1a, 0x3e, 0x90, 0xf8, 0x19, 0x0a, 0x6e,
	0xbf, 0xd3, 0xd4, 0x70, 0xbb, 0x29, 0xe9, 0x8a, 0xd4, 0x6e, 0x29, 0x9a, 0xb4, 0xcd, 0xcf, 0x0a,
	0x7f, 0xcf, 0x00, 0x0c, 0xd2, 0x76, 0x3c, 0x8f, 0x70, 0x43, 0x79, 0xe4, 0xfb, 0x90, 0x27, 0x6f,
	0x68, 0x6e, 0x08, 0x62, 0xe4, 0xde, 0xe5, 0xe9, 0xbf, 0x26, 0xbd, 0x71, 0x6c, 0x25, 0xb0, 0x40,
	0x07, 0x30, 0x67, 0x3a, 0x5d, 0xcb, 0x3e, 0xd6, 0x3d, 0xf2, 0xb3, 0x33, 0x5a, 0x1f, 0x59, 0x9c,
	0x94, 0xea, 0x4f, 0xae, 0x70, 0x22, 0x32, 0x2b, 0x35, 0x34, 0x52, 0xca, 0xe6, 0xd0, 0xb8, 0x6a,
	0x40, 0x8e, 0x2e, 0x33, 0x28, 0xb4, 0x5c, 0x4a, 0xa1, 0xcd, 0x0c, 0x0a, 0xed, 0x53, 0xc8, 0x1f,
	0xb9, 0x51, 0xbd, 0x2f, 0xd5, 0x97, 0x47, 0xea, 0x04, 0xb6, 0xfd, 0x67, 0xf5, 0xb0, 0x50, 0x30,
	0xcd, 0xea, 0x73, 0x28, 0x0f, 0x83, 0x98, 0x74, 0x31, 0xe1, 0x87, 0x00, 0x83, 0x94, 0x81, 0xee,
	0x40, 0x29, 0xec, 0xd0, 0x58, 0xbf, 0x10, 0x50, 0x1b, 0x36, 0x6d, 0xac, 0x59, 0x08, 0xda, 0x98,
	0x4c, 0xd4, 0xc6, 0x08, 0x47, 0x50, 0x15, 0x5d, 0x62, 0xf8, 0x64, 0xa8, 0xc3, 0x52, 0x28, 0x0a,
	0xcf, 0x47, 0x7b, 0x50, 0x1e, 0x6e, 0x72, 0x98, 0xc7, 0x52, 0xfd, 0xee, 0x95, 0x3d, 0x9a, 0x32,
	0x3b, 0xd4, 0x04, 0x09, 0x12, 0x2c, 0xed, 0x12, 0x3f, 0x75, 0x91, 0xd4, 0x4e, 0x8a, 0x4b, 0xed,
	0xa4, 0x84, 0xbf, 0x70, 0x50, 0xed, 0xf4, 0xba, 0xe3, 0xf0, 0x5e, 0xc3, 0x55, 0xca, 0xde, 0x32,
	0xff, 0xdb, 0xde, 0xd0, 0x0b, 0x28, 0x9d, 0x31, 0x4c, 0xec, 0x05, 0x10, 0x9e, 0xfa, 0x68, 0x77,
	0xb0, 0x43, 0x1f, 0x09, 0xfb, 0x86, 0xf7, 0x5a, 0x81, 0x40, 0x9d, 0x7e, 0x0b, 0x7b, 0x50, 0xdd,
	0x26, 0x27, 0xe4, 0xdd, 0x37, 0x24, 0xfc, 0x8b, 0x83, 0x65, 0x95, 0x18, 0xae, 0xf9, 0xf1, 0x90,
	0x2b, 0x2f, 0xf2, 0x75, 0x07, 0x4a, 0x83, 0xa7, 0x41, 0x54, 0xa0, 0xa0, 0xff, 0x36, 0xf0, 0x52,
	0x1f, 0x07, 0x99, 0x4b, 0x1f, 0x07, 0xf1, 0x86, 0xf6, 0x39, 0xe4, 0x69, 0x43, 0xe2, 0x55, 0x72,
	0xab, 0xd9, 0x09, 0x1b, 0xc7, 0xc0, 0x80, 0x96, 0xb6, 0x9e, 0x71, 0x4c, 0x74, 0xdf, 0x79, 0x4d,
	0xec, 0xe8, 0x59, 0x41, 0x25, 0x1a, 0x15, 0xa0, 0x65, 0x60, 0x03, 0xdd, 0xb3, 0x3e, 0x0d, 0xde,
	0x16, 0x79, 0x65, 0x8a, 0x0a, 0x54, 0xeb, 0x53, 0x22, 0x7c, 0xc5, 0xc1, 0xad, 0xf4, 0x4d, 0x7b,
	0x3d, 0xc7, 0xf6, 0x08, 0xfa, 0x31, 0xcc, 0x0d, 0x33, 0x18, 0xec, 0x7c, 0xa2, 0x73, 0x2e, 0x0f,
	0x51, 0xec, 0xa1, 0x87, 0x30, 0x67, 0x93, 0x37, 0xbe, 0x1e, 0x43, 0x1b, 0xf0, 0x33, 0x4b, 0xc5,
	0xed, 0x08, 0xb1, 0x70, 0x08, 0x4b, 0xc9, 0xa0, 0x8a, 0x0e, 0xe1, 0x25, 0xc0, 0xc0, 0x69, 0x18,
	0x4d, 0x2b, 0x97, 0x23, 0x51, 0x62, 0x16, 0xc2, 0xe7, 0x1c, 0xdc, 0xde, 0x32, 0x7c, 0xf3, 0xe3,
	0xe4, 0x02, 0xfd, 0x63, 0xfe, 0x10, 0x4a, 0xb1, 0xe7, 0x6c, 0xb8, 0xd9, 0xab, 0x96, 0x88, 0x9b,
	0xd0, 0xf3, 0x70, 0x03, 0x67, 0xb1, 0x37, 0x64, 0x28, 0xc1, 0x5d, 0xe1, 0x5b, 0x0e, 0x56, 0xc6,
	0x41, 0x08, 0x49, 0x57, 0xa0, 0x48, 0x6c, 0xdf, 0xb5, 0x48, 0xb4, 0xfe, 0xf3, 0xb4, 0xf5, 0x2f,
	0x77, 0x52, 0x0b, 0x3a, 0xf3, 0xc8, 0x51, 0xd5, 0x83, 0x7c, 0xd0, 0x98, 0xaf, 0x43, 0x21, 0x78,
	0x14, 0x87, 0xf4, 0xa1, 0xc8, 0xb7, 0xdb, 0x33, 0x6b, 0x2a, 0x9b, 0x51, 0x42, 0x8d, 0x04, 0xdd,
	0x99, 0x6b, 0xd3, 0xfd, 0x02, 0x16, 0x86, 0xd2, 0x56, 0x44, 0xf2, 0x3d, 0x88, 0xe5, 0x80, 0x41,
	0x4c, 0xce, 0x0c, 0x84, 0xb8, 0x2b, 0xfc, 0x9e, 0x83, 0xa5, 0x64, 0xb2, 0xba, 0x8e, 0x83, 0x77,
	0x45, 0xff, 0x6e, 0x89, 0xe9, 0x25, 0x2c, 0x25, 0x13, 0xd3, 0xb5, 0x76, 0xff, 0xcb, 0x0c, 0x54,
	0x92, 0x91, 0xd9, 0xbf, 0xa4, 0x8f, 0x01, 0x8d, 0xe4, 0xb5, 0x28, 0x25, 0xf1, 0x89, 0xc4, 0xe6,
	0xa1, 0x7b, 0x89, 0xb7, 0x32, 0xbb, 0x92, 0x7b, 0x37, 0x86, 0x5f, 0xcb, 0x8f, 0x46, 0x5e, 0xcb,
	0xd9, 0x50, 0x6d, 0xdc, 0x7b, 0x39, 0x97, 0x52, 0x59, 0xf3, 0x83, 0x32, 0x3e, 0x9c, 0x96, 0x0a,
	0x97, 0xa6, 0xa5, 0xe2, 0x70, 0x5a, 0xda, 0x2a, 0xc1, 0x74, 0x7f, 0x51, 0xe1, 0x17, 0x1c, 0xbc,
	0x9f, 0xc2, 0x44, 0x18, 0x2b, 0xef, 0x1e, 0xaf, 0x13, 0xa6, 0xa5, 0x75, 0x02, 0xe5, 0xe1, 0x04,
	0x4c, 0xfb, 0xd2, 0x86, 0x2c, 0xb7, 0x34, 0xd6, 0xcb, 0xe9, 0x29, 0xef, 0x83, 0x12, 0x14, 0x77,
	0x25, 0x59, 0x52, 0xb0, 0xc8, 0x73, 0x74, 0x70, 0xd0, 0x50, 0x70, 0x43, 0xa6, 0x3d, 0xf9, 0x14,
	0xe4, 0xe8, 0x0c, 0x9f, 0x65, 0x6f, 0x08, 0xa5, 0x21, 0xab, 0xa2, 0x82, 0xdb, 0x1a, 0x9f, 0xab,
	0x7f, 0x39, 0x0b, 0x37, 0xe3, 0x79, 0xd4, 0x3d, 0xb7, 0x4c, 0x72, 0xf0, 0x14, 0x7d, 0xc3, 0xc1,
	0xcd, 0x94, 0x5e, 0x03, 0xd5, 0xd2, 0xf6, 0x3a, 0xbe, 0x29, 0xa9, 0x5e, 0x9d, 0xb8, 0x85, 0xf5,
	0x2f, 0xfe, 0xf6, 0xcf, 0xaf, 0x33, 0xf7, 0x05, 0x94, 0xf8, 0x39, 0x90, 0xf8, 0xde, 0x66, 0xa2,
	0xea, 0xa3, 0xaf, 0x38, 0xe0, 0x93, 0xad, 0x09, 0x4a, 0xfd, 0x11, 0x6a, 0x4c, 0x03, 0x33, 0x09,
	0xa0, 0x1a, 0x03, 0xb4, 0x86, 0x1e, 0x8e, 0x02, 0xda, 0xf8, 0xf9, 0x48, 0x24, 0x7c, 0x86, 0x7e,
	0xc7, 0xc1, 0xcd, 0x94, 0x3e, 0x27, 0x9d, 0xab, 0xf1, 0x0d, 0xd1, 0x24, 0xd0, 0x5e, 0x32, 0x68,
	0xcf, 0xab, 0x13, 0x42, 0x1b, 0xe1, 0xef, 0x57, 0x1c, 0xdc, 0x4c, 0xe9, 0x60, 0xd2, 0xa1, 0x8e,
	0x6f, 0x75, 0xaa, 0x8b, 0x23, 0x79, 0x49, 0x3a, 0xed, 0xf9, 0x17, 0x11, 0x75, 0xeb, 0x93, 0x52,
	0xf7, 0x6b, 0x0e, 0x16, 0xd2, 0x3a, 0x02, 0xb4, 0x91, 0x06, 0xe8, 0x92, 0x86, 0xa9, 0xfa, 0xc1,
	0xe4, 0x06, 0x41, 0x2c, 0x0b, 0xf7, 0x19, 0xd6, 0x15, 0xe1, 0xfd, 0x14, 0xac, 0x1e, 0x33, 0xdc,
	0xe4, 0xd6, 0xd1, 0x97, 0x1c, 0xf0, 0xc9, 0xfb, 0x9d, 0x7e, 0xe3, 0xc6, 0x74, 0x11, 0xd5, 0x2b,
	0xd2, 0x83, 0x70, 0x8f, 0xe1, 0xb8, 0x2d, 0xcc, 0x25, 0x70, 0x6c, 0xc6, 0xab, 0xc3, 0x6f, 0x39,
	0x58, 0x4c, 0x2f, 0xc1, 0xe8, 0xe9, 0x75, 0xca, 0x75, 0x00, 0xa9, 0x7e, 0xfd, 0x0a, 0x2f, 0x3c,
	0x64, 0x30, 0x57, 0x85, 0xe5, 0x24, 0xcc, 0x57, 0x03, 0x3b, 0x4a, 0xd8, 0x17, 0x1c, 0xcc, 0x0e,
	0x05, 0x1f, 0x5a, 0xbb, 0x32, 0x3e, 0x27, 0xa5, 0xea, 0x11, 0xc3, 0x70, 0x17, 0xdd, 0x49, 0x60,
	0x18, 0xba, 0x5b, 0xf4, 0x5e, 0x7d, 0xc3, 0x01, 0x9f, 0x8c, 0xb4, 0xf4, 0x53, 0x1b, 0x53, 0xf3,
	0xaf, 0x84, 0xf2, 0x8c, 0x41, 0x79, 0x52, 0xbd, 0x0a, 0xca, 0xd0, 0x29, 0x7e, 0xce, 0x01, 0x9f,
	0x8c, 0xaa, 0x74, 0x58, 0x63, 0xaa, 0xf9, 0xd8, 0xc0, 0x0b, 0x99, 0x59, 0xbf, 0x92, 0x99, 0xaf,
	0x39, 0x98, 0x1f, 0xa9, 0x6f, 0xe8, 0xf1, 0x24, 0xd1, 0xd3, 0xbf, 0x3e, 0x4f, 0x26, 0xd4, 0x0e,
	0x6f, 0xce, 0x5d, 0x86, 0x6d, 0x59, 0x58, 0x4c, 0x62, 0xeb, 0x47, 0xd9, 0xd6, 0x27, 0x7f, 0x7a,
	0xbb, 0xc2, 0xfd, 0xf5, 0xed, 0x0a, 0xf7, 0x8f, 0xb7, 0x2b, 0x1c, 0x2c, 0x9a, 0xce, 0x69, 0xca,
	0x12, 0x5b, 0x7c, 0xcc, 0x7b, 0x9b, 0xee, 0xbf, 0xcd, 0xfd, 0x74, 0x33, 0xd2, 0x73, 0x4e, 0x0c,
	0xfb, 0xb8, 0xe6, 0xb8, 0xc7, 0x1b, 0xc7, 0xc4, 0x66, 0xec, 0x6c, 0x04, 0x53, 0x46, 0xcf, 0xf2,
	0xe2, 0x7f, 0x39, 0xbd, 0x88, 0xbe, 0xff, 0xcd, 0x71, 0xaf, 0x0a, 0x4c, 0xf3, 0xd9, 0x7f, 0x03,
	0x00, 0x00, 0xff, 0xff, 0x09, 0x1e, 0xe2, 0xe4, 0x9b, 0x1a, 0x00, 0x00,
}
