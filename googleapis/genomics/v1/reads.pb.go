// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/genomics/v1/reads.proto

package genomics

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_longrunning "google.golang.org/genproto/googleapis/longrunning"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "google.golang.org/genproto/protobuf/field_mask"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ImportReadGroupSetsRequest_PartitionStrategy int32

const (
	ImportReadGroupSetsRequest_PARTITION_STRATEGY_UNSPECIFIED ImportReadGroupSetsRequest_PartitionStrategy = 0
	// In most cases, this strategy yields one read group set per file. This is
	// the default behavior.
	//
	// Allocate one read group set per file per sample. For BAM files, read
	// groups are considered to share a sample if they have identical sample
	// names. Furthermore, all reads for each file which do not belong to a read
	// group, if any, will be grouped into a single read group set per-file.
	ImportReadGroupSetsRequest_PER_FILE_PER_SAMPLE ImportReadGroupSetsRequest_PartitionStrategy = 1
	// Includes all read groups in all imported files into a single read group
	// set. Requires that the headers for all imported files are equivalent. All
	// reads which do not belong to a read group, if any, will be grouped into a
	// separate read group set.
	ImportReadGroupSetsRequest_MERGE_ALL ImportReadGroupSetsRequest_PartitionStrategy = 2
)

var ImportReadGroupSetsRequest_PartitionStrategy_name = map[int32]string{
	0: "PARTITION_STRATEGY_UNSPECIFIED",
	1: "PER_FILE_PER_SAMPLE",
	2: "MERGE_ALL",
}
var ImportReadGroupSetsRequest_PartitionStrategy_value = map[string]int32{
	"PARTITION_STRATEGY_UNSPECIFIED": 0,
	"PER_FILE_PER_SAMPLE":            1,
	"MERGE_ALL":                      2,
}

func (x ImportReadGroupSetsRequest_PartitionStrategy) String() string {
	return proto.EnumName(ImportReadGroupSetsRequest_PartitionStrategy_name, int32(x))
}
func (ImportReadGroupSetsRequest_PartitionStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorReads, []int{2, 0}
}

// The read group set search request.
type SearchReadGroupSetsRequest struct {
	// Restricts this query to read group sets within the given datasets. At least
	// one ID must be provided.
	DatasetIds []string `protobuf:"bytes,1,rep,name=dataset_ids,json=datasetIds" json:"dataset_ids,omitempty"`
	// Only return read group sets for which a substring of the name matches this
	// string.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,2,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The maximum number of results to return in a single page. If unspecified,
	// defaults to 256. The maximum value is 1024.
	PageSize int32 `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *SearchReadGroupSetsRequest) Reset()                    { *m = SearchReadGroupSetsRequest{} }
func (m *SearchReadGroupSetsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchReadGroupSetsRequest) ProtoMessage()               {}
func (*SearchReadGroupSetsRequest) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{0} }

func (m *SearchReadGroupSetsRequest) GetDatasetIds() []string {
	if m != nil {
		return m.DatasetIds
	}
	return nil
}

func (m *SearchReadGroupSetsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SearchReadGroupSetsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchReadGroupSetsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// The read group set search response.
type SearchReadGroupSetsResponse struct {
	// The list of matching read group sets.
	ReadGroupSets []*ReadGroupSet `protobuf:"bytes,1,rep,name=read_group_sets,json=readGroupSets" json:"read_group_sets,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *SearchReadGroupSetsResponse) Reset()                    { *m = SearchReadGroupSetsResponse{} }
func (m *SearchReadGroupSetsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchReadGroupSetsResponse) ProtoMessage()               {}
func (*SearchReadGroupSetsResponse) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{1} }

func (m *SearchReadGroupSetsResponse) GetReadGroupSets() []*ReadGroupSet {
	if m != nil {
		return m.ReadGroupSets
	}
	return nil
}

func (m *SearchReadGroupSetsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// The read group set import request.
type ImportReadGroupSetsRequest struct {
	// Required. The ID of the dataset these read group sets will belong to. The
	// caller must have WRITE permissions to this dataset.
	DatasetId string `protobuf:"bytes,1,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
	// The reference set to which the imported read group sets are aligned to, if
	// any. The reference names of this reference set must be a superset of those
	// found in the imported file headers. If no reference set id is provided, a
	// best effort is made to associate with a matching reference set.
	ReferenceSetId string `protobuf:"bytes,4,opt,name=reference_set_id,json=referenceSetId,proto3" json:"reference_set_id,omitempty"`
	// A list of URIs pointing at [BAM
	// files](https://samtools.github.io/hts-specs/SAMv1.pdf)
	// in Google Cloud Storage.
	// Those URIs can include wildcards (*), but do not add or remove
	// matching files before import has completed.
	//
	// Note that Google Cloud Storage object listing is only eventually
	// consistent: files added may be not be immediately visible to
	// everyone. Thus, if using a wildcard it is preferable not to start
	// the import immediately after the files are created.
	SourceUris []string `protobuf:"bytes,2,rep,name=source_uris,json=sourceUris" json:"source_uris,omitempty"`
	// The partition strategy describes how read groups are partitioned into read
	// group sets.
	PartitionStrategy ImportReadGroupSetsRequest_PartitionStrategy `protobuf:"varint,5,opt,name=partition_strategy,json=partitionStrategy,proto3,enum=google.genomics.v1.ImportReadGroupSetsRequest_PartitionStrategy" json:"partition_strategy,omitempty"`
}

func (m *ImportReadGroupSetsRequest) Reset()                    { *m = ImportReadGroupSetsRequest{} }
func (m *ImportReadGroupSetsRequest) String() string            { return proto.CompactTextString(m) }
func (*ImportReadGroupSetsRequest) ProtoMessage()               {}
func (*ImportReadGroupSetsRequest) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{2} }

func (m *ImportReadGroupSetsRequest) GetDatasetId() string {
	if m != nil {
		return m.DatasetId
	}
	return ""
}

func (m *ImportReadGroupSetsRequest) GetReferenceSetId() string {
	if m != nil {
		return m.ReferenceSetId
	}
	return ""
}

func (m *ImportReadGroupSetsRequest) GetSourceUris() []string {
	if m != nil {
		return m.SourceUris
	}
	return nil
}

func (m *ImportReadGroupSetsRequest) GetPartitionStrategy() ImportReadGroupSetsRequest_PartitionStrategy {
	if m != nil {
		return m.PartitionStrategy
	}
	return ImportReadGroupSetsRequest_PARTITION_STRATEGY_UNSPECIFIED
}

// The read group set import response.
type ImportReadGroupSetsResponse struct {
	// IDs of the read group sets that were created.
	ReadGroupSetIds []string `protobuf:"bytes,1,rep,name=read_group_set_ids,json=readGroupSetIds" json:"read_group_set_ids,omitempty"`
}

func (m *ImportReadGroupSetsResponse) Reset()                    { *m = ImportReadGroupSetsResponse{} }
func (m *ImportReadGroupSetsResponse) String() string            { return proto.CompactTextString(m) }
func (*ImportReadGroupSetsResponse) ProtoMessage()               {}
func (*ImportReadGroupSetsResponse) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{3} }

func (m *ImportReadGroupSetsResponse) GetReadGroupSetIds() []string {
	if m != nil {
		return m.ReadGroupSetIds
	}
	return nil
}

// The read group set export request.
type ExportReadGroupSetRequest struct {
	// Required. The Google Cloud project ID that owns this
	// export. The caller must have WRITE access to this project.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Required. A Google Cloud Storage URI for the exported BAM file.
	// The currently authenticated user must have write access to the new file.
	// An error will be returned if the URI already contains data.
	ExportUri string `protobuf:"bytes,2,opt,name=export_uri,json=exportUri,proto3" json:"export_uri,omitempty"`
	// Required. The ID of the read group set to export. The caller must have
	// READ access to this read group set.
	ReadGroupSetId string `protobuf:"bytes,3,opt,name=read_group_set_id,json=readGroupSetId,proto3" json:"read_group_set_id,omitempty"`
	// The reference names to export. If this is not specified, all reference
	// sequences, including unmapped reads, are exported.
	// Use `*` to export only unmapped reads.
	ReferenceNames []string `protobuf:"bytes,4,rep,name=reference_names,json=referenceNames" json:"reference_names,omitempty"`
}

func (m *ExportReadGroupSetRequest) Reset()                    { *m = ExportReadGroupSetRequest{} }
func (m *ExportReadGroupSetRequest) String() string            { return proto.CompactTextString(m) }
func (*ExportReadGroupSetRequest) ProtoMessage()               {}
func (*ExportReadGroupSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{4} }

func (m *ExportReadGroupSetRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *ExportReadGroupSetRequest) GetExportUri() string {
	if m != nil {
		return m.ExportUri
	}
	return ""
}

func (m *ExportReadGroupSetRequest) GetReadGroupSetId() string {
	if m != nil {
		return m.ReadGroupSetId
	}
	return ""
}

func (m *ExportReadGroupSetRequest) GetReferenceNames() []string {
	if m != nil {
		return m.ReferenceNames
	}
	return nil
}

type UpdateReadGroupSetRequest struct {
	// The ID of the read group set to be updated. The caller must have WRITE
	// permissions to the dataset associated with this read group set.
	ReadGroupSetId string `protobuf:"bytes,1,opt,name=read_group_set_id,json=readGroupSetId,proto3" json:"read_group_set_id,omitempty"`
	// The new read group set data. See `updateMask` for details on mutability of
	// fields.
	ReadGroupSet *ReadGroupSet `protobuf:"bytes,2,opt,name=read_group_set,json=readGroupSet" json:"read_group_set,omitempty"`
	// An optional mask specifying which fields to update. Supported fields:
	//
	// * [name][google.genomics.v1.ReadGroupSet.name].
	// * [referenceSetId][google.genomics.v1.ReadGroupSet.reference_set_id].
	//
	// Leaving `updateMask` unset is equivalent to specifying all mutable
	// fields.
	UpdateMask *google_protobuf2.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask" json:"update_mask,omitempty"`
}

func (m *UpdateReadGroupSetRequest) Reset()                    { *m = UpdateReadGroupSetRequest{} }
func (m *UpdateReadGroupSetRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateReadGroupSetRequest) ProtoMessage()               {}
func (*UpdateReadGroupSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{5} }

func (m *UpdateReadGroupSetRequest) GetReadGroupSetId() string {
	if m != nil {
		return m.ReadGroupSetId
	}
	return ""
}

func (m *UpdateReadGroupSetRequest) GetReadGroupSet() *ReadGroupSet {
	if m != nil {
		return m.ReadGroupSet
	}
	return nil
}

func (m *UpdateReadGroupSetRequest) GetUpdateMask() *google_protobuf2.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

type DeleteReadGroupSetRequest struct {
	// The ID of the read group set to be deleted. The caller must have WRITE
	// permissions to the dataset associated with this read group set.
	ReadGroupSetId string `protobuf:"bytes,1,opt,name=read_group_set_id,json=readGroupSetId,proto3" json:"read_group_set_id,omitempty"`
}

func (m *DeleteReadGroupSetRequest) Reset()                    { *m = DeleteReadGroupSetRequest{} }
func (m *DeleteReadGroupSetRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteReadGroupSetRequest) ProtoMessage()               {}
func (*DeleteReadGroupSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{6} }

func (m *DeleteReadGroupSetRequest) GetReadGroupSetId() string {
	if m != nil {
		return m.ReadGroupSetId
	}
	return ""
}

type GetReadGroupSetRequest struct {
	// The ID of the read group set.
	ReadGroupSetId string `protobuf:"bytes,1,opt,name=read_group_set_id,json=readGroupSetId,proto3" json:"read_group_set_id,omitempty"`
}

func (m *GetReadGroupSetRequest) Reset()                    { *m = GetReadGroupSetRequest{} }
func (m *GetReadGroupSetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetReadGroupSetRequest) ProtoMessage()               {}
func (*GetReadGroupSetRequest) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{7} }

func (m *GetReadGroupSetRequest) GetReadGroupSetId() string {
	if m != nil {
		return m.ReadGroupSetId
	}
	return ""
}

type ListCoverageBucketsRequest struct {
	// Required. The ID of the read group set over which coverage is requested.
	ReadGroupSetId string `protobuf:"bytes,1,opt,name=read_group_set_id,json=readGroupSetId,proto3" json:"read_group_set_id,omitempty"`
	// The name of the reference to query, within the reference set associated
	// with this query. Optional.
	ReferenceName string `protobuf:"bytes,3,opt,name=reference_name,json=referenceName,proto3" json:"reference_name,omitempty"`
	// The start position of the range on the reference, 0-based inclusive. If
	// specified, `referenceName` must also be specified. Defaults to 0.
	Start int64 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	// The end position of the range on the reference, 0-based exclusive. If
	// specified, `referenceName` must also be specified. If unset or 0, defaults
	// to the length of the reference.
	End int64 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
	// The desired width of each reported coverage bucket in base pairs. This
	// will be rounded down to the nearest precomputed bucket width; the value
	// of which is returned as `bucketWidth` in the response. Defaults
	// to infinity (each bucket spans an entire reference sequence) or the length
	// of the target range, if specified. The smallest precomputed
	// `bucketWidth` is currently 2048 base pairs; this is subject to
	// change.
	TargetBucketWidth int64 `protobuf:"varint,6,opt,name=target_bucket_width,json=targetBucketWidth,proto3" json:"target_bucket_width,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,7,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The maximum number of results to return in a single page. If unspecified,
	// defaults to 1024. The maximum value is 2048.
	PageSize int32 `protobuf:"varint,8,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *ListCoverageBucketsRequest) Reset()                    { *m = ListCoverageBucketsRequest{} }
func (m *ListCoverageBucketsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListCoverageBucketsRequest) ProtoMessage()               {}
func (*ListCoverageBucketsRequest) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{8} }

func (m *ListCoverageBucketsRequest) GetReadGroupSetId() string {
	if m != nil {
		return m.ReadGroupSetId
	}
	return ""
}

func (m *ListCoverageBucketsRequest) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *ListCoverageBucketsRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ListCoverageBucketsRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *ListCoverageBucketsRequest) GetTargetBucketWidth() int64 {
	if m != nil {
		return m.TargetBucketWidth
	}
	return 0
}

func (m *ListCoverageBucketsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListCoverageBucketsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// A bucket over which read coverage has been precomputed. A bucket corresponds
// to a specific range of the reference sequence.
type CoverageBucket struct {
	// The genomic coordinate range spanned by this bucket.
	Range *Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	// The average number of reads which are aligned to each individual
	// reference base in this bucket.
	MeanCoverage float32 `protobuf:"fixed32,2,opt,name=mean_coverage,json=meanCoverage,proto3" json:"mean_coverage,omitempty"`
}

func (m *CoverageBucket) Reset()                    { *m = CoverageBucket{} }
func (m *CoverageBucket) String() string            { return proto.CompactTextString(m) }
func (*CoverageBucket) ProtoMessage()               {}
func (*CoverageBucket) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{9} }

func (m *CoverageBucket) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *CoverageBucket) GetMeanCoverage() float32 {
	if m != nil {
		return m.MeanCoverage
	}
	return 0
}

type ListCoverageBucketsResponse struct {
	// The length of each coverage bucket in base pairs. Note that buckets at the
	// end of a reference sequence may be shorter. This value is omitted if the
	// bucket width is infinity (the default behaviour, with no range or
	// `targetBucketWidth`).
	BucketWidth int64 `protobuf:"varint,1,opt,name=bucket_width,json=bucketWidth,proto3" json:"bucket_width,omitempty"`
	// The coverage buckets. The list of buckets is sparse; a bucket with 0
	// overlapping reads is not returned. A bucket never crosses more than one
	// reference sequence. Each bucket has width `bucketWidth`, unless
	// its end is the end of the reference sequence.
	CoverageBuckets []*CoverageBucket `protobuf:"bytes,2,rep,name=coverage_buckets,json=coverageBuckets" json:"coverage_buckets,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *ListCoverageBucketsResponse) Reset()         { *m = ListCoverageBucketsResponse{} }
func (m *ListCoverageBucketsResponse) String() string { return proto.CompactTextString(m) }
func (*ListCoverageBucketsResponse) ProtoMessage()    {}
func (*ListCoverageBucketsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorReads, []int{10}
}

func (m *ListCoverageBucketsResponse) GetBucketWidth() int64 {
	if m != nil {
		return m.BucketWidth
	}
	return 0
}

func (m *ListCoverageBucketsResponse) GetCoverageBuckets() []*CoverageBucket {
	if m != nil {
		return m.CoverageBuckets
	}
	return nil
}

func (m *ListCoverageBucketsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// The read search request.
type SearchReadsRequest struct {
	// The IDs of the read groups sets within which to search for reads. All
	// specified read group sets must be aligned against a common set of reference
	// sequences; this defines the genomic coordinates for the query. Must specify
	// one of `readGroupSetIds` or `readGroupIds`.
	ReadGroupSetIds []string `protobuf:"bytes,1,rep,name=read_group_set_ids,json=readGroupSetIds" json:"read_group_set_ids,omitempty"`
	// The IDs of the read groups within which to search for reads. All specified
	// read groups must belong to the same read group sets. Must specify one of
	// `readGroupSetIds` or `readGroupIds`.
	ReadGroupIds []string `protobuf:"bytes,5,rep,name=read_group_ids,json=readGroupIds" json:"read_group_ids,omitempty"`
	// The reference sequence name, for example `chr1`, `1`, or `chrX`. If set to
	// `*`, only unmapped reads are returned. If unspecified, all reads (mapped
	// and unmapped) are returned.
	ReferenceName string `protobuf:"bytes,7,opt,name=reference_name,json=referenceName,proto3" json:"reference_name,omitempty"`
	// The start position of the range on the reference, 0-based inclusive. If
	// specified, `referenceName` must also be specified.
	Start int64 `protobuf:"varint,8,opt,name=start,proto3" json:"start,omitempty"`
	// The end position of the range on the reference, 0-based exclusive. If
	// specified, `referenceName` must also be specified.
	End int64 `protobuf:"varint,9,opt,name=end,proto3" json:"end,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// To get the next page of results, set this parameter to the value of
	// `nextPageToken` from the previous response.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The maximum number of results to return in a single page. If unspecified,
	// defaults to 256. The maximum value is 2048.
	PageSize int32 `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (m *SearchReadsRequest) Reset()                    { *m = SearchReadsRequest{} }
func (m *SearchReadsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchReadsRequest) ProtoMessage()               {}
func (*SearchReadsRequest) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{11} }

func (m *SearchReadsRequest) GetReadGroupSetIds() []string {
	if m != nil {
		return m.ReadGroupSetIds
	}
	return nil
}

func (m *SearchReadsRequest) GetReadGroupIds() []string {
	if m != nil {
		return m.ReadGroupIds
	}
	return nil
}

func (m *SearchReadsRequest) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *SearchReadsRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SearchReadsRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *SearchReadsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *SearchReadsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// The read search response.
type SearchReadsResponse struct {
	// The list of matching alignments sorted by mapped genomic coordinate,
	// if any, ascending in position within the same reference. Unmapped reads,
	// which have no position, are returned contiguously and are sorted in
	// ascending lexicographic order by fragment name.
	Alignments []*Read `protobuf:"bytes,1,rep,name=alignments" json:"alignments,omitempty"`
	// The continuation token, which is used to page through large result sets.
	// Provide this value in a subsequent request to return the next page of
	// results. This field will be empty if there aren't any additional results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (m *SearchReadsResponse) Reset()                    { *m = SearchReadsResponse{} }
func (m *SearchReadsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchReadsResponse) ProtoMessage()               {}
func (*SearchReadsResponse) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{12} }

func (m *SearchReadsResponse) GetAlignments() []*Read {
	if m != nil {
		return m.Alignments
	}
	return nil
}

func (m *SearchReadsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// The stream reads request.
type StreamReadsRequest struct {
	// The Google Cloud project ID which will be billed
	// for this access. The caller must have WRITE access to this project.
	// Required.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// The ID of the read group set from which to stream reads.
	ReadGroupSetId string `protobuf:"bytes,2,opt,name=read_group_set_id,json=readGroupSetId,proto3" json:"read_group_set_id,omitempty"`
	// The reference sequence name, for example `chr1`,
	// `1`, or `chrX`. If set to *, only unmapped reads are
	// returned.
	ReferenceName string `protobuf:"bytes,3,opt,name=reference_name,json=referenceName,proto3" json:"reference_name,omitempty"`
	// The start position of the range on the reference, 0-based inclusive. If
	// specified, `referenceName` must also be specified.
	Start int64 `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	// The end position of the range on the reference, 0-based exclusive. If
	// specified, `referenceName` must also be specified.
	End int64 `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
	// Restricts results to a shard containing approximately `1/totalShards`
	// of the normal response payload for this query. Results from a sharded
	// request are disjoint from those returned by all queries which differ only
	// in their shard parameter. A shard may yield 0 results; this is especially
	// likely for large values of `totalShards`.
	//
	// Valid values are `[0, totalShards)`.
	Shard int32 `protobuf:"varint,6,opt,name=shard,proto3" json:"shard,omitempty"`
	// Specifying `totalShards` causes a disjoint subset of the normal response
	// payload to be returned for each query with a unique `shard` parameter
	// specified. A best effort is made to yield equally sized shards. Sharding
	// can be used to distribute processing amongst workers, where each worker is
	// assigned a unique `shard` number and all workers specify the same
	// `totalShards` number. The union of reads returned for all sharded queries
	// `[0, totalShards)` is equal to those returned by a single unsharded query.
	//
	// Queries for different values of `totalShards` with common divisors will
	// share shard boundaries. For example, streaming `shard` 2 of 5
	// `totalShards` yields the same results as streaming `shard`s 4 and 5 of 10
	// `totalShards`. This property can be leveraged for adaptive retries.
	TotalShards int32 `protobuf:"varint,7,opt,name=total_shards,json=totalShards,proto3" json:"total_shards,omitempty"`
}

func (m *StreamReadsRequest) Reset()                    { *m = StreamReadsRequest{} }
func (m *StreamReadsRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamReadsRequest) ProtoMessage()               {}
func (*StreamReadsRequest) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{13} }

func (m *StreamReadsRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *StreamReadsRequest) GetReadGroupSetId() string {
	if m != nil {
		return m.ReadGroupSetId
	}
	return ""
}

func (m *StreamReadsRequest) GetReferenceName() string {
	if m != nil {
		return m.ReferenceName
	}
	return ""
}

func (m *StreamReadsRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *StreamReadsRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *StreamReadsRequest) GetShard() int32 {
	if m != nil {
		return m.Shard
	}
	return 0
}

func (m *StreamReadsRequest) GetTotalShards() int32 {
	if m != nil {
		return m.TotalShards
	}
	return 0
}

type StreamReadsResponse struct {
	Alignments []*Read `protobuf:"bytes,1,rep,name=alignments" json:"alignments,omitempty"`
}

func (m *StreamReadsResponse) Reset()                    { *m = StreamReadsResponse{} }
func (m *StreamReadsResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamReadsResponse) ProtoMessage()               {}
func (*StreamReadsResponse) Descriptor() ([]byte, []int) { return fileDescriptorReads, []int{14} }

func (m *StreamReadsResponse) GetAlignments() []*Read {
	if m != nil {
		return m.Alignments
	}
	return nil
}

func init() {
	proto.RegisterType((*SearchReadGroupSetsRequest)(nil), "google.genomics.v1.SearchReadGroupSetsRequest")
	proto.RegisterType((*SearchReadGroupSetsResponse)(nil), "google.genomics.v1.SearchReadGroupSetsResponse")
	proto.RegisterType((*ImportReadGroupSetsRequest)(nil), "google.genomics.v1.ImportReadGroupSetsRequest")
	proto.RegisterType((*ImportReadGroupSetsResponse)(nil), "google.genomics.v1.ImportReadGroupSetsResponse")
	proto.RegisterType((*ExportReadGroupSetRequest)(nil), "google.genomics.v1.ExportReadGroupSetRequest")
	proto.RegisterType((*UpdateReadGroupSetRequest)(nil), "google.genomics.v1.UpdateReadGroupSetRequest")
	proto.RegisterType((*DeleteReadGroupSetRequest)(nil), "google.genomics.v1.DeleteReadGroupSetRequest")
	proto.RegisterType((*GetReadGroupSetRequest)(nil), "google.genomics.v1.GetReadGroupSetRequest")
	proto.RegisterType((*ListCoverageBucketsRequest)(nil), "google.genomics.v1.ListCoverageBucketsRequest")
	proto.RegisterType((*CoverageBucket)(nil), "google.genomics.v1.CoverageBucket")
	proto.RegisterType((*ListCoverageBucketsResponse)(nil), "google.genomics.v1.ListCoverageBucketsResponse")
	proto.RegisterType((*SearchReadsRequest)(nil), "google.genomics.v1.SearchReadsRequest")
	proto.RegisterType((*SearchReadsResponse)(nil), "google.genomics.v1.SearchReadsResponse")
	proto.RegisterType((*StreamReadsRequest)(nil), "google.genomics.v1.StreamReadsRequest")
	proto.RegisterType((*StreamReadsResponse)(nil), "google.genomics.v1.StreamReadsResponse")
	proto.RegisterEnum("google.genomics.v1.ImportReadGroupSetsRequest_PartitionStrategy", ImportReadGroupSetsRequest_PartitionStrategy_name, ImportReadGroupSetsRequest_PartitionStrategy_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for StreamingReadService service

type StreamingReadServiceClient interface {
	// Returns a stream of all the reads matching the search request, ordered
	// by reference name, position, and ID.
	StreamReads(ctx context.Context, in *StreamReadsRequest, opts ...grpc.CallOption) (StreamingReadService_StreamReadsClient, error)
}

type streamingReadServiceClient struct {
	cc *grpc.ClientConn
}

func NewStreamingReadServiceClient(cc *grpc.ClientConn) StreamingReadServiceClient {
	return &streamingReadServiceClient{cc}
}

func (c *streamingReadServiceClient) StreamReads(ctx context.Context, in *StreamReadsRequest, opts ...grpc.CallOption) (StreamingReadService_StreamReadsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StreamingReadService_serviceDesc.Streams[0], c.cc, "/google.genomics.v1.StreamingReadService/StreamReads", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingReadServiceStreamReadsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingReadService_StreamReadsClient interface {
	Recv() (*StreamReadsResponse, error)
	grpc.ClientStream
}

type streamingReadServiceStreamReadsClient struct {
	grpc.ClientStream
}

func (x *streamingReadServiceStreamReadsClient) Recv() (*StreamReadsResponse, error) {
	m := new(StreamReadsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for StreamingReadService service

type StreamingReadServiceServer interface {
	// Returns a stream of all the reads matching the search request, ordered
	// by reference name, position, and ID.
	StreamReads(*StreamReadsRequest, StreamingReadService_StreamReadsServer) error
}

func RegisterStreamingReadServiceServer(s *grpc.Server, srv StreamingReadServiceServer) {
	s.RegisterService(&_StreamingReadService_serviceDesc, srv)
}

func _StreamingReadService_StreamReads_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamReadsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingReadServiceServer).StreamReads(m, &streamingReadServiceStreamReadsServer{stream})
}

type StreamingReadService_StreamReadsServer interface {
	Send(*StreamReadsResponse) error
	grpc.ServerStream
}

type streamingReadServiceStreamReadsServer struct {
	grpc.ServerStream
}

func (x *streamingReadServiceStreamReadsServer) Send(m *StreamReadsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _StreamingReadService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.genomics.v1.StreamingReadService",
	HandlerType: (*StreamingReadServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamReads",
			Handler:       _StreamingReadService_StreamReads_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "google/genomics/v1/reads.proto",
}

// Client API for ReadServiceV1 service

type ReadServiceV1Client interface {
	// Creates read group sets by asynchronously importing the provided
	// information.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// The caller must have WRITE permissions to the dataset.
	//
	// ## Notes on [BAM](https://samtools.github.io/hts-specs/SAMv1.pdf) import
	//
	// - Tags will be converted to strings - tag types are not preserved
	// - Comments (`@CO`) in the input file header will not be preserved
	// - Original header order of references (`@SQ`) will not be preserved
	// - Any reverse stranded unmapped reads will be reverse complemented, and
	// their qualities (also the "BQ" and "OQ" tags, if any) will be reversed
	// - Unmapped reads will be stripped of positional information (reference name
	// and position)
	ImportReadGroupSets(ctx context.Context, in *ImportReadGroupSetsRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error)
	// Exports a read group set to a BAM file in Google Cloud Storage.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Note that currently there may be some differences between exported BAM
	// files and the original BAM file at the time of import. See
	// [ImportReadGroupSets][google.genomics.v1.ReadServiceV1.ImportReadGroupSets]
	// for caveats.
	ExportReadGroupSet(ctx context.Context, in *ExportReadGroupSetRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error)
	// Searches for read group sets matching the criteria.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Implements
	// [GlobalAllianceApi.searchReadGroupSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L135).
	SearchReadGroupSets(ctx context.Context, in *SearchReadGroupSetsRequest, opts ...grpc.CallOption) (*SearchReadGroupSetsResponse, error)
	// Updates a read group set.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// This method supports patch semantics.
	UpdateReadGroupSet(ctx context.Context, in *UpdateReadGroupSetRequest, opts ...grpc.CallOption) (*ReadGroupSet, error)
	// Deletes a read group set.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	DeleteReadGroupSet(ctx context.Context, in *DeleteReadGroupSetRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	// Gets a read group set by ID.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	GetReadGroupSet(ctx context.Context, in *GetReadGroupSetRequest, opts ...grpc.CallOption) (*ReadGroupSet, error)
	// Lists fixed width coverage buckets for a read group set, each of which
	// correspond to a range of a reference sequence. Each bucket summarizes
	// coverage information across its corresponding genomic range.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Coverage is defined as the number of reads which are aligned to a given
	// base in the reference sequence. Coverage buckets are available at several
	// precomputed bucket widths, enabling retrieval of various coverage 'zoom
	// levels'. The caller must have READ permissions for the target read group
	// set.
	ListCoverageBuckets(ctx context.Context, in *ListCoverageBucketsRequest, opts ...grpc.CallOption) (*ListCoverageBucketsResponse, error)
	// Gets a list of reads for one or more read group sets.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Reads search operates over a genomic coordinate space of reference sequence
	// & position defined over the reference sequences to which the requested
	// read group sets are aligned.
	//
	// If a target positional range is specified, search returns all reads whose
	// alignment to the reference genome overlap the range. A query which
	// specifies only read group set IDs yields all reads in those read group
	// sets, including unmapped reads.
	//
	// All reads returned (including reads on subsequent pages) are ordered by
	// genomic coordinate (by reference sequence, then position). Reads with
	// equivalent genomic coordinates are returned in an unspecified order. This
	// order is consistent, such that two queries for the same content (regardless
	// of page size) yield reads in the same order across their respective streams
	// of paginated responses.
	//
	// Implements
	// [GlobalAllianceApi.searchReads](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L85).
	SearchReads(ctx context.Context, in *SearchReadsRequest, opts ...grpc.CallOption) (*SearchReadsResponse, error)
}

type readServiceV1Client struct {
	cc *grpc.ClientConn
}

func NewReadServiceV1Client(cc *grpc.ClientConn) ReadServiceV1Client {
	return &readServiceV1Client{cc}
}

func (c *readServiceV1Client) ImportReadGroupSets(ctx context.Context, in *ImportReadGroupSetsRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	err := grpc.Invoke(ctx, "/google.genomics.v1.ReadServiceV1/ImportReadGroupSets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readServiceV1Client) ExportReadGroupSet(ctx context.Context, in *ExportReadGroupSetRequest, opts ...grpc.CallOption) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	err := grpc.Invoke(ctx, "/google.genomics.v1.ReadServiceV1/ExportReadGroupSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readServiceV1Client) SearchReadGroupSets(ctx context.Context, in *SearchReadGroupSetsRequest, opts ...grpc.CallOption) (*SearchReadGroupSetsResponse, error) {
	out := new(SearchReadGroupSetsResponse)
	err := grpc.Invoke(ctx, "/google.genomics.v1.ReadServiceV1/SearchReadGroupSets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readServiceV1Client) UpdateReadGroupSet(ctx context.Context, in *UpdateReadGroupSetRequest, opts ...grpc.CallOption) (*ReadGroupSet, error) {
	out := new(ReadGroupSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.ReadServiceV1/UpdateReadGroupSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readServiceV1Client) DeleteReadGroupSet(ctx context.Context, in *DeleteReadGroupSetRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/google.genomics.v1.ReadServiceV1/DeleteReadGroupSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readServiceV1Client) GetReadGroupSet(ctx context.Context, in *GetReadGroupSetRequest, opts ...grpc.CallOption) (*ReadGroupSet, error) {
	out := new(ReadGroupSet)
	err := grpc.Invoke(ctx, "/google.genomics.v1.ReadServiceV1/GetReadGroupSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readServiceV1Client) ListCoverageBuckets(ctx context.Context, in *ListCoverageBucketsRequest, opts ...grpc.CallOption) (*ListCoverageBucketsResponse, error) {
	out := new(ListCoverageBucketsResponse)
	err := grpc.Invoke(ctx, "/google.genomics.v1.ReadServiceV1/ListCoverageBuckets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readServiceV1Client) SearchReads(ctx context.Context, in *SearchReadsRequest, opts ...grpc.CallOption) (*SearchReadsResponse, error) {
	out := new(SearchReadsResponse)
	err := grpc.Invoke(ctx, "/google.genomics.v1.ReadServiceV1/SearchReads", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ReadServiceV1 service

type ReadServiceV1Server interface {
	// Creates read group sets by asynchronously importing the provided
	// information.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// The caller must have WRITE permissions to the dataset.
	//
	// ## Notes on [BAM](https://samtools.github.io/hts-specs/SAMv1.pdf) import
	//
	// - Tags will be converted to strings - tag types are not preserved
	// - Comments (`@CO`) in the input file header will not be preserved
	// - Original header order of references (`@SQ`) will not be preserved
	// - Any reverse stranded unmapped reads will be reverse complemented, and
	// their qualities (also the "BQ" and "OQ" tags, if any) will be reversed
	// - Unmapped reads will be stripped of positional information (reference name
	// and position)
	ImportReadGroupSets(context.Context, *ImportReadGroupSetsRequest) (*google_longrunning.Operation, error)
	// Exports a read group set to a BAM file in Google Cloud Storage.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Note that currently there may be some differences between exported BAM
	// files and the original BAM file at the time of import. See
	// [ImportReadGroupSets][google.genomics.v1.ReadServiceV1.ImportReadGroupSets]
	// for caveats.
	ExportReadGroupSet(context.Context, *ExportReadGroupSetRequest) (*google_longrunning.Operation, error)
	// Searches for read group sets matching the criteria.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Implements
	// [GlobalAllianceApi.searchReadGroupSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L135).
	SearchReadGroupSets(context.Context, *SearchReadGroupSetsRequest) (*SearchReadGroupSetsResponse, error)
	// Updates a read group set.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// This method supports patch semantics.
	UpdateReadGroupSet(context.Context, *UpdateReadGroupSetRequest) (*ReadGroupSet, error)
	// Deletes a read group set.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	DeleteReadGroupSet(context.Context, *DeleteReadGroupSetRequest) (*google_protobuf1.Empty, error)
	// Gets a read group set by ID.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	GetReadGroupSet(context.Context, *GetReadGroupSetRequest) (*ReadGroupSet, error)
	// Lists fixed width coverage buckets for a read group set, each of which
	// correspond to a range of a reference sequence. Each bucket summarizes
	// coverage information across its corresponding genomic range.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Coverage is defined as the number of reads which are aligned to a given
	// base in the reference sequence. Coverage buckets are available at several
	// precomputed bucket widths, enabling retrieval of various coverage 'zoom
	// levels'. The caller must have READ permissions for the target read group
	// set.
	ListCoverageBuckets(context.Context, *ListCoverageBucketsRequest) (*ListCoverageBucketsResponse, error)
	// Gets a list of reads for one or more read group sets.
	//
	// For the definitions of read group sets and other genomics resources, see
	// [Fundamentals of Google
	// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
	//
	// Reads search operates over a genomic coordinate space of reference sequence
	// & position defined over the reference sequences to which the requested
	// read group sets are aligned.
	//
	// If a target positional range is specified, search returns all reads whose
	// alignment to the reference genome overlap the range. A query which
	// specifies only read group set IDs yields all reads in those read group
	// sets, including unmapped reads.
	//
	// All reads returned (including reads on subsequent pages) are ordered by
	// genomic coordinate (by reference sequence, then position). Reads with
	// equivalent genomic coordinates are returned in an unspecified order. This
	// order is consistent, such that two queries for the same content (regardless
	// of page size) yield reads in the same order across their respective streams
	// of paginated responses.
	//
	// Implements
	// [GlobalAllianceApi.searchReads](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L85).
	SearchReads(context.Context, *SearchReadsRequest) (*SearchReadsResponse, error)
}

func RegisterReadServiceV1Server(s *grpc.Server, srv ReadServiceV1Server) {
	s.RegisterService(&_ReadServiceV1_serviceDesc, srv)
}

func _ReadServiceV1_ImportReadGroupSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportReadGroupSetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadServiceV1Server).ImportReadGroupSets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.ReadServiceV1/ImportReadGroupSets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadServiceV1Server).ImportReadGroupSets(ctx, req.(*ImportReadGroupSetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadServiceV1_ExportReadGroupSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportReadGroupSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadServiceV1Server).ExportReadGroupSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.ReadServiceV1/ExportReadGroupSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadServiceV1Server).ExportReadGroupSet(ctx, req.(*ExportReadGroupSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadServiceV1_SearchReadGroupSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchReadGroupSetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadServiceV1Server).SearchReadGroupSets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.ReadServiceV1/SearchReadGroupSets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadServiceV1Server).SearchReadGroupSets(ctx, req.(*SearchReadGroupSetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadServiceV1_UpdateReadGroupSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReadGroupSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadServiceV1Server).UpdateReadGroupSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.ReadServiceV1/UpdateReadGroupSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadServiceV1Server).UpdateReadGroupSet(ctx, req.(*UpdateReadGroupSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadServiceV1_DeleteReadGroupSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReadGroupSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadServiceV1Server).DeleteReadGroupSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.ReadServiceV1/DeleteReadGroupSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadServiceV1Server).DeleteReadGroupSet(ctx, req.(*DeleteReadGroupSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadServiceV1_GetReadGroupSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReadGroupSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadServiceV1Server).GetReadGroupSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.ReadServiceV1/GetReadGroupSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadServiceV1Server).GetReadGroupSet(ctx, req.(*GetReadGroupSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadServiceV1_ListCoverageBuckets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCoverageBucketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadServiceV1Server).ListCoverageBuckets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.ReadServiceV1/ListCoverageBuckets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadServiceV1Server).ListCoverageBuckets(ctx, req.(*ListCoverageBucketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadServiceV1_SearchReads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchReadsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadServiceV1Server).SearchReads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.genomics.v1.ReadServiceV1/SearchReads",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadServiceV1Server).SearchReads(ctx, req.(*SearchReadsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ReadServiceV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "google.genomics.v1.ReadServiceV1",
	HandlerType: (*ReadServiceV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ImportReadGroupSets",
			Handler:    _ReadServiceV1_ImportReadGroupSets_Handler,
		},
		{
			MethodName: "ExportReadGroupSet",
			Handler:    _ReadServiceV1_ExportReadGroupSet_Handler,
		},
		{
			MethodName: "SearchReadGroupSets",
			Handler:    _ReadServiceV1_SearchReadGroupSets_Handler,
		},
		{
			MethodName: "UpdateReadGroupSet",
			Handler:    _ReadServiceV1_UpdateReadGroupSet_Handler,
		},
		{
			MethodName: "DeleteReadGroupSet",
			Handler:    _ReadServiceV1_DeleteReadGroupSet_Handler,
		},
		{
			MethodName: "GetReadGroupSet",
			Handler:    _ReadServiceV1_GetReadGroupSet_Handler,
		},
		{
			MethodName: "ListCoverageBuckets",
			Handler:    _ReadServiceV1_ListCoverageBuckets_Handler,
		},
		{
			MethodName: "SearchReads",
			Handler:    _ReadServiceV1_SearchReads_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/genomics/v1/reads.proto",
}

func (m *SearchReadGroupSetsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchReadGroupSetsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatasetIds) > 0 {
		for _, s := range m.DatasetIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *SearchReadGroupSetsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchReadGroupSetsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReadGroupSets) > 0 {
		for _, msg := range m.ReadGroupSets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintReads(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *ImportReadGroupSetsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportReadGroupSetsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatasetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.DatasetId)))
		i += copy(dAtA[i:], m.DatasetId)
	}
	if len(m.SourceUris) > 0 {
		for _, s := range m.SourceUris {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ReferenceSetId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReferenceSetId)))
		i += copy(dAtA[i:], m.ReferenceSetId)
	}
	if m.PartitionStrategy != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.PartitionStrategy))
	}
	return i, nil
}

func (m *ImportReadGroupSetsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportReadGroupSetsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReadGroupSetIds) > 0 {
		for _, s := range m.ReadGroupSetIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ExportReadGroupSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportReadGroupSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if len(m.ExportUri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ExportUri)))
		i += copy(dAtA[i:], m.ExportUri)
	}
	if len(m.ReadGroupSetId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReadGroupSetId)))
		i += copy(dAtA[i:], m.ReadGroupSetId)
	}
	if len(m.ReferenceNames) > 0 {
		for _, s := range m.ReferenceNames {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *UpdateReadGroupSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateReadGroupSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReadGroupSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReadGroupSetId)))
		i += copy(dAtA[i:], m.ReadGroupSetId)
	}
	if m.ReadGroupSet != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.ReadGroupSet.Size()))
		n1, err := m.ReadGroupSet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UpdateMask != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.UpdateMask.Size()))
		n2, err := m.UpdateMask.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *DeleteReadGroupSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReadGroupSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReadGroupSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReadGroupSetId)))
		i += copy(dAtA[i:], m.ReadGroupSetId)
	}
	return i, nil
}

func (m *GetReadGroupSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetReadGroupSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReadGroupSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReadGroupSetId)))
		i += copy(dAtA[i:], m.ReadGroupSetId)
	}
	return i, nil
}

func (m *ListCoverageBucketsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCoverageBucketsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReadGroupSetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReadGroupSetId)))
		i += copy(dAtA[i:], m.ReadGroupSetId)
	}
	if len(m.ReferenceName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReferenceName)))
		i += copy(dAtA[i:], m.ReferenceName)
	}
	if m.Start != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.End))
	}
	if m.TargetBucketWidth != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.TargetBucketWidth))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *CoverageBucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoverageBucket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.Range.Size()))
		n3, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.MeanCoverage != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Reads(dAtA, i, uint32(math.Float32bits(float32(m.MeanCoverage))))
	}
	return i, nil
}

func (m *ListCoverageBucketsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCoverageBucketsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BucketWidth != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.BucketWidth))
	}
	if len(m.CoverageBuckets) > 0 {
		for _, msg := range m.CoverageBuckets {
			dAtA[i] = 0x12
			i++
			i = encodeVarintReads(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *SearchReadsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchReadsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReadGroupSetIds) > 0 {
		for _, s := range m.ReadGroupSetIds {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.PageSize))
	}
	if len(m.ReadGroupIds) > 0 {
		for _, s := range m.ReadGroupIds {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ReferenceName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReferenceName)))
		i += copy(dAtA[i:], m.ReferenceName)
	}
	if m.Start != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *SearchReadsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchReadsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Alignments) > 0 {
		for _, msg := range m.Alignments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintReads(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *StreamReadsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamReadsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProjectId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ProjectId)))
		i += copy(dAtA[i:], m.ProjectId)
	}
	if len(m.ReadGroupSetId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReadGroupSetId)))
		i += copy(dAtA[i:], m.ReadGroupSetId)
	}
	if len(m.ReferenceName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReads(dAtA, i, uint64(len(m.ReferenceName)))
		i += copy(dAtA[i:], m.ReferenceName)
	}
	if m.Start != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.End))
	}
	if m.Shard != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.Shard))
	}
	if m.TotalShards != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintReads(dAtA, i, uint64(m.TotalShards))
	}
	return i, nil
}

func (m *StreamReadsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamReadsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Alignments) > 0 {
		for _, msg := range m.Alignments {
			dAtA[i] = 0xa
			i++
			i = encodeVarintReads(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Reads(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Reads(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintReads(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SearchReadGroupSetsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.DatasetIds) > 0 {
		for _, s := range m.DatasetIds {
			l = len(s)
			n += 1 + l + sovReads(uint64(l))
		}
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovReads(uint64(m.PageSize))
	}
	return n
}

func (m *SearchReadGroupSetsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ReadGroupSets) > 0 {
		for _, e := range m.ReadGroupSets {
			l = e.Size()
			n += 1 + l + sovReads(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	return n
}

func (m *ImportReadGroupSetsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.DatasetId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if len(m.SourceUris) > 0 {
		for _, s := range m.SourceUris {
			l = len(s)
			n += 1 + l + sovReads(uint64(l))
		}
	}
	l = len(m.ReferenceSetId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if m.PartitionStrategy != 0 {
		n += 1 + sovReads(uint64(m.PartitionStrategy))
	}
	return n
}

func (m *ImportReadGroupSetsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.ReadGroupSetIds) > 0 {
		for _, s := range m.ReadGroupSetIds {
			l = len(s)
			n += 1 + l + sovReads(uint64(l))
		}
	}
	return n
}

func (m *ExportReadGroupSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	l = len(m.ExportUri)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	l = len(m.ReadGroupSetId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if len(m.ReferenceNames) > 0 {
		for _, s := range m.ReferenceNames {
			l = len(s)
			n += 1 + l + sovReads(uint64(l))
		}
	}
	return n
}

func (m *UpdateReadGroupSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReadGroupSetId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if m.ReadGroupSet != nil {
		l = m.ReadGroupSet.Size()
		n += 1 + l + sovReads(uint64(l))
	}
	if m.UpdateMask != nil {
		l = m.UpdateMask.Size()
		n += 1 + l + sovReads(uint64(l))
	}
	return n
}

func (m *DeleteReadGroupSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReadGroupSetId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	return n
}

func (m *GetReadGroupSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReadGroupSetId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	return n
}

func (m *ListCoverageBucketsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReadGroupSetId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	l = len(m.ReferenceName)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovReads(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovReads(uint64(m.End))
	}
	if m.TargetBucketWidth != 0 {
		n += 1 + sovReads(uint64(m.TargetBucketWidth))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovReads(uint64(m.PageSize))
	}
	return n
}

func (m *CoverageBucket) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovReads(uint64(l))
	}
	if m.MeanCoverage != 0 {
		n += 5
	}
	return n
}

func (m *ListCoverageBucketsResponse) Size() (n int) {
	var l int
	_ = l
	if m.BucketWidth != 0 {
		n += 1 + sovReads(uint64(m.BucketWidth))
	}
	if len(m.CoverageBuckets) > 0 {
		for _, e := range m.CoverageBuckets {
			l = e.Size()
			n += 1 + l + sovReads(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	return n
}

func (m *SearchReadsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.ReadGroupSetIds) > 0 {
		for _, s := range m.ReadGroupSetIds {
			l = len(s)
			n += 1 + l + sovReads(uint64(l))
		}
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovReads(uint64(m.PageSize))
	}
	if len(m.ReadGroupIds) > 0 {
		for _, s := range m.ReadGroupIds {
			l = len(s)
			n += 1 + l + sovReads(uint64(l))
		}
	}
	l = len(m.ReferenceName)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovReads(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovReads(uint64(m.End))
	}
	return n
}

func (m *SearchReadsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Alignments) > 0 {
		for _, e := range m.Alignments {
			l = e.Size()
			n += 1 + l + sovReads(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	return n
}

func (m *StreamReadsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	l = len(m.ReadGroupSetId)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	l = len(m.ReferenceName)
	if l > 0 {
		n += 1 + l + sovReads(uint64(l))
	}
	if m.Start != 0 {
		n += 1 + sovReads(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovReads(uint64(m.End))
	}
	if m.Shard != 0 {
		n += 1 + sovReads(uint64(m.Shard))
	}
	if m.TotalShards != 0 {
		n += 1 + sovReads(uint64(m.TotalShards))
	}
	return n
}

func (m *StreamReadsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Alignments) > 0 {
		for _, e := range m.Alignments {
			l = e.Size()
			n += 1 + l + sovReads(uint64(l))
		}
	}
	return n
}

func sovReads(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozReads(x uint64) (n int) {
	return sovReads(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SearchReadGroupSetsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReadGroupSetsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReadGroupSetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetIds = append(m.DatasetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchReadGroupSetsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReadGroupSetsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReadGroupSetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSets = append(m.ReadGroupSets, &ReadGroupSet{})
			if err := m.ReadGroupSets[len(m.ReadGroupSets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportReadGroupSetsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportReadGroupSetsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportReadGroupSetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceUris", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceUris = append(m.SourceUris, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionStrategy", wireType)
			}
			m.PartitionStrategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionStrategy |= (ImportReadGroupSetsRequest_PartitionStrategy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportReadGroupSetsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportReadGroupSetsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportReadGroupSetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSetIds = append(m.ReadGroupSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportReadGroupSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportReadGroupSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportReadGroupSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceNames = append(m.ReferenceNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateReadGroupSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateReadGroupSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateReadGroupSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadGroupSet == nil {
				m.ReadGroupSet = &ReadGroupSet{}
			}
			if err := m.ReadGroupSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMask", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateMask == nil {
				m.UpdateMask = &google_protobuf2.FieldMask{}
			}
			if err := m.UpdateMask.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReadGroupSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteReadGroupSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteReadGroupSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetReadGroupSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetReadGroupSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetReadGroupSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCoverageBucketsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCoverageBucketsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCoverageBucketsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBucketWidth", wireType)
			}
			m.TargetBucketWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBucketWidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoverageBucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoverageBucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoverageBucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeanCoverage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.MeanCoverage = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCoverageBucketsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCoverageBucketsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCoverageBucketsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketWidth", wireType)
			}
			m.BucketWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketWidth |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverageBuckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverageBuckets = append(m.CoverageBuckets, &CoverageBucket{})
			if err := m.CoverageBuckets[len(m.CoverageBuckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchReadsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReadsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReadsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSetIds = append(m.ReadGroupSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupIds = append(m.ReadGroupIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchReadsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReadsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReadsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alignments = append(m.Alignments, &Read{})
			if err := m.Alignments[len(m.Alignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamReadsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamReadsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamReadsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroupSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroupSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			m.Shard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shard |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShards", wireType)
			}
			m.TotalShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalShards |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamReadsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReads
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamReadsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamReadsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReads
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReads
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alignments = append(m.Alignments, &Read{})
			if err := m.Alignments[len(m.Alignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReads(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReads
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReads(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReads
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReads
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReads
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthReads
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowReads
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipReads(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthReads = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReads   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/genomics/v1/reads.proto", fileDescriptorReads) }

var fileDescriptorReads = []byte{
	// 1355 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0x67, 0xec, 0xb8, 0x6d, 0x9e, 0x9b, 0xc4, 0x19, 0x97, 0xe2, 0x38, 0x24, 0x84, 0x2d, 0x6d,
	0x43, 0xa0, 0x36, 0x31, 0x42, 0x45, 0xa9, 0x90, 0x48, 0x5b, 0x27, 0x18, 0x25, 0xad, 0xb5, 0x4e,
	0x40, 0x70, 0x59, 0x4d, 0xec, 0xc9, 0x76, 0x89, 0xbd, 0xbb, 0x9d, 0x19, 0xa7, 0xff, 0xd4, 0x4b,
	0x6f, 0x20, 0x01, 0x07, 0xc4, 0x89, 0x2b, 0x57, 0x8e, 0x88, 0xaf, 0x80, 0xc4, 0x05, 0xc4, 0x85,
	0x23, 0xaa, 0x10, 0x1f, 0x80, 0x13, 0x47, 0x34, 0xb3, 0xbb, 0xce, 0xae, 0x77, 0xdc, 0xb8, 0x8a,
	0xc4, 0x6d, 0xf7, 0xbd, 0xb7, 0x6f, 0x7e, 0xef, 0xcf, 0xbc, 0xf7, 0x5b, 0x58, 0xb4, 0x3d, 0xcf,
	0xee, 0xd2, 0xaa, 0x4d, 0x5d, 0xaf, 0xe7, 0xb4, 0x79, 0xf5, 0x70, 0xb5, 0xca, 0x28, 0xe9, 0xf0,
	0x8a, 0xcf, 0x3c, 0xe1, 0x61, 0x1c, 0xe8, 0x2b, 0x91, 0xbe, 0x72, 0xb8, 0x5a, 0x7e, 0x39, 0xfc,
	0x86, 0xf8, 0x4e, 0x95, 0xb8, 0xae, 0x27, 0x88, 0x70, 0x3c, 0x37, 0xfc, 0xa2, 0xac, 0xf5, 0x48,
	0x5c, 0x9b, 0x86, 0xfa, 0x4b, 0x23, 0x4e, 0x24, 0x5d, 0xc7, 0x76, 0x7b, 0xd4, 0x15, 0xa1, 0xdd,
	0xc5, 0x11, 0x76, 0x36, 0xf3, 0xfa, 0x3e, 0xa7, 0x91, 0xd9, 0x85, 0xd0, 0xac, 0xeb, 0xb9, 0x36,
	0xeb, 0xbb, 0xae, 0xe3, 0xda, 0x55, 0xcf, 0xa7, 0x2c, 0x81, 0x69, 0x3e, 0x34, 0x52, 0x6f, 0x7b,
	0xfd, 0xfd, 0x2a, 0xed, 0xf9, 0xe2, 0x41, 0xa8, 0x5c, 0x1a, 0x56, 0xee, 0x3b, 0xb4, 0xdb, 0xb1,
	0x7a, 0x84, 0x1f, 0x04, 0x16, 0xc6, 0x97, 0x08, 0xca, 0x2d, 0x4a, 0x58, 0xfb, 0x8e, 0x49, 0x49,
	0x67, 0x53, 0x02, 0x68, 0x51, 0xc1, 0x4d, 0x7a, 0xb7, 0x4f, 0xb9, 0xc0, 0xaf, 0x40, 0xbe, 0x43,
	0x04, 0xe1, 0x54, 0x58, 0x4e, 0x87, 0x97, 0xd0, 0x52, 0x76, 0x79, 0xd2, 0x84, 0x50, 0xd4, 0xe8,
	0x70, 0xbc, 0x00, 0xe0, 0x13, 0x9b, 0x5a, 0xc2, 0x3b, 0xa0, 0x6e, 0x29, 0xb3, 0x84, 0x96, 0x27,
	0xcd, 0x49, 0x29, 0xd9, 0x91, 0x02, 0x8c, 0x61, 0xc2, 0x25, 0x3d, 0x5a, 0xca, 0x2a, 0x85, 0x7a,
	0xc6, 0xf3, 0xa0, 0x0c, 0x2c, 0xee, 0x3c, 0xa4, 0xa5, 0x89, 0x25, 0xb4, 0x9c, 0x33, 0xcf, 0x48,
	0x41, 0xcb, 0x79, 0x48, 0x8d, 0xaf, 0x11, 0xcc, 0x6b, 0xf1, 0x70, 0xdf, 0x73, 0x39, 0xc5, 0x1f,
	0xc0, 0x8c, 0xcc, 0x94, 0xa5, 0x52, 0x65, 0x71, 0x2a, 0x02, 0x50, 0xf9, 0xda, 0x52, 0x25, 0x5d,
	0xce, 0x4a, 0xdc, 0x87, 0x39, 0xc5, 0xe2, 0x1e, 0xf1, 0x25, 0x98, 0x71, 0xe9, 0x7d, 0x61, 0xa5,
	0xe0, 0x4f, 0x49, 0x71, 0x33, 0x0a, 0xc1, 0xf8, 0x23, 0x03, 0xe5, 0x46, 0xcf, 0xf7, 0x98, 0xd0,
	0x66, 0x68, 0x01, 0xe0, 0x28, 0x43, 0x25, 0x14, 0x24, 0x60, 0x90, 0x20, 0x99, 0x40, 0xee, 0xf5,
	0x59, 0x9b, 0x5a, 0x7d, 0xe6, 0xf0, 0x52, 0x26, 0x48, 0x60, 0x20, 0xda, 0x65, 0x0e, 0xc7, 0xcb,
	0x50, 0x60, 0x74, 0x9f, 0x32, 0xea, 0xb6, 0xa9, 0x15, 0x7a, 0x99, 0x50, 0x5e, 0xa6, 0x07, 0xf2,
	0x96, 0x72, 0xe5, 0x01, 0xf6, 0x09, 0x13, 0x8e, 0xac, 0xbe, 0xc5, 0x05, 0x23, 0x82, 0xda, 0x0f,
	0x4a, 0xb9, 0x25, 0xb4, 0x3c, 0x5d, 0x7b, 0x5f, 0x17, 0xfd, 0x68, 0xd4, 0x95, 0x66, 0xe4, 0xa8,
	0x15, 0xfa, 0x31, 0x67, 0xfd, 0x61, 0x91, 0x61, 0xc1, 0x6c, 0xca, 0x0e, 0x1b, 0xb0, 0xd8, 0x5c,
	0x37, 0x77, 0x1a, 0x3b, 0x8d, 0xdb, 0xb7, 0xac, 0xd6, 0x8e, 0xb9, 0xbe, 0x53, 0xdf, 0xfc, 0xc4,
	0xda, 0xbd, 0xd5, 0x6a, 0xd6, 0x6f, 0x34, 0x36, 0x1a, 0xf5, 0x9b, 0x85, 0x17, 0xf0, 0x4b, 0x50,
	0x6c, 0xd6, 0x4d, 0x6b, 0xa3, 0xb1, 0x55, 0xb7, 0xe4, 0x43, 0x6b, 0x7d, 0xbb, 0xb9, 0x55, 0x2f,
	0x20, 0x3c, 0x05, 0x93, 0xdb, 0x75, 0x73, 0xb3, 0x6e, 0xad, 0x6f, 0x6d, 0x15, 0x32, 0xc6, 0x87,
	0x30, 0xaf, 0xc5, 0x18, 0xd6, 0xfa, 0x0d, 0xc0, 0xc9, 0x5a, 0xc7, 0x7a, 0x70, 0x26, 0x5e, 0xcc,
	0x46, 0x87, 0x1b, 0x3f, 0x20, 0x98, 0xab, 0xdf, 0x1f, 0x76, 0x16, 0xab, 0x92, 0xcf, 0xbc, 0xcf,
	0x68, 0x3b, 0x5e, 0xa5, 0x50, 0xd2, 0xe8, 0x48, 0x35, 0x55, 0xdf, 0xca, 0x2a, 0x45, 0x5d, 0x1c,
	0x48, 0x76, 0x99, 0x83, 0x5f, 0x87, 0xd9, 0x14, 0x90, 0xb0, 0xa5, 0xa7, 0x93, 0x38, 0xf0, 0x65,
	0xd9, 0x9f, 0x51, 0x39, 0x65, 0xbb, 0xf3, 0xd2, 0x84, 0x02, 0x7c, 0x54, 0xcd, 0x5b, 0x52, 0x6a,
	0xfc, 0x82, 0x60, 0x6e, 0xd7, 0xef, 0x10, 0x41, 0x75, 0x78, 0xb5, 0x27, 0x22, 0xed, 0x89, 0x1b,
	0x30, 0x9d, 0x34, 0x55, 0xf8, 0xc7, 0xb9, 0x10, 0x67, 0xe3, 0x9e, 0xf0, 0x35, 0xc8, 0xf7, 0x15,
	0x1e, 0x35, 0x1e, 0x54, 0x78, 0xf9, 0x5a, 0x39, 0x72, 0x12, 0x4d, 0x90, 0xca, 0x86, 0x9c, 0x20,
	0xdb, 0x84, 0x1f, 0x98, 0x10, 0x98, 0xcb, 0x67, 0x63, 0x03, 0xe6, 0x6e, 0xd2, 0x2e, 0x3d, 0x69,
	0x30, 0xc6, 0x0d, 0x38, 0xbf, 0x49, 0xc5, 0x09, 0x9d, 0x3c, 0xc9, 0x40, 0x79, 0xcb, 0xe1, 0xe2,
	0x86, 0x77, 0x48, 0x19, 0xb1, 0xe9, 0xf5, 0x7e, 0xfb, 0x20, 0x76, 0x63, 0x9f, 0x23, 0xb7, 0x17,
	0x61, 0x3a, 0x59, 0xcd, 0xb0, 0xea, 0x53, 0x89, 0x62, 0xe2, 0x73, 0x90, 0xe3, 0x82, 0x30, 0xa1,
	0x2e, 0x6e, 0xd6, 0x0c, 0x5e, 0x70, 0x01, 0xb2, 0xd4, 0xed, 0xa8, 0x0b, 0x9a, 0x35, 0xe5, 0x23,
	0xae, 0x40, 0x51, 0x10, 0x66, 0x53, 0x61, 0xed, 0x29, 0x48, 0xd6, 0x3d, 0xa7, 0x23, 0xee, 0x94,
	0x4e, 0x29, 0x8b, 0xd9, 0x40, 0x15, 0x80, 0xfd, 0x58, 0x2a, 0x86, 0x86, 0xeb, 0xe9, 0xe1, 0xe1,
	0x9a, 0x18, 0xa4, 0x67, 0x86, 0x06, 0xe9, 0x3e, 0x4c, 0x27, 0xe3, 0xc7, 0x55, 0xc8, 0xa9, 0x65,
	0xa5, 0x62, 0xcd, 0xd7, 0xe6, 0xb4, 0xfd, 0x21, 0x0d, 0xcc, 0xc0, 0x0e, 0x5f, 0x80, 0xa9, 0x1e,
	0x25, 0xae, 0xd5, 0x0e, 0xfd, 0xa8, 0xc6, 0xca, 0x98, 0x67, 0xa5, 0x30, 0xf2, 0x6d, 0xfc, 0x84,
	0x60, 0x5e, 0x9b, 0xec, 0xf0, 0x12, 0xbf, 0x0a, 0x67, 0x13, 0xc1, 0x22, 0x15, 0x6c, 0x7e, 0x2f,
	0x16, 0xe6, 0x36, 0x14, 0xa2, 0x23, 0xc2, 0xc4, 0x04, 0x83, 0x32, 0x5f, 0x33, 0x74, 0x18, 0x93,
	0x27, 0x99, 0x33, 0xed, 0xe4, 0xc9, 0xba, 0xc1, 0x9e, 0xd5, 0x0d, 0xf6, 0x7f, 0x10, 0xe0, 0xa3,
	0x55, 0x33, 0x68, 0x8f, 0xe7, 0x99, 0x3a, 0x43, 0x15, 0xca, 0x3e, 0xb3, 0x42, 0x43, 0xab, 0x0e,
	0xbf, 0x96, 0xb8, 0xb8, 0xf2, 0x90, 0x9c, 0x3a, 0xe4, 0xe8, 0x5a, 0xca, 0x13, 0xd2, 0x2d, 0x78,
	0xfa, 0x99, 0x2d, 0x78, 0x46, 0xd3, 0x82, 0x93, 0x83, 0x16, 0x34, 0xee, 0x41, 0x31, 0x11, 0x73,
	0x58, 0xa5, 0x77, 0x01, 0x06, 0x24, 0x25, 0xda, 0xa8, 0xa5, 0x51, 0x03, 0xc4, 0x8c, 0xd9, 0x8e,
	0xbd, 0x46, 0xff, 0x96, 0xd9, 0x16, 0x8c, 0x92, 0x5e, 0x22, 0xdb, 0xc7, 0x0c, 0x66, 0xed, 0x5d,
	0xcd, 0xfc, 0x1f, 0x77, 0x55, 0xda, 0xdd, 0x21, 0xac, 0xa3, 0x6e, 0x67, 0xce, 0x0c, 0x5e, 0x64,
	0x37, 0x0b, 0x4f, 0x90, 0xae, 0xa5, 0x5e, 0xb9, 0xaa, 0x45, 0xce, 0xcc, 0x2b, 0x59, 0x4b, 0x89,
	0x8c, 0xdb, 0x50, 0x4c, 0xc4, 0x79, 0xd2, 0x0c, 0xd7, 0xbe, 0x45, 0x70, 0x2e, 0xf0, 0xe8, 0xb8,
	0xb6, 0xd4, 0xb6, 0x28, 0x3b, 0x74, 0xda, 0x14, 0x3f, 0x86, 0x7c, 0xec, 0x24, 0x7c, 0x49, 0xe7,
	0x2d, 0x9d, 0xf2, 0xf2, 0xe5, 0x63, 0xed, 0x02, 0xc8, 0xc6, 0xfc, 0x93, 0xdf, 0xff, 0xfa, 0x26,
	0xf3, 0xa2, 0x51, 0x18, 0x30, 0xe7, 0x35, 0xae, 0xcc, 0xd6, 0xd0, 0xca, 0x5b, 0xa8, 0xf6, 0xdb,
	0x24, 0x4c, 0xc5, 0xe0, 0x7c, 0xb4, 0x8a, 0x3f, 0x47, 0x50, 0xd4, 0x2c, 0x74, 0x5c, 0x79, 0x3e,
	0x76, 0x52, 0x5e, 0x88, 0xec, 0x63, 0xcc, 0xb7, 0x72, 0x3b, 0x62, 0xbe, 0xc6, 0x05, 0x85, 0x6b,
	0xc1, 0x28, 0x0d, 0xf3, 0x66, 0xbe, 0xe6, 0x28, 0xa7, 0x6b, 0x68, 0x05, 0x7f, 0x87, 0x00, 0xa7,
	0xf9, 0x00, 0xbe, 0xa2, 0x83, 0x32, 0x92, 0x37, 0x1c, 0x87, 0xe4, 0xaa, 0x42, 0xb2, 0x6a, 0xbc,
	0x99, 0x42, 0x52, 0x7d, 0x94, 0xea, 0xdb, 0xc7, 0x6b, 0x01, 0xa3, 0x08, 0xd1, 0x15, 0x35, 0x34,
	0x57, 0x9f, 0xa9, 0xd1, 0xfc, 0xbc, 0x5c, 0x1d, 0xdb, 0x3e, 0xac, 0xe9, 0xe8, 0xdc, 0x55, 0xb9,
	0xfa, 0x4c, 0xa2, 0xfb, 0x1e, 0x01, 0x4e, 0x73, 0x13, 0x7d, 0xee, 0x46, 0x72, 0x98, 0xf2, 0xb1,
	0x04, 0xc4, 0x78, 0x4f, 0x81, 0xb9, 0x5a, 0xbb, 0x38, 0x5e, 0xfa, 0x86, 0x78, 0x0e, 0xfe, 0x02,
	0x01, 0x4e, 0xb3, 0x0e, 0x3d, 0xcc, 0x91, 0xec, 0xa4, 0x7c, 0x3e, 0x45, 0x71, 0xea, 0xf2, 0x0f,
	0xca, 0xb8, 0xa2, 0xc0, 0x5d, 0x5e, 0x19, 0x0f, 0x1c, 0xfe, 0x0a, 0xc1, 0xcc, 0x10, 0x75, 0xc1,
	0x2b, 0x3a, 0x24, 0x7a, 0x7e, 0x33, 0x46, 0xb6, 0x42, 0x40, 0x78, 0x4c, 0x40, 0x3f, 0x22, 0x28,
	0x6a, 0x16, 0xb3, 0xbe, 0xc5, 0x46, 0xd3, 0x25, 0x7d, 0x8b, 0x3d, 0x63, 0xe3, 0x47, 0x55, 0xc5,
	0xef, 0x8c, 0x85, 0xb3, 0x1a, 0xad, 0xef, 0x70, 0xf3, 0xe3, 0x47, 0x90, 0x8f, 0x6d, 0xa8, 0x11,
	0x53, 0x2d, 0xb5, 0xb6, 0x47, 0x4c, 0xb5, 0xf4, 0xaa, 0xd3, 0x4c, 0xb5, 0xa3, 0xce, 0xbf, 0x7e,
	0xf7, 0xe7, 0xa7, 0x8b, 0xe8, 0xd7, 0xa7, 0x8b, 0xe8, 0xcf, 0xa7, 0x8b, 0x08, 0xce, 0xb7, 0xbd,
	0x9e, 0xc6, 0xed, 0x75, 0x50, 0x1e, 0x9b, 0xb2, 0x5f, 0x9a, 0xe8, 0xd3, 0xb5, 0xc8, 0xc2, 0xeb,
	0x12, 0xd7, 0xae, 0x78, 0xcc, 0x96, 0x3f, 0xf6, 0xaa, 0x9b, 0xaa, 0x81, 0x8a, 0xf8, 0x0e, 0x8f,
	0xff, 0xec, 0x5f, 0x8b, 0x9e, 0xff, 0x45, 0x68, 0xef, 0x94, 0xb2, 0x7c, 0xfb, 0xbf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x2b, 0xa9, 0xae, 0xb4, 0xaf, 0x10, 0x00, 0x00,
}
