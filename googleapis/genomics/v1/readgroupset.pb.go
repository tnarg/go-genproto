// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: google/genomics/v1/readgroupset.proto

package genomics

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf3 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A read group set is a logical collection of read groups, which are
// collections of reads produced by a sequencer. A read group set typically
// models reads corresponding to one sample, sequenced one way, and aligned one
// way.
//
// * A read group set belongs to one dataset.
// * A read group belongs to one read group set.
// * A read belongs to one read group.
//
// For more genomics resource definitions, see [Fundamentals of Google
// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
type ReadGroupSet struct {
	// The server-generated read group set ID, unique for all read group sets.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The dataset to which this read group set belongs.
	DatasetId string `protobuf:"bytes,2,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
	// The reference set to which the reads in this read group set are aligned.
	ReferenceSetId string `protobuf:"bytes,3,opt,name=reference_set_id,json=referenceSetId,proto3" json:"reference_set_id,omitempty"`
	// The read group set name. By default this will be initialized to the sample
	// name of the sequenced data contained in this set.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// The filename of the original source file for this read group set, if any.
	Filename string `protobuf:"bytes,5,opt,name=filename,proto3" json:"filename,omitempty"`
	// The read groups in this set. There are typically 1-10 read groups in a read
	// group set.
	ReadGroups []*ReadGroup `protobuf:"bytes,6,rep,name=read_groups,json=readGroups" json:"read_groups,omitempty"`
	// A map of additional read group set information.
	Info map[string]*google_protobuf3.ListValue `protobuf:"bytes,7,rep,name=info" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ReadGroupSet) Reset()                    { *m = ReadGroupSet{} }
func (m *ReadGroupSet) String() string            { return proto.CompactTextString(m) }
func (*ReadGroupSet) ProtoMessage()               {}
func (*ReadGroupSet) Descriptor() ([]byte, []int) { return fileDescriptorReadgroupset, []int{0} }

func (m *ReadGroupSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ReadGroupSet) GetDatasetId() string {
	if m != nil {
		return m.DatasetId
	}
	return ""
}

func (m *ReadGroupSet) GetReferenceSetId() string {
	if m != nil {
		return m.ReferenceSetId
	}
	return ""
}

func (m *ReadGroupSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ReadGroupSet) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *ReadGroupSet) GetReadGroups() []*ReadGroup {
	if m != nil {
		return m.ReadGroups
	}
	return nil
}

func (m *ReadGroupSet) GetInfo() map[string]*google_protobuf3.ListValue {
	if m != nil {
		return m.Info
	}
	return nil
}

func init() {
	proto.RegisterType((*ReadGroupSet)(nil), "google.genomics.v1.ReadGroupSet")
}
func (m *ReadGroupSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadGroupSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintReadgroupset(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.DatasetId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintReadgroupset(dAtA, i, uint64(len(m.DatasetId)))
		i += copy(dAtA[i:], m.DatasetId)
	}
	if len(m.ReferenceSetId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintReadgroupset(dAtA, i, uint64(len(m.ReferenceSetId)))
		i += copy(dAtA[i:], m.ReferenceSetId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintReadgroupset(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Filename) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintReadgroupset(dAtA, i, uint64(len(m.Filename)))
		i += copy(dAtA[i:], m.Filename)
	}
	if len(m.ReadGroups) > 0 {
		for _, msg := range m.ReadGroups {
			dAtA[i] = 0x32
			i++
			i = encodeVarintReadgroupset(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x3a
			i++
			v := m.Info[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovReadgroupset(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovReadgroupset(uint64(len(k))) + msgSize
			i = encodeVarintReadgroupset(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintReadgroupset(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintReadgroupset(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func encodeFixed64Readgroupset(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Readgroupset(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintReadgroupset(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ReadGroupSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovReadgroupset(uint64(l))
	}
	l = len(m.DatasetId)
	if l > 0 {
		n += 1 + l + sovReadgroupset(uint64(l))
	}
	l = len(m.ReferenceSetId)
	if l > 0 {
		n += 1 + l + sovReadgroupset(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovReadgroupset(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovReadgroupset(uint64(l))
	}
	if len(m.ReadGroups) > 0 {
		for _, e := range m.ReadGroups {
			l = e.Size()
			n += 1 + l + sovReadgroupset(uint64(l))
		}
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovReadgroupset(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovReadgroupset(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovReadgroupset(uint64(mapEntrySize))
		}
	}
	return n
}

func sovReadgroupset(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozReadgroupset(x uint64) (n int) {
	return sovReadgroupset(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReadGroupSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReadgroupset
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadGroupSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadGroupSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadgroupset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadgroupset
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadgroupset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadgroupset
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatasetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadgroupset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadgroupset
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadgroupset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadgroupset
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadgroupset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReadgroupset
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadgroupset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReadgroupset
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadGroups = append(m.ReadGroups, &ReadGroup{})
			if err := m.ReadGroups[len(m.ReadGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReadgroupset
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReadgroupset
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]*google_protobuf3.ListValue)
			}
			var mapkey string
			var mapvalue *google_protobuf3.ListValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowReadgroupset
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReadgroupset
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthReadgroupset
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowReadgroupset
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthReadgroupset
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthReadgroupset
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &google_protobuf3.ListValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipReadgroupset(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthReadgroupset
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReadgroupset(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthReadgroupset
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReadgroupset(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReadgroupset
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReadgroupset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReadgroupset
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthReadgroupset
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowReadgroupset
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipReadgroupset(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthReadgroupset = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReadgroupset   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("google/genomics/v1/readgroupset.proto", fileDescriptorReadgroupset) }

var fileDescriptorReadgroupset = []byte{
	// 385 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x92, 0xbf, 0xaa, 0xdb, 0x30,
	0x14, 0xc6, 0x91, 0xf3, 0xa7, 0x8d, 0x52, 0x42, 0xaa, 0xa1, 0x18, 0xd3, 0x84, 0x10, 0x28, 0x84,
	0x0e, 0x72, 0x93, 0x2e, 0x25, 0x85, 0x0c, 0x81, 0x52, 0x02, 0x1d, 0x82, 0x0d, 0x1d, 0xba, 0x04,
	0xc5, 0x3e, 0x36, 0xa2, 0x8e, 0x64, 0x24, 0x39, 0x34, 0x6f, 0xd8, 0xb1, 0x8f, 0x50, 0x32, 0xdf,
	0x07, 0xb8, 0xe3, 0xc5, 0xf2, 0x1f, 0x02, 0xf7, 0x92, 0xed, 0xe8, 0xd3, 0xef, 0x3b, 0xe7, 0xf8,
	0xb3, 0xf0, 0x87, 0x54, 0xca, 0x34, 0x03, 0x3f, 0x05, 0x21, 0x4f, 0x3c, 0xd2, 0xfe, 0x79, 0xe9,
	0x2b, 0x60, 0x71, 0xaa, 0x64, 0x91, 0x6b, 0x30, 0x34, 0x57, 0xd2, 0x48, 0x42, 0x2a, 0x8c, 0x36,
	0x18, 0x3d, 0x2f, 0xbd, 0xf7, 0xb5, 0x95, 0xe5, 0xdc, 0x67, 0x42, 0x48, 0xc3, 0x0c, 0x97, 0x42,
	0x57, 0x0e, 0x6f, 0x7e, 0xaf, 0x71, 0xcd, 0x34, 0x1d, 0xec, 0xe9, 0x58, 0x24, 0xbe, 0x36, 0xaa,
	0x88, 0xea, 0x99, 0xf3, 0x07, 0x07, 0xbf, 0x09, 0x80, 0xc5, 0xdf, 0x4b, 0x47, 0x08, 0x86, 0x8c,
	0xb0, 0xc3, 0x63, 0x17, 0xcd, 0xd0, 0x62, 0x10, 0x38, 0x3c, 0x26, 0x13, 0x8c, 0x63, 0x66, 0x98,
	0x06, 0x73, 0xe0, 0xb1, 0xeb, 0x58, 0x7d, 0x50, 0x2b, 0xbb, 0x98, 0x2c, 0xf0, 0x58, 0x41, 0x02,
	0x0a, 0x44, 0x04, 0x87, 0x1a, 0xea, 0x58, 0x68, 0xd4, 0xea, 0xa1, 0x25, 0x09, 0xee, 0x0a, 0x76,
	0x02, 0xb7, 0x6b, 0x6f, 0x6d, 0x4d, 0x3c, 0xfc, 0x3a, 0xe1, 0x19, 0x58, 0xbd, 0x67, 0xf5, 0xf6,
	0x4c, 0x36, 0x78, 0x58, 0x7e, 0xca, 0xa1, 0x0a, 0xc9, 0xed, 0xcf, 0x3a, 0x8b, 0xe1, 0x6a, 0x42,
	0x9f, 0x67, 0x44, 0xdb, 0xfd, 0x03, 0xac, 0x9a, 0x52, 0x93, 0x0d, 0xee, 0x72, 0x91, 0x48, 0xf7,
	0x95, 0x35, 0x7e, 0xbc, 0x6b, 0x0c, 0xc1, 0xd0, 0x9d, 0x48, 0xe4, 0x37, 0x61, 0xd4, 0x25, 0xb0,
	0x3e, 0x2f, 0xc4, 0x83, 0x56, 0x22, 0x63, 0xdc, 0xf9, 0x0d, 0x97, 0x3a, 0x96, 0xb2, 0x24, 0x9f,
	0x70, 0xef, 0xcc, 0xb2, 0x02, 0x6c, 0x24, 0xc3, 0x95, 0xd7, 0xf4, 0x6f, 0x62, 0xa6, 0x3f, 0xb8,
	0x36, 0x3f, 0x4b, 0x22, 0xa8, 0xc0, 0xb5, 0xf3, 0x05, 0x6d, 0xff, 0xfc, 0xbd, 0x4e, 0xd1, 0xbf,
	0xeb, 0x14, 0xfd, 0xbf, 0x4e, 0x11, 0x7e, 0x17, 0xc9, 0xd3, 0x0b, 0x7b, 0x6d, 0xdf, 0xde, 0x2e,
	0xb6, 0x2f, 0x1b, 0xee, 0xd1, 0xaf, 0x75, 0x03, 0xca, 0x8c, 0x89, 0x94, 0x4a, 0x95, 0x96, 0xbf,
	0xdd, 0x8e, 0xf3, 0xab, 0x2b, 0x96, 0x73, 0x7d, 0xfb, 0x14, 0xbe, 0x36, 0xf5, 0x23, 0x42, 0xc7,
	0xbe, 0x25, 0x3f, 0x3f, 0x05, 0x00, 0x00, 0xff, 0xff, 0x24, 0x45, 0xb8, 0x78, 0x8c, 0x02, 0x00,
	0x00,
}
